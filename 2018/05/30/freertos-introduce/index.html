<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>FreeRTOS Introduction---Based on ESP32 | suda-morris&#39;s Personal Blog | Geek makes life better.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="FreeRTOS">
    <meta name="description" content="FreeRTOS系统配置 FreeRTOS的系统配置文件为FreeRTOSConfig.h，在此配置文件中可以完成FreeRTOS的裁剪和配置。FreeRTOS中的裁剪和配置使用条件编译的方式来实现。   “INCLUDE_”开始的宏，用来表示使能或者失能FreeRTOS中的相应API函数，比如INCLUDE_vTaskPrioritySet用来决定是否可以使用vTaskPrioritySet函数">
<meta name="keywords" content="FreeRTOS">
<meta property="og:type" content="article">
<meta property="og:title" content="FreeRTOS Introduction---Based on ESP32">
<meta property="og:url" content="https://suda-morris.github.io/2018/05/30/freertos-introduce/index.html">
<meta property="og:site_name" content="suda-morris&#39;s Personal Blog">
<meta property="og:description" content="FreeRTOS系统配置 FreeRTOS的系统配置文件为FreeRTOSConfig.h，在此配置文件中可以完成FreeRTOS的裁剪和配置。FreeRTOS中的裁剪和配置使用条件编译的方式来实现。   “INCLUDE_”开始的宏，用来表示使能或者失能FreeRTOS中的相应API函数，比如INCLUDE_vTaskPrioritySet用来决定是否可以使用vTaskPrioritySet函数">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://s1.ax1x.com/2018/07/03/PE0q2D.png">
<meta property="og:image" content="https://s1.ax1x.com/2018/07/03/PEB4SS.png">
<meta property="og:image" content="https://s1.ax1x.com/2018/07/03/PEsHwd.png">
<meta property="og:image" content="https://s1.ax1x.com/2018/07/03/PEyFkn.png">
<meta property="og:image" content="https://s1.ax1x.com/2018/07/03/PEyUne.png">
<meta property="og:image" content="https://s1.ax1x.com/2018/07/04/PEv1LF.png">
<meta property="og:image" content="https://s1.ax1x.com/2018/07/04/PExpTJ.png">
<meta property="og:image" content="https://s1.ax1x.com/2018/07/04/PEzUKK.png">
<meta property="og:updated_time" content="2018-07-19T07:36:39.532Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FreeRTOS Introduction---Based on ESP32">
<meta name="twitter:description" content="FreeRTOS系统配置 FreeRTOS的系统配置文件为FreeRTOSConfig.h，在此配置文件中可以完成FreeRTOS的裁剪和配置。FreeRTOS中的裁剪和配置使用条件编译的方式来实现。   “INCLUDE_”开始的宏，用来表示使能或者失能FreeRTOS中的相应API函数，比如INCLUDE_vTaskPrioritySet用来决定是否可以使用vTaskPrioritySet函数">
<meta name="twitter:image" content="https://s1.ax1x.com/2018/07/03/PE0q2D.png">
    
        <link rel="alternate" type="application/atom+xml" title="suda-morris&#39;s Personal Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">suda-morris</h5>
          <a href="mailto:362953310@qq.com" title="362953310@qq.com" class="mail">362953310@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/suda-morris" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://www.weibo.com/wenris" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about" target="_blank" >
                <i class="icon icon-lg icon-info"></i>
                About
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">FreeRTOS Introduction---Based on ESP32</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">FreeRTOS Introduction---Based on ESP32</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-05-30T12:56:00.000Z" itemprop="datePublished" class="page-time">
  2018-05-30
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Geek-Hobbies/">Geek Hobbies</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FreeRTOS系统配置"><span class="post-toc-number">1.</span> <span class="post-toc-text">FreeRTOS系统配置</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FreeRTOS中的Task"><span class="post-toc-number">2.</span> <span class="post-toc-text">FreeRTOS中的Task</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#尾调用-调度任务创建和删除API函数"><span class="post-toc-number">2.0.1.</span> <span class="post-toc-text">尾调用 调度任务创建和删除API函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#任务挂起和恢复API函数"><span class="post-toc-number">2.0.2.</span> <span class="post-toc-text">任务挂起和恢复API函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#其他常用API函数-部分函数需要在配置文件中开启相关的宏"><span class="post-toc-number">2.0.3.</span> <span class="post-toc-text">其他常用API函数(部分函数需要在配置文件中开启相关的宏)</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FreeRTOS开关中断"><span class="post-toc-number">3.</span> <span class="post-toc-text">FreeRTOS开关中断</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FreeRTOS临界段代码保护"><span class="post-toc-number">4.</span> <span class="post-toc-text">FreeRTOS临界段代码保护</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FreeRTOS列表（双向循环链表）和列表项"><span class="post-toc-number">5.</span> <span class="post-toc-text">FreeRTOS列表（双向循环链表）和列表项</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#列表操作相关API"><span class="post-toc-number">5.0.1.</span> <span class="post-toc-text">列表操作相关API</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FreeRTOS的调度器"><span class="post-toc-number">6.</span> <span class="post-toc-text">FreeRTOS的调度器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#vTaskStartScheduler函数"><span class="post-toc-number">6.0.1.</span> <span class="post-toc-text">vTaskStartScheduler函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#xPortStartScheduler函数"><span class="post-toc-number">6.0.2.</span> <span class="post-toc-text">xPortStartScheduler函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#xTaskCreatePinnedToCore函数"><span class="post-toc-number">6.0.3.</span> <span class="post-toc-text">xTaskCreatePinnedToCore函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#prvInitialiseNewTask函数"><span class="post-toc-number">6.0.4.</span> <span class="post-toc-text">prvInitialiseNewTask函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pxPortInitialiseStack函数"><span class="post-toc-number">6.0.5.</span> <span class="post-toc-text">pxPortInitialiseStack函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#prvAddNewTaskToReadyList函数"><span class="post-toc-number">6.0.6.</span> <span class="post-toc-text">prvAddNewTaskToReadyList函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#prvAddTaskToReadyList宏"><span class="post-toc-number">6.0.7.</span> <span class="post-toc-text">prvAddTaskToReadyList宏</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#vTaskDelete函数"><span class="post-toc-number">6.0.8.</span> <span class="post-toc-text">vTaskDelete函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#vTaskSuspend函数"><span class="post-toc-number">6.0.9.</span> <span class="post-toc-text">vTaskSuspend函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#vTaskResume函数"><span class="post-toc-number">6.0.10.</span> <span class="post-toc-text">vTaskResume函数</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FreeRTOS任务切换"><span class="post-toc-number">7.</span> <span class="post-toc-text">FreeRTOS任务切换</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#执行系统调用"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">执行系统调用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#vPortYield函数"><span class="post-toc-number">7.1.1.</span> <span class="post-toc-text">vPortYield函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#frxt-dispatch函数"><span class="post-toc-number">7.1.2.</span> <span class="post-toc-text">_frxt_dispatch函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#vTaskSwitchContext函数"><span class="post-toc-number">7.1.3.</span> <span class="post-toc-text">vTaskSwitchContext函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#系统滴答定时器中断"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">系统滴答定时器中断</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#frxt-timer-int"><span class="post-toc-number">7.2.1.</span> <span class="post-toc-text">_frxt_timer_int</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#xPortSysTickHandler函数"><span class="post-toc-number">7.2.2.</span> <span class="post-toc-text">xPortSysTickHandler函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#frxt-setup-switch函数"><span class="post-toc-number">7.2.3.</span> <span class="post-toc-text">_frxt_setup_switch函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#vPortYieldFromInt"><span class="post-toc-number">7.2.4.</span> <span class="post-toc-text">vPortYieldFromInt</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#end-总结上下文切换的场合"><span class="post-toc-number">7.2.5.</span> <span class="post-toc-text">:end:总结上下文切换的场合</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FreeRTOS时间片调度"><span class="post-toc-number">8.</span> <span class="post-toc-text">FreeRTOS时间片调度</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FreeRTOS时间管理"><span class="post-toc-number">9.</span> <span class="post-toc-text">FreeRTOS时间管理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#vTaskDelay相对延时函数"><span class="post-toc-number">9.0.1.</span> <span class="post-toc-text">vTaskDelay相对延时函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#prvAddCurrentTaskToDelayedList函数"><span class="post-toc-number">9.0.2.</span> <span class="post-toc-text">prvAddCurrentTaskToDelayedList函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#vTaskDelayUntil绝对延时函数"><span class="post-toc-number">9.0.3.</span> <span class="post-toc-text">vTaskDelayUntil绝对延时函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#portYIELD-WITHIN-API宏定义"><span class="post-toc-number">9.0.4.</span> <span class="post-toc-text">portYIELD_WITHIN_API宏定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#xTaskIncreamentTick函数的主要功能"><span class="post-toc-number">9.0.5.</span> <span class="post-toc-text">xTaskIncreamentTick函数的主要功能</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FreeRTOS队列"><span class="post-toc-number">10.</span> <span class="post-toc-text">FreeRTOS队列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#队列结构体Queue-t"><span class="post-toc-number">10.0.1.</span> <span class="post-toc-text">队列结构体Queue_t</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#创建队列xQueueCreate"><span class="post-toc-number">10.0.2.</span> <span class="post-toc-text">创建队列xQueueCreate</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#初始化队列prvInitialiseNewQueue"><span class="post-toc-number">10.0.3.</span> <span class="post-toc-text">初始化队列prvInitialiseNewQueue</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#队列复位函数xQueueGenericReset"><span class="post-toc-number">10.0.4.</span> <span class="post-toc-text">队列复位函数xQueueGenericReset</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#向队列发送消息"><span class="post-toc-number">10.0.5.</span> <span class="post-toc-text">向队列发送消息</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#xQueueGenericSend函数"><span class="post-toc-number">10.0.6.</span> <span class="post-toc-text">xQueueGenericSend函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#从队列读取消息"><span class="post-toc-number">10.0.7.</span> <span class="post-toc-text">从队列读取消息</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FreeRTOS信号量"><span class="post-toc-number">11.</span> <span class="post-toc-text">FreeRTOS信号量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#二值信号量和互斥信号量的差别"><span class="post-toc-number">11.0.1.</span> <span class="post-toc-text">二值信号量和互斥信号量的差别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#二值信号量"><span class="post-toc-number">11.0.2.</span> <span class="post-toc-text">二值信号量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#计数型信号量"><span class="post-toc-number">11.0.3.</span> <span class="post-toc-text">计数型信号量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#优先级翻转"><span class="post-toc-number">11.0.4.</span> <span class="post-toc-text">优先级翻转</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#互斥信号量"><span class="post-toc-number">11.0.5.</span> <span class="post-toc-text">互斥信号量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#递归互斥信号量"><span class="post-toc-number">11.0.6.</span> <span class="post-toc-text">递归互斥信号量</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FreeRTOS软件定时器"><span class="post-toc-number">12.</span> <span class="post-toc-text">FreeRTOS软件定时器</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FreeRTOS事件标志组"><span class="post-toc-number">13.</span> <span class="post-toc-text">FreeRTOS事件标志组</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FreeRTOS任务通知"><span class="post-toc-number">14.</span> <span class="post-toc-text">FreeRTOS任务通知</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FreeRTOS中的空闲任务"><span class="post-toc-number">15.</span> <span class="post-toc-text">FreeRTOS中的空闲任务</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FreeRTOS低功耗Tickless模式"><span class="post-toc-number">16.</span> <span class="post-toc-text">FreeRTOS低功耗Tickless模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Tickless的具体实现"><span class="post-toc-number">16.0.1.</span> <span class="post-toc-text">Tickless的具体实现</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-freertos-introduce"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">FreeRTOS Introduction---Based on ESP32</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-05-30 20:56:00" datetime="2018-05-30T12:56:00.000Z"  itemprop="datePublished">2018-05-30</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Geek-Hobbies/">Geek Hobbies</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="FreeRTOS系统配置"><a href="#FreeRTOS系统配置" class="headerlink" title="FreeRTOS系统配置"></a>FreeRTOS系统配置</h2><blockquote>
<p>FreeRTOS的系统配置文件为FreeRTOSConfig.h，在此配置文件中可以完成FreeRTOS的裁剪和配置。FreeRTOS中的裁剪和配置使用条件编译的方式来实现。</p>
</blockquote>
<ul>
<li>“INCLUDE_”开始的宏，用来表示使能或者失能FreeRTOS中的相应API函数，比如<code>INCLUDE_vTaskPrioritySet</code>用来决定是否可以使用vTaskPrioritySet函数</li>
<li>“config”开始的宏也用来对FreeRTOS的进行裁剪和配置，比如<ul>
<li><code>configAPPLICATION_ALLOCATED_HEAP</code>宏，如果不开启，那么FreeRTOS的堆内存由编译器分配，开启后，堆内存将由用户自行设置<ul>
<li><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://s1.ax1x.com/2018/07/03/PE0q2D.png" alt="configASSERT设置" title="">
                </div>
                <div class="image-caption">configASSERT设置</div>
            </figure></li>
</ul>
</li>
<li><code>configCHECK_FOR_STACK_OVERFLOW</code>宏如果不为零，用户必须提供一个钩子函数<code>vApplicationStackOverflowHook</code><ul>
<li><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://s1.ax1x.com/2018/07/03/PEB4SS.png" alt="PEB4SS.png" title="">
                </div>
                <div class="image-caption">PEB4SS.png</div>
            </figure></li>
<li>当堆栈溢出太严重时可能会损毁该函数的两个参数，这时可以通过查看变量pxCurrentTCB来确定哪个任务发生了堆栈溢出</li>
<li><code>vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB[ xPortGetCoreID() ], pxCurrentTCB[ xPortGetCoreID() ]-&gt;pcTaskName );</code></li>
<li>堆栈溢出有两种检测方法：<ul>
<li>方法1：上下文切换的时候需要保存现场，现场是保存在堆栈中的，这个时候任务堆栈使用率很可能达到最大值，方法1就是不断检测任务堆栈指针是否指向有效空间，如果指向了无效空间，则调用钩子函数。该方法的特点是快，缺点是不能检测所有的堆栈溢出</li>
<li>方法2：在创建任务的时候向任务堆栈填充一个已知的标记值，然后检测堆栈后面的几个字节是否被改写，如果被改写，则调用钩子函数，方法2几乎能够检测到所有的堆栈溢出</li>
</ul>
</li>
</ul>
</li>
<li><code>configMAX_PRIORITIES</code>设置任务的优先级数量，设置好后任务就可以使用从0～configMAX_PRIORITIES-1的优先级，其中0是最低优先级<ul>
<li><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://s1.ax1x.com/2018/07/03/PEsHwd.png" alt="PEsHwd.png" title="">
                </div>
                <div class="image-caption">PEsHwd.png</div>
            </figure></li>
</ul>
</li>
<li><code>configMINIMAL_STACK_SIZE</code>设置空闲任务的最小任务堆栈大小，以<strong>字</strong>为单位<ul>
<li><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://s1.ax1x.com/2018/07/03/PEyFkn.png" alt="PEyFkn.png" title="">
                </div>
                <div class="image-caption">PEyFkn.png</div>
            </figure></li>
</ul>
</li>
<li><code>configTOTAL_HEAP_SIZE</code>设置堆的大小，如果使用了动态内存管理，则FreeRTOS在创建任务、信号量、队列等的时候就会从用户指定的内存中获取空间<ul>
<li><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://s1.ax1x.com/2018/07/03/PEyUne.png" alt="PEyUne.png" title="">
                </div>
                <div class="image-caption">PEyUne.png</div>
            </figure></li>
</ul>
</li>
<li><code>configKERNEL_INTERRUPT_PRIORITY</code>设置了内核中断系统中systick中断的优先级(FreeRTOS中systick的中断优先级是最低的)<ul>
<li><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://s1.ax1x.com/2018/07/04/PEv1LF.png" alt="PEv1LF.png" title="">
                </div>
                <div class="image-caption">PEv1LF.png</div>
            </figure></li>
</ul>
</li>
<li><code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code>设置了FreeRTOS系统可管理的最大优先级，这里实际值为<em>3</em>，高于此优先级的中断是不会被FreeRTOS内核屏蔽的，对实时性要求严格的任务就可以使用这些优先级，中断服务函数也不能调用FreeRTOS的API函数；低于（包括本身）此优先级的中断可以安全地调用以FromISR结尾的API函数<ul>
<li><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://s1.ax1x.com/2018/07/04/PExpTJ.png" alt="PExpTJ.png" title="">
                </div>
                <div class="image-caption">PExpTJ.png</div>
            </figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="FreeRTOS中的Task"><a href="#FreeRTOS中的Task" class="headerlink" title="FreeRTOS中的Task"></a>FreeRTOS中的Task</h2><ul>
<li><p>任务控制块</p>
<ul>
<li><blockquote>
<p>xTaskCreate()创建任务的时候，会自动给每个任务分配一个任务控制块</p>
</blockquote>
</li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Task control block.  A task control block (TCB) is allocated for each task,</span></span><br><span class="line"><span class="comment"> * and stores task state information, including a pointer to the task's context</span></span><br><span class="line"><span class="comment"> * (the task's run time environment, including register values)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> StackType_t	*pxTopOfStack;	<span class="comment">//任务堆栈栈顶</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )</span></span><br><span class="line">		xMPU_SETTINGS	xMPUSettings;		<span class="comment">//MPU相关的设置</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	ListItem_t			xGenericListItem;	<span class="comment">//状态列表项</span></span><br><span class="line">	ListItem_t			xEventListItem;		<span class="comment">//事件列表项</span></span><br><span class="line">	UBaseType_t			uxPriority;			<span class="comment">//任务优先级</span></span><br><span class="line">	StackType_t			*pxStack;			<span class="comment">//任务堆栈起始地址</span></span><br><span class="line">	<span class="keyword">char</span>				pcTaskName[ configMAX_TASK_NAME_LEN ];<span class="comment">//任务名字</span></span><br><span class="line">	BaseType_t			xCoreID;			<span class="comment">//执行任务的处理器核ID</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( portSTACK_GROWTH &gt; 0 || configENABLE_TASK_SNAPSHOT == 1 )</span></span><br><span class="line">		StackType_t		*pxEndOfStack;		<span class="comment">//任务堆栈栈底</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( portCRITICAL_NESTING_IN_TCB == 1 )</span></span><br><span class="line">		UBaseType_t 	uxCriticalNesting; 	<span class="comment">//临界区嵌套深度</span></span><br><span class="line">		<span class="keyword">uint32_t</span>		uxOldInterruptState; <span class="comment">/*&lt; Interrupt state before the outer taskEnterCritical was called */</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">		UBaseType_t		uxTCBNumber;		<span class="comment">/*&lt; Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */</span></span><br><span class="line">		UBaseType_t  	uxTaskNumber;		<span class="comment">/*&lt; Stores a number specifically for use by third party trace code. */</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_MUTEXES == 1 )</span></span><br><span class="line">		UBaseType_t 	uxBasePriority;		<span class="comment">//任务基础优先级</span></span><br><span class="line">		UBaseType_t 	uxMutexesHeld;		<span class="comment">//任务获取到的互斥信号量个数</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 )</span></span><br><span class="line">		TaskHookFunction_t pxTaskTag;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span>( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )</span></span><br><span class="line">		<span class="keyword">void</span> *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS )</span></span><br><span class="line">		TlsDeleteCallbackFunction_t pvThreadLocalStoragePointersDelCallback[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( configGENERATE_RUN_TIME_STATS == 1 )</span></span><br><span class="line">		<span class="keyword">uint32_t</span>		ulRunTimeCounter;	<span class="comment">//记录任务运行总时间</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )</span></span><br><span class="line">		<span class="comment">/* Allocate a Newlib reent structure that is specific to this task.</span></span><br><span class="line"><span class="comment">		Note Newlib support has been included by popular demand, but is not</span></span><br><span class="line"><span class="comment">		used by the FreeRTOS maintainers themselves.  FreeRTOS is not</span></span><br><span class="line"><span class="comment">		responsible for resulting newlib operation.  User must be familiar with</span></span><br><span class="line"><span class="comment">		newlib and must provide system-wide implementations of the necessary</span></span><br><span class="line"><span class="comment">		stubs. Be warned that (at the time of writing) the current newlib design</span></span><br><span class="line"><span class="comment">		implements a system-wide malloc() that must be provided with locks. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> 	_<span class="title">reent</span> <span class="title">xNewLib_reent</span>;</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )</span></span><br><span class="line">		<span class="keyword">volatile</span> <span class="keyword">uint32_t</span> ulNotifiedValue;	<span class="comment">//任务通知值</span></span><br><span class="line">		<span class="keyword">volatile</span> eNotifyValue eNotifyState;	<span class="comment">//任务通知状态</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* See the comments above the definition of</span></span><br><span class="line"><span class="comment">	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span>( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )</span></span><br><span class="line">		<span class="keyword">uint8_t</span>	ucStaticallyAllocated; 		<span class="comment">//如果任务是静态创建的，该变量就为pdTRUE</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; tskTCB;</span><br><span class="line"><span class="keyword">typedef</span> tskTCB TCB_t;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>任务堆栈</p>
<ul>
<li><blockquote>
<p>任务调度器在进行任务切换的时候，会将当前任务的现场(CPU寄存器值等等)保存在此任务的任务堆栈中；此任务下次运行的时候就会先用堆栈中保存的值来恢复现场，之后任务就会接着从上次中断的地方开始运行。使用动态的方法创建任务时，任务堆栈会自动创建；使用静态的方法创建任务时，任务堆栈需要用户自行定义。任务堆栈的数据类型为<code>StackType_t</code>，其大小为4字节，所以动态创建的任务，其堆栈大小是传入数值4倍</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> portSTACK_TYPE uint32_t</span></span><br><span class="line"><span class="keyword">typedef</span> portSTACK_TYPE StackType_t</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="尾调用-调度任务创建和删除API函数"><a href="#尾调用-调度任务创建和删除API函数" class="headerlink" title="尾调用 调度任务创建和删除API函数"></a>尾调用 调度任务创建和删除API函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xTaskCreate()</td>
<td>使用动态的方法创建一个任务</td>
</tr>
<tr>
<td>xTaskCreateStatic()</td>
<td>使用静态的方法创建一个任务</td>
</tr>
<tr>
<td>xTaskCreateRestricted()</td>
<td>创建一个使用MPU进行限制的任务，相关内存使用动态内存分配</td>
</tr>
<tr>
<td>vTaskDelete()</td>
<td>删除一个任务</td>
</tr>
</tbody>
</table>
<h4 id="任务挂起和恢复API函数"><a href="#任务挂起和恢复API函数" class="headerlink" title="任务挂起和恢复API函数"></a>任务挂起和恢复API函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>vTaskSuspend()</td>
<td>挂起一个任务，传入某个任务的句柄，NULL表示当前任务</td>
</tr>
<tr>
<td>vTaskResume()</td>
<td>恢复一个任务的运行</td>
</tr>
<tr>
<td>xTaskResumeFromISR()</td>
<td>中断服务函数中恢复一个任务的运行。返回pdTRUE表示恢复运行的任务的优先级等于或者高于正在运行的任务（被中断打断的任务），这意味着在退出中断服务函数的时候必须进行一次上下文切换（调用<em>portYIELD_FROM_ISR</em>）。返回pdFALSE表示恢复运行的任务的优先级低于当前正在运行的任务（被中断打断的任务），这意味着在退出中断服务函数的以后不需要进行上下文切换</td>
</tr>
</tbody>
</table>
<h4 id="其他常用API函数-部分函数需要在配置文件中开启相关的宏"><a href="#其他常用API函数-部分函数需要在配置文件中开启相关的宏" class="headerlink" title="其他常用API函数(部分函数需要在配置文件中开启相关的宏)"></a>其他常用API函数(部分函数需要在配置文件中开启相关的宏)</h4><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xTaskGetHandle()</td>
<td>根据任务名字获取某个任务的任务句柄</td>
</tr>
<tr>
<td>vTaskStartScheduler()</td>
<td>开启任务调度</td>
</tr>
<tr>
<td>vTaskSuspendAll()</td>
<td>挂起任务调度器，支持嵌套</td>
</tr>
<tr>
<td>vTaskResumeAll()</td>
<td>恢复调度器</td>
</tr>
<tr>
<td>vTaskDelay()</td>
<td>任务延时，单位是时钟节拍</td>
</tr>
<tr>
<td>uxTaskPriorityGet()</td>
<td>获取指定任务的优先级</td>
</tr>
<tr>
<td>vTaskPrioritySet()</td>
<td>改变一个任务的任务优先级</td>
</tr>
<tr>
<td>uxTaskGetSystemState()</td>
<td>获取系统中所有任务的任务状态</td>
</tr>
<tr>
<td>vTaskGetInfo()</td>
<td>获取单个任务的状态</td>
</tr>
<tr>
<td>xTaskGetCurrentTaskHandle()</td>
<td>获取当前任务的任务句柄</td>
</tr>
<tr>
<td>xTaskGetHandle()</td>
<td>根据任务名字获取任务的任务句柄</td>
</tr>
<tr>
<td>xTaskGetIdleTaskHandle()</td>
<td>返回空闲任务的任务句柄</td>
</tr>
<tr>
<td>uxTaskGetStackHighWaterMark()</td>
<td>检查任务从创建好到现在的历史剩余最小值，FreeRTOS把这个历史剩余最小值叫“高水位线”</td>
</tr>
<tr>
<td>eTaskGetState()</td>
<td>查询某个任务的运行状态</td>
</tr>
<tr>
<td>pcTaskGetName()</td>
<td>根据某个任务的任务句柄来查询这个任务对应的任务名</td>
</tr>
<tr>
<td>xTaskGetTickCount()/xTaskGetTickCountFromISR()</td>
<td>查询任务调度器从启动到现在的时间计数器xTickCount的值，每个滴答定时器中断时xTickCount就会加1</td>
</tr>
<tr>
<td>xTaskGetSchedulerState()</td>
<td>获取FreeRTOS的任务调度器运行情况：运行、关闭还是挂起</td>
</tr>
<tr>
<td>uxTaskGetNumberOfTasks()</td>
<td>查询系统当前存在的任务数量</td>
</tr>
<tr>
<td>vTaskList()</td>
<td>创建一个表格来描述每个任务的详细信息</td>
</tr>
<tr>
<td>vTaskGetRunTimeStats()</td>
<td>统计任务的运行时间信息，任务的运行时间信息提供了每个任务获取到CPU使用权总的时间</td>
</tr>
<tr>
<td>SetThreadLocalStoragePointer()</td>
<td>设置线程本地存储指针的值，每个任务都有自己的指针数组来作为线程本地存储，使用这些线程本地存储可以用来在任务控制块中存储一些应用信息，这些信息只属于线程自己</td>
</tr>
<tr>
<td>GetThreadLocalStoragePointer()</td>
<td>获取线程本地存储指针的值</td>
</tr>
</tbody>
</table>
<h2 id="FreeRTOS开关中断"><a href="#FreeRTOS开关中断" class="headerlink" title="FreeRTOS开关中断"></a>FreeRTOS开关中断</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://s1.ax1x.com/2018/07/04/PEzUKK.png" alt="PEzUKK.png" title="">
                </div>
                <div class="image-caption">PEzUKK.png</div>
            </figure>
<ul>
<li>关闭中断是指优先级低于XCHAL_EXCM_LEVEL的中断将会被屏蔽</li>
</ul>
<h2 id="FreeRTOS临界段代码保护"><a href="#FreeRTOS临界段代码保护" class="headerlink" title="FreeRTOS临界段代码保护"></a>FreeRTOS临界段代码保护</h2><table>
<thead>
<tr>
<th>函数/宏</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>taskENTER_CRITICAL()</td>
<td>任务级进入临界段</td>
</tr>
<tr>
<td>taskEXIT_CRITICAL()</td>
<td>任务级退出临界段</td>
</tr>
<tr>
<td>taskENTER_CRITICAL_FROME_ISR()</td>
<td>中断级进入临界段（中断优先级不能高于configMAX_SYSCALL_INTERRUPT_PRIORITY）</td>
</tr>
<tr>
<td>taskEXIT_CRITICAL_FROM_ISR()</td>
<td>中断级退出临界段</td>
</tr>
</tbody>
</table>
<h2 id="FreeRTOS列表（双向循环链表）和列表项"><a href="#FreeRTOS列表（双向循环链表）和列表项" class="headerlink" title="FreeRTOS列表（双向循环链表）和列表项"></a>FreeRTOS列表（双向循环链表）和列表项</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xLIST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	listFIRST_LIST_INTEGRITY_CHECK_VALUE			<span class="comment">//用来检查列表的完整性</span></span><br><span class="line">	configLIST_VOLATILE UBaseType_t uxNumberOfItems;<span class="comment">//记录列表中列表项的数量</span></span><br><span class="line">	ListItem_t * configLIST_VOLATILE pxIndex;		<span class="comment">//记录最新的列表项，用于遍历列表</span></span><br><span class="line">	MiniListItem_t xListEnd;						<span class="comment">//标记列表的最后一项</span></span><br><span class="line">	listSECOND_LIST_INTEGRITY_CHECK_VALUE			<span class="comment">//用来检查列表的完整性</span></span><br><span class="line">&#125; List_t;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE</span><br><span class="line">	configLIST_VOLATILE TickType_t xItemValue;			<span class="comment">//序号，用来对列表项进行排列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxNext</span>;</span>		<span class="comment">//指向下一个列表项</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxPrevious</span>;</span>	<span class="comment">//指向前一个列表项</span></span><br><span class="line">	<span class="keyword">void</span> * pvOwner;										<span class="comment">//指向实际包含有该列表项的对象</span></span><br><span class="line">	<span class="keyword">void</span> * configLIST_VOLATILE pvContainer;				<span class="comment">//指向此列表项归属的列表</span></span><br><span class="line">	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> <span class="title">ListItem_t</span>;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xMINI_LIST_ITEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE</span><br><span class="line">	configLIST_VOLATILE TickType_t xItemValue;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxNext</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxPrevious</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xMINI_LIST_ITEM</span> <span class="title">MiniListItem_t</span>;</span></span><br></pre></td></tr></table></figure>
<h4 id="列表操作相关API"><a href="#列表操作相关API" class="headerlink" title="列表操作相关API"></a>列表操作相关API</h4><table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>void vListInitialise( List_t * const pxList )</td>
<td>列表初始化</td>
</tr>
<tr>
<td>void vListInitialiseItem( ListItem_t * const pxItem )</td>
<td>列表项初始化</td>
</tr>
<tr>
<td>void vListInsert( List_t <em> const pxList, ListItem_t </em> const pxNewListItem )</td>
<td>列表项插入（指定位置）</td>
</tr>
<tr>
<td>void vListInsertEnd( List_t <em> const pxList, ListItem_t </em> const pxNewListItem )</td>
<td>列表项插入（末尾）</td>
</tr>
<tr>
<td>UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )</td>
<td>列表项删除</td>
</tr>
<tr>
<td>listGET_OWNER_OF_NEXT_ENTRY(pxTCB,pxList)</td>
<td>列表的遍历</td>
</tr>
</tbody>
</table>
<ul>
<li>vListInsert中，列表项的插入位置是根据列表项中的xItemValue来决定，按照<strong>升序</strong>方式排列，例如xItemValue的值为portMAX_DELAY就表示要插入的位置是列表的最末尾</li>
<li>vListInsertEnd中，列表项插入的位置是pxList中pxIndex指向的列表项的前面</li>
<li>uxListRemove函数会返回删除后列表的剩余长度，该函数只是将指定的列表项从列表中删除掉，并不会将这个列表项的内存释放掉</li>
<li>列表中的成员变量pxIndex是用来便利列表的，每调用一次宏listGET_OWNER_OF_NEXT_ENTRY，列表的pxIndex就会指向下一个列表项，并且返回这个列表项的pxOwner变量值</li>
</ul>
<h2 id="FreeRTOS的调度器"><a href="#FreeRTOS的调度器" class="headerlink" title="FreeRTOS的调度器"></a>FreeRTOS的调度器</h2><h4 id="vTaskStartScheduler函数"><a href="#vTaskStartScheduler函数" class="headerlink" title="vTaskStartScheduler函数"></a>vTaskStartScheduler函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vTaskStartScheduler</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BaseType_t xReturn;</span><br><span class="line">	BaseType_t i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//给每个内核都创建一个空闲任务，优先级设为最低（0），任务名为“IDLE”</span></span><br><span class="line">	<span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;portNUM_PROCESSORS; i++) &#123;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">if</span> ( INCLUDE_xTaskGetIdleTaskHandle == 1 )</span></span><br><span class="line">		&#123;</span><br><span class="line">			xReturn = xTaskCreatePinnedToCore( prvIdleTask, <span class="string">"IDLE"</span>, tskIDLE_STACK_SIZE, ( <span class="keyword">void</span> * ) <span class="literal">NULL</span>, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &amp;xIdleTaskHandle[i], i ); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		&#123;</span><br><span class="line">			xReturn = xTaskCreatePinnedToCore( prvIdleTask, <span class="string">"IDLE"</span>, tskIDLE_STACK_SIZE, ( <span class="keyword">void</span> * ) <span class="literal">NULL</span>, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), <span class="literal">NULL</span>, i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* INCLUDE_xTaskGetIdleTaskHandle */</span>	<span class="comment">/* Event lists are always in priority order. */</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建软件定时器任务，任务名为“Tmr Svc”，此任务只在内核0上运行</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_TIMERS == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( xReturn == pdPASS )</span><br><span class="line">		&#123;</span><br><span class="line">			xReturn = xTimerCreateTimerTask();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			mtCOVERAGE_TEST_MARKER();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* configUSE_TIMERS */</span></span></span><br><span class="line">	<span class="keyword">if</span>( xReturn == pdPASS )</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//在开启调度器之前不允许被中断打扰，在这里将中断关闭。之前创建的任务堆栈中包含有一个状态字，指示这中断是打开状态，所以当第一个任务运行起来后，中断将会再一次被开启。</span></span><br><span class="line">		portDISABLE_INTERRUPTS();</span><br><span class="line">		xTickCount = ( TickType_t ) <span class="number">0U</span>;</span><br><span class="line">		<span class="comment">//如果需要使用时间统计功能，下面的这个宏需要用户自定义（配置一个计数器或定时器）</span></span><br><span class="line">		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();</span><br><span class="line">		xSchedulerRunning = pdTRUE;<span class="comment">//表示调度器开始运行</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//初始化相关硬件：滴答定时器等，这需要用户自行实现</span></span><br><span class="line">		<span class="keyword">if</span>( xPortStartScheduler() != pdFALSE )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//一旦调度器起来后就永远不会执行到这里</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//只有调用了xTaskEndScheduler函数后才会执行到这里</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//如果创建空闲任务或者定时器任务时内存不够就会执行到这里</span></span><br><span class="line">		configASSERT( xReturn );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="xPortStartScheduler函数"><a href="#xPortStartScheduler函数" class="headerlink" title="xPortStartScheduler函数"></a>xPortStartScheduler函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xPortStartScheduler</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> XCHAL_CP_NUM &gt; 0</span></span><br><span class="line">	<span class="comment">//初始化任务的协处理器</span></span><br><span class="line">	_xt_coproc_init();</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">//初始化滴答计数器的分频系数</span></span><br><span class="line">	_xt_tick_divisor_init();</span><br><span class="line">	<span class="comment">//配置、使能滴答计数器</span></span><br><span class="line">	_frxt_tick_timer_init();</span><br><span class="line">	port_xSchedulerRunning[xPortGetCoreID()] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//_frxt_dispatch函数不能直接用C语言调用。调度最高优先级的任务</span></span><br><span class="line">	__<span class="function">asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"call0    _frxt_dispatch\n"</span>)</span></span>;</span><br><span class="line">	<span class="comment">//永远不会返回</span></span><br><span class="line">	<span class="keyword">return</span> pdTRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="xTaskCreatePinnedToCore函数"><a href="#xTaskCreatePinnedToCore函数" class="headerlink" title="xTaskCreatePinnedToCore函数"></a>xTaskCreatePinnedToCore函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在某个具体的核上创建任务</span></span><br><span class="line"><span class="function">BaseType_t <span class="title">xTaskCreatePinnedToCore</span><span class="params">(	TaskFunction_t pxTaskCode,</span></span></span><br><span class="line"><span class="function"><span class="params">							<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> pcName,</span></span></span><br><span class="line"><span class="function"><span class="params">							<span class="keyword">const</span> <span class="keyword">uint32_t</span> usStackDepth,</span></span></span><br><span class="line"><span class="function"><span class="params">							<span class="keyword">void</span> * <span class="keyword">const</span> pvParameters,</span></span></span><br><span class="line"><span class="function"><span class="params">							UBaseType_t uxPriority,</span></span></span><br><span class="line"><span class="function"><span class="params">							TaskHandle_t * <span class="keyword">const</span> pxCreatedTask,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> BaseType_t xCoreID )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCB_t *pxNewTCB;</span><br><span class="line">    BaseType_t xReturn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果任务栈向上生长，那么先开辟任务控制块TCB的内存，再开辟任务栈的内存，任务栈的地址保存在TCB中</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span>( portSTACK_GROWTH &gt; 0 )</span></span><br><span class="line">    &#123;</span><br><span class="line">        pxNewTCB = ( TCB_t * ) pvPortMallocTcbMem( <span class="keyword">sizeof</span>( TCB_t ) );</span><br><span class="line">        <span class="keyword">if</span>( pxNewTCB != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            pxNewTCB-&gt;pxStack = ( StackType_t * ) pvPortMallocStackMem( ( ( ( <span class="keyword">size_t</span> ) usStackDepth ) * <span class="keyword">sizeof</span>( StackType_t ) ) ); </span><br><span class="line">            <span class="keyword">if</span>( pxNewTCB-&gt;pxStack == <span class="literal">NULL</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                vPortFree( pxNewTCB );</span><br><span class="line">                pxNewTCB = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">//如果任务栈向下生长，那么先开辟任务栈的内存，再开辟任务控制块TCB的内存，任务栈的地址保存在TCB中</span></span><br><span class="line">    &#123;</span><br><span class="line">        StackType_t *pxStack;</span><br><span class="line">        pxStack = ( StackType_t * ) pvPortMallocStackMem( ( ( ( <span class="keyword">size_t</span> ) usStackDepth ) * <span class="keyword">sizeof</span>( StackType_t ) ) );</span><br><span class="line">        <span class="keyword">if</span>( pxStack != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            pxNewTCB = ( TCB_t * ) pvPortMallocTcbMem( <span class="keyword">sizeof</span>( TCB_t ) ); </span><br><span class="line">            <span class="keyword">if</span>( pxNewTCB != <span class="literal">NULL</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                pxNewTCB-&gt;pxStack = pxStack;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                vPortFree( pxStack );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pxNewTCB = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* portSTACK_GROWTH */</span></span></span><br><span class="line">    <span class="keyword">if</span>( pxNewTCB != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span>( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//标记该任务后期不需要的时候需要删除</span></span><br><span class="line">            pxNewTCB-&gt;ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* configSUPPORT_STATIC_ALLOCATION */</span></span></span><br><span class="line">		<span class="comment">//初始化任务</span></span><br><span class="line">        prvInitialiseNewTask( pxTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, <span class="literal">NULL</span>, xCoreID );</span><br><span class="line">        <span class="comment">//将新创建的任务加入就绪列表中</span></span><br><span class="line">        prvAddNewTaskToReadyList( pxNewTCB, pxTaskCode, xCoreID );</span><br><span class="line">        xReturn = pdPASS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="prvInitialiseNewTask函数"><a href="#prvInitialiseNewTask函数" class="headerlink" title="prvInitialiseNewTask函数"></a>prvInitialiseNewTask函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prvInitialiseNewTask</span><span class="params">( 	TaskFunction_t pxTaskCode,</span></span></span><br><span class="line"><span class="function"><span class="params">									<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> pcName,</span></span></span><br><span class="line"><span class="function"><span class="params">									<span class="keyword">const</span> <span class="keyword">uint32_t</span> ulStackDepth,</span></span></span><br><span class="line"><span class="function"><span class="params">									<span class="keyword">void</span> * <span class="keyword">const</span> pvParameters,</span></span></span><br><span class="line"><span class="function"><span class="params">									UBaseType_t uxPriority,</span></span></span><br><span class="line"><span class="function"><span class="params">									TaskHandle_t * <span class="keyword">const</span> pxCreatedTask,</span></span></span><br><span class="line"><span class="function"><span class="params">									TCB_t *pxNewTCB,</span></span></span><br><span class="line"><span class="function"><span class="params">									<span class="keyword">const</span> MemoryRegion_t * <span class="keyword">const</span> xRegions, <span class="keyword">const</span> BaseType_t xCoreID )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StackType_t *pxTopOfStack;</span><br><span class="line">UBaseType_t x;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span>( portUSING_MPU_WRAPPERS == 1 )</span></span><br><span class="line">		<span class="comment">//任务使用特权模式创建任务</span></span><br><span class="line">		BaseType_t xRunPrivileged;</span><br><span class="line">		<span class="keyword">if</span>( ( uxPriority &amp; portPRIVILEGE_BIT ) != <span class="number">0U</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			xRunPrivileged = pdTRUE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			xRunPrivileged = pdFALSE;</span><br><span class="line">		&#125;</span><br><span class="line">		uxPriority &amp;= ~portPRIVILEGE_BIT;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* portUSING_MPU_WRAPPERS == 1 */</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span>( ( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将任务栈初始化相同的值(0xA5)</span></span><br><span class="line">		( <span class="keyword">void</span> ) <span class="built_in">memset</span>( pxNewTCB-&gt;pxStack, ( <span class="keyword">int</span> ) tskSTACK_FILL_BYTE, ( <span class="keyword">size_t</span> ) ulStackDepth * <span class="keyword">sizeof</span>( StackType_t ) );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">//根据栈的不同生长方向来计算栈顶位置</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span>( portSTACK_GROWTH &lt; 0 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		pxTopOfStack = pxNewTCB-&gt;pxStack + ( ulStackDepth - ( <span class="keyword">uint32_t</span> ) <span class="number">1</span> );</span><br><span class="line">		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); </span><br><span class="line"></span><br><span class="line">		<span class="comment">//检查堆栈栈顶地址是否字节对齐</span></span><br><span class="line">		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == <span class="number">0U</span>L ) );</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">if</span> ( configENABLE_TASK_SNAPSHOT == 1 )</span></span><br><span class="line">		&#123;</span><br><span class="line">			pxNewTCB-&gt;pxEndOfStack = pxTopOfStack;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* portSTACK_GROWTH */</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		pxTopOfStack = pxNewTCB-&gt;pxStack;</span><br><span class="line">		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB-&gt;pxStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == <span class="number">0U</span>L ) );</span><br><span class="line">		pxNewTCB-&gt;pxEndOfStack = pxNewTCB-&gt;pxStack + ( ulStackDepth - ( <span class="keyword">uint32_t</span> ) <span class="number">1</span> );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* portSTACK_GROWTH */</span></span></span><br><span class="line">	<span class="comment">//保存任务的任务名</span></span><br><span class="line">	<span class="keyword">for</span>( x = ( UBaseType_t ) <span class="number">0</span>; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )</span><br><span class="line">	&#123;</span><br><span class="line">		pxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ];</span><br><span class="line">		<span class="keyword">if</span>( pcName[ x ] == <span class="number">0x00</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			mtCOVERAGE_TEST_MARKER();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//任务名太长需要截断</span></span><br><span class="line">	pxNewTCB-&gt;pcTaskName[ configMAX_TASK_NAME_LEN - <span class="number">1</span> ] = <span class="string">'\0'</span>;</span><br><span class="line">	<span class="comment">//修正不合法的优先级</span></span><br><span class="line">	<span class="keyword">if</span>( uxPriority &gt;= ( UBaseType_t ) configMAX_PRIORITIES )</span><br><span class="line">	&#123;</span><br><span class="line">		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) <span class="number">1U</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		mtCOVERAGE_TEST_MARKER();</span><br><span class="line">	&#125;</span><br><span class="line">	pxNewTCB-&gt;uxPriority = uxPriority;<span class="comment">//初始化任务控制块的优先级字段</span></span><br><span class="line">	pxNewTCB-&gt;xCoreID = xCoreID;<span class="comment">//初始化任务所在的内核ID号</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_MUTEXES == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		pxNewTCB-&gt;uxBasePriority = uxPriority;<span class="comment">//如果使用了互斥信号量，就需要指定基础优先级</span></span><br><span class="line">		pxNewTCB-&gt;uxMutexesHeld = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* configUSE_MUTEXES */</span></span></span><br><span class="line"></span><br><span class="line">	vListInitialiseItem( &amp;( pxNewTCB-&gt;xGenericListItem ) );<span class="comment">//初始化通用列表项</span></span><br><span class="line">	vListInitialiseItem( &amp;( pxNewTCB-&gt;xEventListItem ) );<span class="comment">//初始化事件列表项</span></span><br><span class="line">	listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xGenericListItem ), pxNewTCB );<span class="comment">//设置列表项归属</span></span><br><span class="line">	listSET_LIST_ITEM_VALUE( &amp;( pxNewTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );<span class="comment">//设置事件列表项的值使得优先级从小到大排列</span></span><br><span class="line">	listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xEventListItem ), pxNewTCB );<span class="comment">//设置列表项归属</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( portCRITICAL_NESTING_IN_TCB == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		pxNewTCB-&gt;uxCriticalNesting = ( UBaseType_t ) <span class="number">0U</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* portCRITICAL_NESTING_IN_TCB */</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		pxNewTCB-&gt;pxTaskTag = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* configUSE_APPLICATION_TASK_TAG */</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( configGENERATE_RUN_TIME_STATS == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		pxNewTCB-&gt;ulRunTimeCounter = <span class="number">0U</span>L;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* configGENERATE_RUN_TIME_STATS */</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		vPortStoreTaskMPUSettings( &amp;( pxNewTCB-&gt;xMPUSettings ), xRegions, pxNewTCB-&gt;pxStack, ulStackDepth );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Avoid compiler warning about unreferenced parameter. */</span></span><br><span class="line">		( <span class="keyword">void</span> ) xRegions;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span>( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>( x = <span class="number">0</span>; x &lt; ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )</span><br><span class="line">		&#123;</span><br><span class="line">			pxNewTCB-&gt;pvThreadLocalStoragePointers[ x ] = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">if</span> ( configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS == 1)</span></span><br><span class="line">			pxNewTCB-&gt;pvThreadLocalStoragePointersDelCallback[ x ] = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		pxNewTCB-&gt;ulNotifiedValue = <span class="number">0</span>;</span><br><span class="line">		pxNewTCB-&gt;eNotifyState = eNotWaitingNotification;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Initialise this task's Newlib reent structure. */</span></span><br><span class="line">		esp_reent_init(&amp;pxNewTCB-&gt;xNewLib_reent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span>( INCLUDE_xTaskAbortDelay == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		pxNewTCB-&gt;ucDelayAborted = pdFALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span>( portUSING_MPU_WRAPPERS == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* portUSING_MPU_WRAPPERS */</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );<span class="comment">//初始化任务堆栈</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* portUSING_MPU_WRAPPERS */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ( <span class="keyword">void</span> * ) pxCreatedTask != <span class="literal">NULL</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//任务句柄其实就是任务控制块的地址</span></span><br><span class="line">		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		mtCOVERAGE_TEST_MARKER();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pxPortInitialiseStack函数"><a href="#pxPortInitialiseStack函数" class="headerlink" title="pxPortInitialiseStack函数"></a>pxPortInitialiseStack函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StackType_t *<span class="title">pxPortInitialiseStack</span><span class="params">( StackType_t *pxTopOfStack, TaskFunction_t pxCode, <span class="keyword">void</span> *pvParameters )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	StackType_t *sp, *tp;</span><br><span class="line">	XtExcFrame  *frame;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> XCHAL_CP_NUM &gt; 0</span></span><br><span class="line">	<span class="keyword">uint32_t</span> *p;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">uint32_t</span> *threadptr;</span><br><span class="line">	<span class="keyword">void</span> *task_thread_local_start;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">int</span> _thread_local_start, _thread_local_end, _rodata_start;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> check that TLS area fits the stack</span></span><br><span class="line">	<span class="keyword">uint32_t</span> thread_local_sz = (<span class="keyword">uint8_t</span> *)&amp;_thread_local_end - (<span class="keyword">uint8_t</span> *)&amp;_thread_local_start;</span><br><span class="line"></span><br><span class="line">	thread_local_sz = ALIGNUP(<span class="number">0x10</span>, thread_local_sz);</span><br><span class="line">	<span class="comment">/* 初始化任务堆栈，使之从高地址开始往下依次是：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	----LOW ADDRESSES ----------------------------------------HIGH ADDRESSES----------</span></span><br><span class="line"><span class="comment">	task stack | interrupt stack frame | thread local vars | co-processor save area |</span></span><br><span class="line"><span class="comment">	----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">	           |																	|</span></span><br><span class="line"><span class="comment">			   SP 								                            pxTopOfStack</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	sp = (StackType_t *) (((UBaseType_t)(pxTopOfStack + <span class="number">1</span>) - XT_CP_SIZE - thread_local_sz - XT_STK_FRMSZ) &amp; ~<span class="number">0xf</span>);<span class="comment">//16字节对齐</span></span><br><span class="line">	<span class="keyword">for</span> (tp = sp; tp &lt;= pxTopOfStack; ++tp)<span class="comment">//将sp到TopOfStack之间的内存清零</span></span><br><span class="line">		*tp = <span class="number">0</span>;</span><br><span class="line">	frame = (XtExcFrame *) sp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对一些必要的寄存赋值 */</span></span><br><span class="line">	frame-&gt;pc   = (UBaseType_t) pxCode;             <span class="comment">//PC指针初始化为任务函数的入口地址</span></span><br><span class="line">	frame-&gt;a0   = <span class="number">0</span>;                                <span class="comment">//组织GDB回溯</span></span><br><span class="line">	frame-&gt;a1   = (UBaseType_t) sp + XT_STK_FRMSZ;  </span><br><span class="line">	frame-&gt;<span class="built_in">exit</span> = (UBaseType_t) _xt_user_exit;      </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set initial PS to int level 0, EXCM disabled ('rfe' will enable), user mode. */</span></span><br><span class="line">	<span class="comment">/* Also set entry point argument parameter. */</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> __XTENSA_CALL0_ABI__</span></span><br><span class="line">	frame-&gt;a2 = (UBaseType_t) pvParameters;</span><br><span class="line">	frame-&gt;ps = PS_UM | PS_EXCM;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="comment">/* + for windowed ABI also set WOE and CALLINC (pretend task was 'call4'd). */</span></span><br><span class="line">	frame-&gt;a6 = (UBaseType_t) pvParameters;</span><br><span class="line">	frame-&gt;ps = PS_UM | PS_EXCM | PS_WOE | PS_CALLINC(<span class="number">1</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> XT_USE_SWPRI</span></span><br><span class="line">	<span class="comment">/* Set the initial virtual priority mask value to all 1's. */</span></span><br><span class="line">	frame-&gt;vpri = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Init threadptr reg and TLS vars */</span></span><br><span class="line">	task_thread_local_start = (<span class="keyword">void</span> *)(((<span class="keyword">uint32_t</span>)pxTopOfStack - XT_CP_SIZE - thread_local_sz) &amp; ~<span class="number">0xf</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(task_thread_local_start, &amp;_thread_local_start, thread_local_sz);</span><br><span class="line">	threadptr = (<span class="keyword">uint32_t</span> *)(sp + XT_STK_EXTRA);</span><br><span class="line">	<span class="comment">/* shift threadptr by the offset of _thread_local_start from DROM start;</span></span><br><span class="line"><span class="comment">	   need to take into account extra 16 bytes offset */</span></span><br><span class="line">	*threadptr = (<span class="keyword">uint32_t</span>)task_thread_local_start - ((<span class="keyword">uint32_t</span>)&amp;_thread_local_start - (<span class="keyword">uint32_t</span>)&amp;_rodata_start) - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> XCHAL_CP_NUM &gt; 0</span></span><br><span class="line">	<span class="comment">/* Init the coprocessor save area (see xtensa_context.h) */</span></span><br><span class="line">	p = (<span class="keyword">uint32_t</span> *)(((<span class="keyword">uint32_t</span>) pxTopOfStack - XT_CP_SIZE) &amp; ~<span class="number">0xf</span>);</span><br><span class="line">	p[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	p[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	p[<span class="number">2</span>] = (((<span class="keyword">uint32_t</span>) p) + <span class="number">12</span> + XCHAL_TOTAL_SA_ALIGN - <span class="number">1</span>) &amp; -XCHAL_TOTAL_SA_ALIGN;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="prvAddNewTaskToReadyList函数"><a href="#prvAddNewTaskToReadyList函数" class="headerlink" title="prvAddNewTaskToReadyList函数"></a>prvAddNewTaskToReadyList函数</h4><blockquote>
<p>FreeRTOS使用不同的列表来表示任务的不同状态</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prvAddNewTaskToReadyList</span><span class="params">( TCB_t *pxNewTCB, TaskFunction_t pxTaskCode, BaseType_t xCoreID )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TCB_t *curTCB, *tcb0, *tcb1;</span><br><span class="line">	configASSERT( xCoreID == tskNO_AFFINITY || xCoreID &lt; portNUM_PROCESSORS);</span><br><span class="line">    <span class="comment">//确保列表在被更新的过程中不会被中断打断</span></span><br><span class="line">	taskENTER_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">	&#123;</span><br><span class="line">		uxCurrentNumberOfTasks++;<span class="comment">//全局变量，统计任务数量</span></span><br><span class="line">		<span class="comment">//判断这个任务在哪个内核上运行</span></span><br><span class="line">		<span class="keyword">if</span> ( xCoreID == tskNO_AFFINITY )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> ( portNUM_PROCESSORS == <span class="number">1</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				xCoreID = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				tcb0 = pxCurrentTCB[<span class="number">0</span>];</span><br><span class="line">				tcb1 = pxCurrentTCB[<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span> ( tcb0 == <span class="literal">NULL</span> )</span><br><span class="line">				&#123;</span><br><span class="line">					xCoreID = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> ( tcb1 == <span class="literal">NULL</span> )</span><br><span class="line">				&#123;</span><br><span class="line">					xCoreID = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> ( tcb0-&gt;uxPriority &lt; pxNewTCB-&gt;uxPriority &amp;&amp; tcb0-&gt;uxPriority &lt; tcb1-&gt;uxPriority )</span><br><span class="line">				&#123;</span><br><span class="line">					xCoreID = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> ( tcb1-&gt;uxPriority &lt; pxNewTCB-&gt;uxPriority )</span><br><span class="line">				&#123;</span><br><span class="line">					xCoreID = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">//两个核上的运行的任务，其优先级都比新的任务要高</span></span><br><span class="line">				&#123;</span><br><span class="line">					xCoreID = xPortGetCoreID();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前的核上没有任务正在运行</span></span><br><span class="line">		<span class="keyword">if</span>( pxCurrentTCB[ xCoreID ] == <span class="literal">NULL</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			pxCurrentTCB[ xCoreID ] = pxNewTCB;</span><br><span class="line">			<span class="keyword">if</span>( uxCurrentNumberOfTasks == ( UBaseType_t ) <span class="number">1</span> )</span><br><span class="line">			&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> portFIRST_TASK_HOOK</span></span><br><span class="line">				<span class="keyword">if</span> ( xPortGetCoreID() == <span class="number">0</span> ) &#123;</span><br><span class="line">					vPortFirstTaskHook(pxTaskCode);</span><br><span class="line">				&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* configFIRST_TASK_HOOK */</span></span></span><br><span class="line">				<span class="comment">//正在创建的任务是第一个任务，那么需要先初始化相应的列表</span></span><br><span class="line">				prvInitialiseTaskLists();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				mtCOVERAGE_TEST_MARKER();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>( xSchedulerRunning == pdFALSE )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//新任务的优先级比正在运行的任务优先级高</span></span><br><span class="line">				<span class="keyword">if</span> ( pxCurrentTCB[xCoreID] == <span class="literal">NULL</span> || pxCurrentTCB[xCoreID]-&gt;uxPriority &lt;= pxNewTCB-&gt;uxPriority )</span><br><span class="line">				&#123;</span><br><span class="line">					pxCurrentTCB[xCoreID] = pxNewTCB;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				mtCOVERAGE_TEST_MARKER();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		uxTaskNumber++;<span class="comment">//uxTaskNumber加1，用作任务控制块编号</span></span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">		&#123;</span><br><span class="line">			pxNewTCB-&gt;uxTCBNumber = uxTaskNumber;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* configUSE_TRACE_FACILITY */</span></span></span><br><span class="line">		traceTASK_CREATE( pxNewTCB );</span><br><span class="line"></span><br><span class="line">		prvAddTaskToReadyList( pxNewTCB );</span><br><span class="line"></span><br><span class="line">		portSETUP_TCB( pxNewTCB );</span><br><span class="line">	&#125;</span><br><span class="line">	taskEXIT_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">	<span class="keyword">if</span>( xSchedulerRunning != pdFALSE )</span><br><span class="line">	&#123;</span><br><span class="line">		taskENTER_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">		curTCB = pxCurrentTCB[ xCoreID ];</span><br><span class="line">        <span class="comment">//如果新任务的任务优先级最高，而且调度器已经开始正常运行了，那么就执行任务切换</span></span><br><span class="line">		<span class="keyword">if</span>( curTCB == <span class="literal">NULL</span> || curTCB-&gt;uxPriority &lt; pxNewTCB-&gt;uxPriority )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>( xCoreID == xPortGetCoreID() )</span><br><span class="line">			&#123;</span><br><span class="line">				taskYIELD_IF_USING_PREEMPTION();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				taskYIELD_OTHER_CORE(xCoreID, pxNewTCB-&gt;uxPriority);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			mtCOVERAGE_TEST_MARKER();</span><br><span class="line">		&#125;</span><br><span class="line">		taskEXIT_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		mtCOVERAGE_TEST_MARKER();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="prvAddTaskToReadyList宏"><a href="#prvAddTaskToReadyList宏" class="headerlink" title="prvAddTaskToReadyList宏"></a>prvAddTaskToReadyList宏</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prvAddTaskToReadyList( pxTCB )												\</span></span><br><span class="line">	traceMOVED_TASK_TO_READY_STATE( pxTCB );										\</span><br><span class="line">	taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority );								\</span><br><span class="line">	vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xGenericListItem ) )<span class="comment">//将任务添加到就绪列表的末尾</span></span><br></pre></td></tr></table></figure>
<h4 id="vTaskDelete函数"><a href="#vTaskDelete函数" class="headerlink" title="vTaskDelete函数"></a>vTaskDelete函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vTaskDelete</span><span class="params">( TaskHandle_t xTaskToDelete )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCB_t *pxTCB;</span><br><span class="line">    <span class="keyword">int</span> core = xPortGetCoreID();</span><br><span class="line">    UBaseType_t free_now;</span><br><span class="line"></span><br><span class="line">    taskENTER_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">    &#123;</span><br><span class="line">        pxTCB = prvGetTCBFromHandle( xTaskToDelete );<span class="comment">//根据任务句柄获取TCB指针</span></span><br><span class="line">        <span class="comment">//将任务从就绪列表中删除</span></span><br><span class="line">        <span class="keyword">if</span>( uxListRemove( &amp;( pxTCB-&gt;xGenericListItem ) ) == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断该任务是否在等待某个事件，如果是这样，则这个任务会被放到相应的列表中，这里需要将其移除</span></span><br><span class="line">        <span class="keyword">if</span>( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ( <span class="keyword">void</span> ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发调试器刷新任务列表</span></span><br><span class="line">        uxTaskNumber++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//被删除的任务是正在运行的任务，或者在别的核，那么就交给空闲任务来释放内存</span></span><br><span class="line">        <span class="keyword">if</span>( pxTCB == pxCurrentTCB[ core ] ||</span><br><span class="line">           (portNUM_PROCESSORS &gt; <span class="number">1</span> &amp;&amp; pxTCB == pxCurrentTCB[ !core ]) ||</span><br><span class="line">           (portNUM_PROCESSORS &gt; <span class="number">1</span> &amp;&amp; pxTCB-&gt;xCoreID == (!core)) )</span><br><span class="line">        &#123;</span><br><span class="line">            vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xGenericListItem ) );</span><br><span class="line">            ++uxTasksDeleted;</span><br><span class="line">            portPRE_TASK_DELETE_HOOK( pxTCB, &amp;xYieldPending[xPortGetCoreID()] );<span class="comment">//调用任务删除钩子函数</span></span><br><span class="line">            free_now = pdFALSE;		<span class="comment">//不能立即释放内存</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//要删除的任务不是当前运行的，也不在别的核上</span></span><br><span class="line">        &#123;</span><br><span class="line">            --uxCurrentNumberOfTasks;</span><br><span class="line">            <span class="comment">//重新计算一下还要多长时间执行下一个任务，也就是下一个任务的解锁时间，防止有的任务的解锁时间参考了刚刚被删除的那个任务</span></span><br><span class="line">            prvResetNextTaskUnblockTime();</span><br><span class="line">            free_now = pdTRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        traceTASK_DELETE( pxTCB );</span><br><span class="line">    &#125;</span><br><span class="line">    taskEXIT_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(free_now == pdTRUE)&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> ( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 ) &amp;&amp; ( configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS )</span></span><br><span class="line">        prvDeleteTLS( pxTCB );	<span class="comment">//Run deletion callbacks before deleting TCB</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        prvDeleteTCB( pxTCB );	<span class="comment">//Must only be called after del cb</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果删除的是正在运行的任务，那么删除完以后肯定需要强制进行一次任务切换</span></span><br><span class="line">    <span class="keyword">if</span>( xSchedulerRunning != pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( pxTCB == pxCurrentTCB[ core ] )</span><br><span class="line">        &#123;</span><br><span class="line">            configASSERT( uxSchedulerSuspended[ core ] == <span class="number">0</span> );</span><br><span class="line">            portPRE_TASK_DELETE_HOOK( pxTCB, &amp;xYieldPending[xPortGetCoreID()] );</span><br><span class="line">            portYIELD_WITHIN_API();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( portNUM_PROCESSORS &gt; <span class="number">1</span> &amp;&amp; pxTCB == pxCurrentTCB[ !core] )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果被删除的任务正在另外一个核上运行，强制另外一个核做任务切换</span></span><br><span class="line">            vPortYieldOtherCore( !core );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vTaskSuspend函数"><a href="#vTaskSuspend函数" class="headerlink" title="vTaskSuspend函数"></a>vTaskSuspend函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vTaskSuspend</span><span class="params">( TaskHandle_t xTaskToSuspend )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCB_t *pxTCB;</span><br><span class="line">    TCB_t *curTCB;</span><br><span class="line"></span><br><span class="line">    taskENTER_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">    &#123;</span><br><span class="line">        pxTCB = prvGetTCBFromHandle( xTaskToSuspend );</span><br><span class="line">        traceTASK_SUSPEND( pxTCB );</span><br><span class="line">        <span class="comment">//将任务从就绪列表中删除</span></span><br><span class="line">        <span class="keyword">if</span>( uxListRemove( &amp;( pxTCB-&gt;xGenericListItem ) ) == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将任务从事件列表中删除</span></span><br><span class="line">        <span class="keyword">if</span>( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ( <span class="keyword">void</span> ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">        traceMOVED_TASK_TO_SUSPENDED_LIST(pxTCB);</span><br><span class="line">        <span class="comment">//将任务添加到挂起列表的最后</span></span><br><span class="line">        vListInsertEnd( &amp;xSuspendedTaskList, &amp;( pxTCB-&gt;xGenericListItem ) );</span><br><span class="line">        curTCB = pxCurrentTCB[ xPortGetCoreID() ];</span><br><span class="line">    &#125;</span><br><span class="line">    taskEXIT_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pxTCB == curTCB )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( xSchedulerRunning != pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//确保当前核的任务调度器工作正常</span></span><br><span class="line">            configASSERT( uxSchedulerSuspended[ xPortGetCoreID() ] == <span class="number">0</span> );</span><br><span class="line">            portYIELD_WITHIN_API();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//任务调度器不在工作，只能手动查找下一个要运行的任务</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//所有的任务都被挂起，事实上这种情况几乎不存在，除非在空闲任务中调用了阻塞的API</span></span><br><span class="line">            <span class="keyword">if</span>( listCURRENT_LIST_LENGTH( &amp;xSuspendedTaskList ) == uxCurrentNumberOfTasks )</span><br><span class="line">            &#123;</span><br><span class="line">                taskENTER_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">                pxCurrentTCB[ xPortGetCoreID() ] = <span class="literal">NULL</span>;</span><br><span class="line">                taskEXIT_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//获取下一个要运行的任务</span></span><br><span class="line">                vTaskSwitchContext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( xSchedulerRunning != pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果被挂起的任务当前不在运行，重新计算一下还要多长时间执行下一个任务，防止有的任务的解锁时间参考了刚刚被挂起的任务</span></span><br><span class="line">            taskENTER_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">            &#123;</span><br><span class="line">                prvResetNextTaskUnblockTime();</span><br><span class="line">            &#125;</span><br><span class="line">            taskEXIT_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vTaskResume函数"><a href="#vTaskResume函数" class="headerlink" title="vTaskResume函数"></a>vTaskResume函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vTaskResume</span><span class="params">( TaskHandle_t xTaskToResume )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCB_t * <span class="keyword">const</span> pxTCB = ( TCB_t * ) xTaskToResume;</span><br><span class="line"></span><br><span class="line">    configASSERT( xTaskToResume );</span><br><span class="line">    taskENTER_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">    <span class="comment">//xTaskToResume不能为NULL，也不应该存在恢复当前正在运行的任务这种情况</span></span><br><span class="line">    <span class="keyword">if</span>( ( pxTCB != <span class="literal">NULL</span> ) &amp;&amp; ( pxTCB != pxCurrentTCB[ xPortGetCoreID() ] ) )</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )</span><br><span class="line">            &#123;</span><br><span class="line">                traceTASK_RESUME( pxTCB );</span><br><span class="line">                <span class="comment">//将要恢复的任务从挂起列表中删除</span></span><br><span class="line">                ( <span class="keyword">void</span> ) uxListRemove(  &amp;( pxTCB-&gt;xGenericListItem ) );</span><br><span class="line">                <span class="comment">//将要恢复的任务添加到就绪任务列表中</span></span><br><span class="line">                prvAddTaskToReadyList( pxTCB );</span><br><span class="line">                <span class="comment">//如果被恢复的任务优先级更高</span></span><br><span class="line">                <span class="keyword">if</span>( tskCAN_RUN_HERE(pxTCB-&gt;xCoreID) &amp;&amp; pxTCB-&gt;uxPriority &gt;= pxCurrentTCB[ xPortGetCoreID() ]-&gt;uxPriority )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//这个yield不会让恢复的任务立即运行，但是会刷新就绪列表</span></span><br><span class="line">                    taskYIELD_IF_USING_PREEMPTION();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( pxTCB-&gt;xCoreID != xPortGetCoreID() )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//被恢复的任务不属于当前的核</span></span><br><span class="line">                    taskYIELD_OTHER_CORE( pxTCB-&gt;xCoreID, pxTCB-&gt;uxPriority );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">    taskEXIT_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FreeRTOS任务切换"><a href="#FreeRTOS任务切换" class="headerlink" title="FreeRTOS任务切换"></a>FreeRTOS任务切换</h2><ul>
<li>FreeRTOS任务切换的场合</li>
</ul>
<blockquote>
<ol>
<li>执行一个会引起任务切换的API函数，比如<strong>taskYIELD</strong></li>
<li>系统滴答定时器中断</li>
</ol>
</blockquote>
<ul>
<li><del>任务切换一般是在PendSV（可挂起的系统调用）中断服务函数里面完成的</del></li>
</ul>
<h3 id="执行系统调用"><a href="#执行系统调用" class="headerlink" title="执行系统调用"></a>执行系统调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> taskYIELD()					portYIELD()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> portYIELD()					vPortYield()</span></span><br></pre></td></tr></table></figure>
<h4 id="vPortYield函数"><a href="#vPortYield函数" class="headerlink" title="vPortYield函数"></a>vPortYield函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数void vPortYield(void)使用汇编实现，主要功能是保存待暂停任务的最小现场环境，清除CPENABLE，最后调用_frxt_dispatch函数实现真正的上下文切换</span></span><br><span class="line">    .globl  vPortYield</span><br><span class="line">    .type   vPortYield,@function</span><br><span class="line">    .align  <span class="number">4</span></span><br><span class="line">vPortYield:</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __XTENSA_CALL0_ABI__</span></span><br><span class="line">    addi    sp,  sp, -XT_SOL_FRMSZ</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    entry   sp,  XT_SOL_FRMSZ</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    rsr     a2,  PS</span><br><span class="line">    s32i    a0,  sp, XT_SOL_PC</span><br><span class="line">    s32i    a2,  sp, XT_SOL_PS</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __XTENSA_CALL0_ABI__</span></span><br><span class="line">    s32i    a12, sp, XT_SOL_A12         <span class="comment">/* save callee-saved registers      */</span></span><br><span class="line">    s32i    a13, sp, XT_SOL_A13</span><br><span class="line">    s32i    a14, sp, XT_SOL_A14</span><br><span class="line">    s32i    a15, sp, XT_SOL_A15</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/* Spill register windows. Calling xthal_window_spill() causes extra    */</span></span><br><span class="line">    <span class="comment">/* spills and reloads, so we will set things up to call the _nw version */</span></span><br><span class="line">    <span class="comment">/* instead to save cycles.                                              */</span></span><br><span class="line">    movi    a6,  ~(PS_WOE_MASK|PS_INTLEVEL_MASK)  <span class="comment">/* spills a4-a7 if needed */</span></span><br><span class="line">    <span class="keyword">and</span>     a2,  a2, a6                           <span class="comment">/* clear WOE, INTLEVEL    */</span></span><br><span class="line">    addi    a2,  a2, XCHAL_EXCM_LEVEL             <span class="comment">/* set INTLEVEL           */</span></span><br><span class="line">    wsr     a2,  PS</span><br><span class="line">    rsync</span><br><span class="line">    call0   xthal_window_spill_nw</span><br><span class="line">    l32i    a2,  sp, XT_SOL_PS                    <span class="comment">/* restore PS             */</span></span><br><span class="line">    wsr     a2,  PS</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    rsil    a2,  XCHAL_EXCM_LEVEL       <span class="comment">/* disable low/med interrupts       */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> XCHAL_CP_NUM &gt; 0</span></span><br><span class="line">    <span class="comment">/* Save coprocessor callee-saved state (if any). At this point CPENABLE */</span></span><br><span class="line">    <span class="comment">/* should still reflect which CPs were in use (enabled).                */</span></span><br><span class="line">    call0   _xt_coproc_savecs</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    movi    a2,  pxCurrentTCB</span><br><span class="line">	getcoreid a3</span><br><span class="line">	addx4	a2,  a3, a2</span><br><span class="line">    l32i    a2,  a2, <span class="number">0</span>                  <span class="comment">/* a2 = pxCurrentTCB                */</span></span><br><span class="line">    movi    a3,  <span class="number">0</span></span><br><span class="line">    s32i    a3,  sp, XT_SOL_EXIT        <span class="comment">/* 0 to flag as solicited frame     */</span></span><br><span class="line">    s32i    sp,  a2, TOPOFSTACK_OFFS    <span class="comment">/* pxCurrentTCB-&gt;pxTopOfStack = SP  */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> XCHAL_CP_NUM &gt; 0</span></span><br><span class="line">    <span class="comment">/* Clear CPENABLE, also in task's co-processor state save area. */</span></span><br><span class="line">    l32i    a2,  a2, CP_TOPOFSTACK_OFFS <span class="comment">/* a2 = pxCurrentTCB-&gt;cp_state      */</span></span><br><span class="line">    movi    a3,  <span class="number">0</span></span><br><span class="line">    wsr     a3,  CPENABLE</span><br><span class="line">    beqz    a2,  <span class="number">1f</span></span><br><span class="line">    s16i    a3,  a2, XT_CPENABLE        <span class="comment">/* clear saved cpenable             */</span></span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tail-call dispatcher. */</span></span><br><span class="line">    call0   _frxt_dispatch</span><br><span class="line">    <span class="comment">/* Never reaches here. */</span></span><br></pre></td></tr></table></figure>
<h4 id="frxt-dispatch函数"><a href="#frxt-dispatch函数" class="headerlink" title="_frxt_dispatch函数"></a>_frxt_dispatch函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数的功能是将上下文切换到最高优先级的就绪任务，恢复它的状态，最后将将控制权转交给它</span></span><br><span class="line">    .globl  _frxt_dispatch</span><br><span class="line">    .type   _frxt_dispatch,@function</span><br><span class="line">    .align  <span class="number">4</span></span><br><span class="line">_frxt_dispatch:</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __XTENSA_CALL0_ABI__</span></span><br><span class="line">    call0   vTaskSwitchContext  <span class="comment">// Get next TCB to resume</span></span><br><span class="line">    movi    a2, pxCurrentTCB</span><br><span class="line">	getcoreid a3</span><br><span class="line">	addx4	a2,  a3, a2</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    call4   vTaskSwitchContext  <span class="comment">// Get next TCB to resume</span></span><br><span class="line">    movi    a2, pxCurrentTCB</span><br><span class="line">	getcoreid a3</span><br><span class="line">	addx4	a2,  a3, a2</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    l32i    a3,  a2, <span class="number">0</span></span><br><span class="line">    l32i    sp,  a3, TOPOFSTACK_OFFS     <span class="comment">/* SP = next_TCB-&gt;pxTopOfStack;  */</span></span><br><span class="line">    s32i    a3,  a2, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Determine the type of stack frame. */</span></span><br><span class="line">    l32i    a2,  sp, XT_STK_EXIT        <span class="comment">/* exit dispatcher or solicited flag */</span></span><br><span class="line">    bnez    a2,  .L_frxt_dispatch_stk</span><br><span class="line"></span><br><span class="line">.L_frxt_dispatch_sol:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Solicited stack frame. Restore minimal context and return from vPortYield(). */</span></span><br><span class="line">    l32i    a3,  sp, XT_SOL_PS</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __XTENSA_CALL0_ABI__</span></span><br><span class="line">    l32i    a12, sp, XT_SOL_A12</span><br><span class="line">    l32i    a13, sp, XT_SOL_A13</span><br><span class="line">    l32i    a14, sp, XT_SOL_A14</span><br><span class="line">    l32i    a15, sp, XT_SOL_A15</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    l32i    a0,  sp, XT_SOL_PC</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> XCHAL_CP_NUM &gt; 0</span></span><br><span class="line">    <span class="comment">/* Ensure wsr.CPENABLE is complete (should be, it was cleared on entry). */</span></span><br><span class="line">    rsync</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* As soons as PS is restored, interrupts can happen. No need to sync PS. */</span></span><br><span class="line">    wsr     a3,  PS</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __XTENSA_CALL0_ABI__</span></span><br><span class="line">    addi    sp,  sp, XT_SOL_FRMSZ</span><br><span class="line">    ret</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    retw</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">.L_frxt_dispatch_stk:</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> XCHAL_CP_NUM &gt; 0</span></span><br><span class="line">    <span class="comment">/* Restore CPENABLE from task's co-processor save area. */</span></span><br><span class="line">    movi    a3, pxCurrentTCB            <span class="comment">/* cp_state =                       */</span></span><br><span class="line">	getcoreid a2</span><br><span class="line">	addx4	a3,  a2, a3</span><br><span class="line">    l32i    a3, a3, <span class="number">0</span></span><br><span class="line">    l32i    a2, a3, CP_TOPOFSTACK_OFFS     <span class="comment">/* StackType_t                       *pxStack; */</span></span><br><span class="line">    l16ui   a3, a2, XT_CPENABLE         <span class="comment">/* CPENABLE = cp_state-&gt;cpenable;   */</span></span><br><span class="line">    wsr     a3, CPENABLE</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Interrupt stack frame. Restore full context and return to exit dispatcher. */</span></span><br><span class="line">    call0   _xt_context_restore</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In Call0 ABI, restore callee-saved regs (A12, A13 already restored). */</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __XTENSA_CALL0_ABI__</span></span><br><span class="line">    l32i    a14, sp, XT_STK_A14</span><br><span class="line">    l32i    a15, sp, XT_STK_A15</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> XCHAL_CP_NUM &gt; 0</span></span><br><span class="line">    <span class="comment">/* Ensure wsr.CPENABLE has completed. */</span></span><br><span class="line">    rsync</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Must return via the exit dispatcher corresponding to the entrypoint from which</span></span><br><span class="line"><span class="comment">    this was called. Interruptee's A0, A1, PS, PC are restored and the interrupt</span></span><br><span class="line"><span class="comment">    stack frame is deallocated in the exit dispatcher.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    l32i    a0, sp, XT_STK_EXIT</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<h4 id="vTaskSwitchContext函数"><a href="#vTaskSwitchContext函数" class="headerlink" title="vTaskSwitchContext函数"></a>vTaskSwitchContext函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//理论上，该函数只有在滴答定时器中断和crosscore中断中被调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vTaskSwitchContext</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> irqstate=portENTER_CRITICAL_NESTED();</span><br><span class="line">	tskTCB * pxTCB;</span><br><span class="line">	<span class="keyword">if</span>( uxSchedulerSuspended[ xPortGetCoreID() ] != ( UBaseType_t ) pdFALSE )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* The scheduler is currently suspended - do not allow a context</span></span><br><span class="line"><span class="comment">		switch. */</span></span><br><span class="line">		xYieldPending[ xPortGetCoreID() ] = pdTRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		xYieldPending[ xPortGetCoreID() ] = pdFALSE;</span><br><span class="line">        xSwitchingContext[ xPortGetCoreID() ] = pdTRUE;</span><br><span class="line">		traceTASK_SWITCHED_OUT();</span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">if</span> ( configGENERATE_RUN_TIME_STATS == 1 )</span></span><br><span class="line">		&#123;</span><br><span class="line">				<span class="meta">#<span class="meta-keyword">ifdef</span> portALT_GET_RUN_TIME_COUNTER_VALUE</span></span><br><span class="line">					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );</span><br><span class="line">				<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();</span><br><span class="line">				<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">				<span class="comment">/* Add the amount of time the task has been running to the</span></span><br><span class="line"><span class="comment">				accumulated time so far.  The time the task started running was</span></span><br><span class="line"><span class="comment">				stored in ulTaskSwitchedInTime.  Note that there is no overflow</span></span><br><span class="line"><span class="comment">				protection here so count values are only valid until the timer</span></span><br><span class="line"><span class="comment">				overflows.  The guard against negative values is to protect</span></span><br><span class="line"><span class="comment">				against suspect run time stat counter implementations - which</span></span><br><span class="line"><span class="comment">				are provided by the application, not the kernel. */</span></span><br><span class="line">				taskENTER_CRITICAL_ISR(&amp;xTaskQueueMutex);</span><br><span class="line">				<span class="keyword">if</span>( ulTotalRunTime &gt; ulTaskSwitchedInTime[ xPortGetCoreID() ] )</span><br><span class="line">				&#123;</span><br><span class="line">					pxCurrentTCB[ xPortGetCoreID() ]-&gt;ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime[ xPortGetCoreID() ] );</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					mtCOVERAGE_TEST_MARKER();</span><br><span class="line">				&#125;</span><br><span class="line">				taskEXIT_CRITICAL_ISR(&amp;xTaskQueueMutex);</span><br><span class="line">				ulTaskSwitchedInTime[ xPortGetCoreID() ] = ulTotalRunTime;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* configGENERATE_RUN_TIME_STATS */</span></span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Check for stack overflow, if configured. */</span></span><br><span class="line">		taskFIRST_CHECK_FOR_STACK_OVERFLOW();</span><br><span class="line">		taskSECOND_CHECK_FOR_STACK_OVERFLOW();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Select a new task to run */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 We cannot do taskENTER_CRITICAL_ISR(&amp;xTaskQueueMutex); here because it saves the interrupt context to the task tcb, and we're</span></span><br><span class="line"><span class="comment">		 swapping that out here. Instead, we're going to do the work here ourselves. Because interrupts are already disabled, we only</span></span><br><span class="line"><span class="comment">		 need to acquire the mutex.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FREERTOS_PORTMUX_DEBUG</span></span><br><span class="line">		vPortCPUAcquireMutex( &amp;xTaskQueueMutex, __FUNCTION__, __LINE__ );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		vPortCPUAcquireMutex( &amp;xTaskQueueMutex );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">unsigned</span> portBASE_TYPE foundNonExecutingWaiter = pdFALSE, ableToSchedule = pdFALSE, resetListHead;</span><br><span class="line">		portBASE_TYPE uxDynamicTopReady = uxTopReadyPriority;</span><br><span class="line">		<span class="keyword">unsigned</span> portBASE_TYPE holdTop=pdFALSE;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  ToDo: This scheduler doesn't correctly implement the round-robin scheduling as done in the single-core</span></span><br><span class="line"><span class="comment">		 *  FreeRTOS stack when multiple tasks have the same priority and are all ready; it just keeps grabbing the</span></span><br><span class="line"><span class="comment">		 *  first one. ToDo: fix this.</span></span><br><span class="line"><span class="comment">		 *  (Is this still true? if any, there's the issue with one core skipping over the processes for the other</span></span><br><span class="line"><span class="comment">		 *  core, potentially not giving the skipped-over processes any time.)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> ( ableToSchedule == pdFALSE &amp;&amp; uxDynamicTopReady &gt;= <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			resetListHead = pdFALSE;</span><br><span class="line">			<span class="comment">// Nothing to do for empty lists</span></span><br><span class="line">			<span class="keyword">if</span> (!listLIST_IS_EMPTY( &amp;( pxReadyTasksLists[ uxDynamicTopReady ] ) )) &#123;</span><br><span class="line"></span><br><span class="line">				ableToSchedule = pdFALSE;</span><br><span class="line">				tskTCB * pxRefTCB;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* Remember the current list item so that we</span></span><br><span class="line"><span class="comment">				can detect if all items have been inspected.</span></span><br><span class="line"><span class="comment">				Once this happens, we move on to a lower</span></span><br><span class="line"><span class="comment">				priority list (assuming nothing is suitable</span></span><br><span class="line"><span class="comment">				for scheduling). Note: This can return NULL if</span></span><br><span class="line"><span class="comment">				the list index is at the listItem */</span></span><br><span class="line">				pxRefTCB = pxReadyTasksLists[ uxDynamicTopReady ].pxIndex-&gt;pvOwner;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> ((<span class="keyword">void</span>*)pxReadyTasksLists[ uxDynamicTopReady ].pxIndex==(<span class="keyword">void</span>*)&amp;pxReadyTasksLists[ uxDynamicTopReady ].xListEnd) &#123;</span><br><span class="line">					<span class="comment">//pxIndex points to the list end marker. Skip that and just get the next item.</span></span><br><span class="line">					listGET_OWNER_OF_NEXT_ENTRY( pxRefTCB, &amp;( pxReadyTasksLists[ uxDynamicTopReady ] ) );</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">do</span> &#123;</span><br><span class="line">					listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &amp;( pxReadyTasksLists[ uxDynamicTopReady ] ) );</span><br><span class="line">					<span class="comment">/* Find out if the next task in the list is</span></span><br><span class="line"><span class="comment">					already being executed by another core */</span></span><br><span class="line">					foundNonExecutingWaiter = pdTRUE;</span><br><span class="line">					portBASE_TYPE i = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;portNUM_PROCESSORS; i++ ) &#123;</span><br><span class="line">						<span class="keyword">if</span> (i == xPortGetCoreID()) &#123;</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">						&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pxCurrentTCB[i] == pxTCB) &#123;</span><br><span class="line">							holdTop=pdTRUE; <span class="comment">//keep this as the top prio, for the other CPU</span></span><br><span class="line">							foundNonExecutingWaiter = pdFALSE;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (foundNonExecutingWaiter == pdTRUE) &#123;</span><br><span class="line">						<span class="comment">/* If the task is not being executed</span></span><br><span class="line"><span class="comment">						by another core and its affinity is</span></span><br><span class="line"><span class="comment">						compatible with the current one,</span></span><br><span class="line"><span class="comment">						prepare it to be swapped in */</span></span><br><span class="line">						<span class="keyword">if</span> (pxTCB-&gt;xCoreID == tskNO_AFFINITY) &#123;</span><br><span class="line">							pxCurrentTCB[xPortGetCoreID()] = pxTCB;</span><br><span class="line">							ableToSchedule = pdTRUE;</span><br><span class="line">						&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pxTCB-&gt;xCoreID == xPortGetCoreID()) &#123;</span><br><span class="line">							pxCurrentTCB[xPortGetCoreID()] = pxTCB;</span><br><span class="line">							ableToSchedule = pdTRUE;</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							ableToSchedule = pdFALSE;</span><br><span class="line">							holdTop=pdTRUE; <span class="comment">//keep this as the top prio, for the other CPU</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						ableToSchedule = pdFALSE;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (ableToSchedule == pdFALSE) &#123;</span><br><span class="line">						resetListHead = pdTRUE;</span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((ableToSchedule == pdTRUE) &amp;&amp; (resetListHead == pdTRUE)) &#123;</span><br><span class="line">						tskTCB * pxResetTCB;</span><br><span class="line">						<span class="keyword">do</span> &#123;</span><br><span class="line">							listGET_OWNER_OF_NEXT_ENTRY( pxResetTCB, &amp;( pxReadyTasksLists[ uxDynamicTopReady ] ) );</span><br><span class="line">						&#125; <span class="keyword">while</span>(pxResetTCB != pxRefTCB);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">while</span> ((ableToSchedule == pdFALSE) &amp;&amp; (pxTCB != pxRefTCB));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (!holdTop) --uxTopReadyPriority;</span><br><span class="line">			&#125;</span><br><span class="line">			--uxDynamicTopReady;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		traceTASK_SWITCHED_IN();</span><br><span class="line">        xSwitchingContext[ xPortGetCoreID() ] = pdFALSE;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Exit critical region manually as well: release the mux now, interrupts will be re-enabled when we</span></span><br><span class="line">		<span class="comment">//exit the function.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FREERTOS_PORTMUX_DEBUG</span></span><br><span class="line">		vPortCPUReleaseMutex( &amp;xTaskQueueMutex, __FUNCTION__, __LINE__ );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		vPortCPUReleaseMutex( &amp;xTaskQueueMutex );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_FREERTOS_WATCHPOINT_END_OF_STACK</span></span><br><span class="line">		vPortSetStackWatchpoint(pxCurrentTCB[xPortGetCoreID()]-&gt;pxStack);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	portEXIT_CRITICAL_NESTED(irqstate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="系统滴答定时器中断"><a href="#系统滴答定时器中断" class="headerlink" title="系统滴答定时器中断"></a>系统滴答定时器中断</h3><h4 id="frxt-timer-int"><a href="#frxt-timer-int" class="headerlink" title="_frxt_timer_int"></a>_frxt_timer_int</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数是系统滴答定时器中断处理函数，每一次tick时钟到来都会调用一次xPortSysTickHandler</span></span><br><span class="line">    .globl  _frxt_timer_int</span><br><span class="line">    .type   _frxt_timer_int,@function</span><br><span class="line">    .align  <span class="number">4</span></span><br><span class="line">_frxt_timer_int:</span><br><span class="line"></span><br><span class="line">    ENTRY(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM_TRACE</span></span><br><span class="line">    movi a6, <span class="number">1</span> <span class="comment">/* = ESP_PM_TRACE_TICK */</span></span><br><span class="line">    getcoreid a7</span><br><span class="line">    call4 esp_pm_trace_enter</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CONFIG_PM_TRACE</span></span></span><br><span class="line"></span><br><span class="line">.L_xt_timer_int_catchup:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update the timer comparator for the next tick. */</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> XT_CLOCK_FREQ</span></span><br><span class="line">    movi    a2, XT_TICK_DIVISOR         <span class="comment">/* a2 = comparator increment          */</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    movi    a3, _xt_tick_divisor</span><br><span class="line">    l32i    a2, a3, <span class="number">0</span>                   <span class="comment">/* a2 = comparator increment          */</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    rsr     a3, XT_CCOMPARE             <span class="comment">/* a3 = old comparator value          */</span></span><br><span class="line">    add     a4, a3, a2                  <span class="comment">/* a4 = new comparator value          */</span></span><br><span class="line">    wsr     a4, XT_CCOMPARE             <span class="comment">/* update comp. and clear interrupt   */</span></span><br><span class="line">    esync</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __XTENSA_CALL0_ABI__</span></span><br><span class="line">    <span class="comment">/* Preserve a2 and a3 across C calls. */</span></span><br><span class="line">    s32i    a2, sp, <span class="number">4</span></span><br><span class="line">    s32i    a3, sp, <span class="number">8</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Call the FreeRTOS tick handler (see port.c). */</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __XTENSA_CALL0_ABI__</span></span><br><span class="line">    call0   xPortSysTickHandler</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    call4   xPortSysTickHandler</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __XTENSA_CALL0_ABI__</span></span><br><span class="line">    <span class="comment">/* Restore a2 and a3. */</span></span><br><span class="line">    l32i    a2, sp, <span class="number">4</span></span><br><span class="line">    l32i    a3, sp, <span class="number">8</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we need to process more ticks to catch up. */</span></span><br><span class="line">    esync                               <span class="comment">/* ensure comparator update complete  */</span></span><br><span class="line">    rsr     a4, CCOUNT                  <span class="comment">/* a4 = cycle count                   */</span></span><br><span class="line">    sub     a4, a4, a3                  <span class="comment">/* diff = ccount - old comparator     */</span></span><br><span class="line">    blt     a2, a4, .L_xt_timer_int_catchup  <span class="comment">/* repeat while diff &gt; divisor */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM_TRACE</span></span><br><span class="line">    movi a6, <span class="number">1</span> <span class="comment">/* = ESP_PM_TRACE_TICK */</span></span><br><span class="line">    getcoreid a7</span><br><span class="line">    call4 esp_pm_trace_exit</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CONFIG_PM_TRACE</span></span></span><br><span class="line"></span><br><span class="line">    RET(<span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<h4 id="xPortSysTickHandler函数"><a href="#xPortSysTickHandler函数" class="headerlink" title="xPortSysTickHandler函数"></a>xPortSysTickHandler函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xPortSysTickHandler</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BaseType_t ret;</span><br><span class="line"></span><br><span class="line">	portbenchmarkIntLatency();</span><br><span class="line">	traceISR_ENTER(SYSTICK_INTR_ID);</span><br><span class="line">	ret = xTaskIncrementTick();</span><br><span class="line">	<span class="keyword">if</span>( ret != pdFALSE )</span><br><span class="line">	&#123;</span><br><span class="line">		portYIELD_FROM_ISR();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		traceISR_EXIT();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> portYIELD_FROM_ISR()        &#123;traceISR_EXIT_TO_SCHEDULER(); _frxt_setup_switch();&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="frxt-setup-switch函数"><a href="#frxt-setup-switch函数" class="headerlink" title="_frxt_setup_switch函数"></a>_frxt_setup_switch函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在内部设置一个flag，在退出中断的时候_frxt_int_exit会检查该flag，如果发现flag被设置了，就调用函数vPortYieldFromInt</span></span><br><span class="line">    .global     _frxt_setup_switch</span><br><span class="line">    .type       _frxt_setup_switch,@function</span><br><span class="line">    .align      <span class="number">4</span></span><br><span class="line">_frxt_setup_switch:</span><br><span class="line"></span><br><span class="line">    ENTRY(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">	getcoreid a3</span><br><span class="line">    movi    a2, port_switch_flag</span><br><span class="line">	addx4	a2,  a3, a2</span><br><span class="line"></span><br><span class="line">    movi    a3, <span class="number">1</span></span><br><span class="line">    s32i    a3, a2, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    RET(<span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<h4 id="vPortYieldFromInt"><a href="#vPortYieldFromInt" class="headerlink" title="vPortYieldFromInt"></a>vPortYieldFromInt</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    .globl  vPortYieldFromInt</span><br><span class="line">    .type   vPortYieldFromInt,@function</span><br><span class="line">    .align  <span class="number">4</span></span><br><span class="line">vPortYieldFromInt:</span><br><span class="line">    ENTRY(<span class="number">16</span>)</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> XCHAL_CP_NUM &gt; 0</span></span><br><span class="line">    <span class="comment">/* Save CPENABLE in task's co-processor save area, and clear CPENABLE.  */</span></span><br><span class="line">    movi    a3, pxCurrentTCB            <span class="comment">/* cp_state =                       */</span></span><br><span class="line">	getcoreid a2</span><br><span class="line">	addx4	a3,  a2, a3</span><br><span class="line">    l32i    a3, a3, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    l32i    a2, a3, CP_TOPOFSTACK_OFFS</span><br><span class="line"></span><br><span class="line">    rsr     a3, CPENABLE</span><br><span class="line">    s16i    a3, a2, XT_CPENABLE         <span class="comment">/* cp_state-&gt;cpenable = CPENABLE;   */</span></span><br><span class="line">    movi    a3, <span class="number">0</span></span><br><span class="line">    wsr     a3, CPENABLE                <span class="comment">/* disable all co-processors        */</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __XTENSA_CALL0_ABI__</span></span><br><span class="line">    <span class="comment">/* Tail-call dispatcher. */</span></span><br><span class="line">    call0   _frxt_dispatch</span><br><span class="line">    <span class="comment">/* Never reaches here. */</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    RET(<span class="number">16</span>)</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="end-总结上下文切换的场合"><a href="#end-总结上下文切换的场合" class="headerlink" title=":end:总结上下文切换的场合"></a>:end:总结上下文切换的场合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	fd(_frxt_dispatch) --&gt; tsc(vTaskSwitchContext)</span><br><span class="line">    ty(taskYIELD/portYIELD) --&gt; py(vPortYield)</span><br><span class="line">    py --&gt; fd</span><br><span class="line">	</span><br><span class="line">	fie(XT_RTOS_INT_ENTER/_frxt_int_enter) --&gt; fti(_frxt_timer_int)</span><br><span class="line">    fti --&gt; psth(xPortSysTickHandler)</span><br><span class="line">    psth --&gt; pyfi(portYIELD_FROM_ISR)</span><br><span class="line">	pyfi --&gt; fss(_frxt_setup_switch)</span><br><span class="line">	fss --&gt; fiex(XT_RTOS_INT_EXIT/_frxt_int_exit)</span><br><span class="line">	fiex --&gt; pyf(vPortYieldFromInt)</span><br><span class="line">	pyf --&gt; fd</span><br><span class="line"></span><br><span class="line">	tyoc(taskYIELD_OTHER_CORE) --&gt; vpyoc(vPortYieldOtherCore)</span><br><span class="line">	vpyoc --&gt; ecisy(esp_crosscore_int_send_yield)</span><br><span class="line">	ecisy --&gt; ecis(esp_crosscore_int_send)</span><br><span class="line">	ecis --&gt; eci(esp_crosscore_isr)</span><br><span class="line">	eci --&gt; ecihy(esp_crosscore_isr_handle_yield)</span><br><span class="line">	ecihy --&gt; pyfi</span><br></pre></td></tr></table></figure>
<h2 id="FreeRTOS时间片调度"><a href="#FreeRTOS时间片调度" class="headerlink" title="FreeRTOS时间片调度"></a>FreeRTOS时间片调度</h2><blockquote>
<p>时间片调度发生在滴答定时器的中断服务函数中，在中断服务函数中会调用xPortSysTickHandler()，而xPortSysTickHandler会引发任务调度，只是这个任务调度是有条件的，只有<strong>xTaskIncrementTick</strong>的返回值不为pdFALSE时，才会进行任务调度。如果当前任务所对应的优先级下有其他的任务存在，那么函数xTaskIncrementTick就会返回pdTRUE。</p>
</blockquote>
<h2 id="FreeRTOS时间管理"><a href="#FreeRTOS时间管理" class="headerlink" title="FreeRTOS时间管理"></a>FreeRTOS时间管理</h2><h4 id="vTaskDelay相对延时函数"><a href="#vTaskDelay相对延时函数" class="headerlink" title="vTaskDelay相对延时函数"></a>vTaskDelay相对延时函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vTaskDelay</span><span class="params">( <span class="keyword">const</span> TickType_t xTicksToDelay )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TickType_t xTimeToWake;</span><br><span class="line">    BaseType_t xAlreadyYielded = pdFALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//延时的时间如果不大于0，那就相当于直接进行任务切换</span></span><br><span class="line">    <span class="keyword">if</span>( xTicksToDelay &gt; ( TickType_t ) <span class="number">0U</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        configASSERT( uxSchedulerSuspended[ xPortGetCoreID() ] == <span class="number">0</span> );</span><br><span class="line">        taskENTER_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">        &#123;</span><br><span class="line">            traceTASK_DELAY();</span><br><span class="line">            <span class="comment">//计算唤醒时间</span></span><br><span class="line">            xTimeToWake = xTickCount + xTicksToDelay;</span><br><span class="line">            <span class="comment">//从就绪列表上移除</span></span><br><span class="line">            <span class="keyword">if</span>( uxListRemove( &amp;( pxCurrentTCB[ xPortGetCoreID() ]-&gt;xGenericListItem ) ) == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                portRESET_READY_PRIORITY( pxCurrentTCB[ xPortGetCoreID() ]-&gt;uxPriority, uxTopReadyPriority );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//添加到延时列表中</span></span><br><span class="line">            prvAddCurrentTaskToDelayedList( xPortGetCoreID(), xTimeToWake );</span><br><span class="line">        &#125;</span><br><span class="line">        taskEXIT_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( xAlreadyYielded == pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        portYIELD_WITHIN_API();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="prvAddCurrentTaskToDelayedList函数"><a href="#prvAddCurrentTaskToDelayedList函数" class="headerlink" title="prvAddCurrentTaskToDelayedList函数"></a>prvAddCurrentTaskToDelayedList函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prvAddCurrentTaskToDelayedList</span><span class="params">( <span class="keyword">const</span> BaseType_t xCoreID, <span class="keyword">const</span> TickType_t xTimeToWake )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//按照唤醒时间从小到达的顺序，插入延时列表</span></span><br><span class="line">	listSET_LIST_ITEM_VALUE( &amp;( pxCurrentTCB[ xCoreID ]-&gt;xGenericListItem ), xTimeToWake );</span><br><span class="line">	<span class="keyword">if</span>( xTimeToWake &lt; xTickCount )</span><br><span class="line">	&#123;</span><br><span class="line">        traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();</span><br><span class="line">		<span class="comment">//唤醒时间已经溢出，将其插入延时溢出列表中</span></span><br><span class="line">		vListInsert( pxOverflowDelayedTaskList, &amp;( pxCurrentTCB[ xCoreID ]-&gt;xGenericListItem ) );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        traceMOVED_TASK_TO_DELAYED_LIST();</span><br><span class="line">		<span class="comment">//时间还没有溢出，插入延时列表中</span></span><br><span class="line">		vListInsert( pxDelayedTaskList, &amp;( pxCurrentTCB[ xCoreID ]-&gt;xGenericListItem ) );</span><br><span class="line">		<span class="comment">//xNextTaskUnblockTime是一个全局变量，保存着距离下一个要取消阻塞的任务最小时间点值</span></span><br><span class="line">		<span class="keyword">if</span>( xTimeToWake &lt; xNextTaskUnblockTime )</span><br><span class="line">		&#123;</span><br><span class="line">			xNextTaskUnblockTime = xTimeToWake;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			mtCOVERAGE_TEST_MARKER();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vTaskDelayUntil绝对延时函数"><a href="#vTaskDelayUntil绝对延时函数" class="headerlink" title="vTaskDelayUntil绝对延时函数"></a>vTaskDelayUntil绝对延时函数</h4><blockquote>
<p>使用该函数延时的任务也不一定能够周期性的运行，该函数只能保证按照一定的周期取消阻塞，进入就绪态</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vTaskDelayUntil</span><span class="params">( TickType_t * <span class="keyword">const</span> pxPreviousWakeTime, <span class="keyword">const</span> TickType_t xTimeIncrement )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TickType_t xTimeToWake;</span><br><span class="line">    BaseType_t xAlreadyYielded=pdFALSE, xShouldDelay = pdFALSE;</span><br><span class="line"></span><br><span class="line">    configASSERT( pxPreviousWakeTime );</span><br><span class="line">    configASSERT( ( xTimeIncrement &gt; <span class="number">0U</span> ) );</span><br><span class="line">    configASSERT( uxSchedulerSuspended[ xPortGetCoreID() ] == <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    taskENTER_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> TickType_t xConstTickCount = xTickCount;</span><br><span class="line">        <span class="comment">//计算任务被唤醒的时刻</span></span><br><span class="line">        xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;</span><br><span class="line">        <span class="comment">//tick计数器溢出</span></span><br><span class="line">        <span class="keyword">if</span>( xConstTickCount &lt; *pxPreviousWakeTime )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//tick计数器和唤醒时间都溢出，且tick计数器值比唤醒时间小</span></span><br><span class="line">            <span class="keyword">if</span>( ( xTimeToWake &lt; *pxPreviousWakeTime ) &amp;&amp; ( xTimeToWake &gt; xConstTickCount ) )</span><br><span class="line">            &#123;</span><br><span class="line">                xShouldDelay = pdTRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//tick计数器没有溢出，唤醒时间溢出或者tick计数器值比唤醒时间小，这两种情况都说明还需要继续延时</span></span><br><span class="line">            <span class="keyword">if</span>( ( xTimeToWake &lt; *pxPreviousWakeTime ) || ( xTimeToWake &gt; xConstTickCount ) )</span><br><span class="line">            &#123;</span><br><span class="line">                xShouldDelay = pdTRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为本函数的下一次执行做好准备</span></span><br><span class="line">        *pxPreviousWakeTime = xTimeToWake;</span><br><span class="line">        <span class="keyword">if</span>( xShouldDelay != pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            traceTASK_DELAY_UNTIL();</span><br><span class="line">            <span class="comment">//从就序列表中移除</span></span><br><span class="line">            <span class="keyword">if</span>( uxListRemove( &amp;( pxCurrentTCB[ xPortGetCoreID() ]-&gt;xGenericListItem ) ) == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                portRESET_READY_PRIORITY( pxCurrentTCB[ xPortGetCoreID() ]-&gt;uxPriority, uxTopReadyPriority );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">            prvAddCurrentTaskToDelayedList( xPortGetCoreID(), xTimeToWake );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    taskEXIT_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( xAlreadyYielded == pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        portYIELD_WITHIN_API();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="portYIELD-WITHIN-API宏定义"><a href="#portYIELD-WITHIN-API宏定义" class="headerlink" title="portYIELD_WITHIN_API宏定义"></a>portYIELD_WITHIN_API宏定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上下文切换工作需要等待直到中断被允许后才执行，这里使用cross-core中断来触发自己</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> portYIELD_WITHIN_API() esp_crosscore_int_send_yield(xPortGetCoreID())</span></span><br></pre></td></tr></table></figure>
<h4 id="xTaskIncreamentTick函数的主要功能"><a href="#xTaskIncreamentTick函数的主要功能" class="headerlink" title="xTaskIncreamentTick函数的主要功能"></a>xTaskIncreamentTick函数的主要功能</h4><blockquote>
<p>xTickCount是FreeRTOS的系统节拍计数器，每个滴答定时器中断后xTickCount就会增加一，xTickCount的具体操作是在函数xTaskIncrementTick中进行的</p>
</blockquote>
<ol>
<li>系统节拍计数器的值加1</li>
<li>判断是否有任务的延时等待时间已到，如果就就将其恢复</li>
<li>处理时间片调度</li>
<li>综上给出是否需要执行上下文切换的判断结果并返回滴答定时器中断</li>
</ol>
<h2 id="FreeRTOS队列"><a href="#FreeRTOS队列" class="headerlink" title="FreeRTOS队列"></a>FreeRTOS队列</h2><h4 id="队列结构体Queue-t"><a href="#队列结构体Queue-t" class="headerlink" title="队列结构体Queue_t"></a>队列结构体Queue_t</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueDefinition</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int8_t</span> *pcHead;					<span class="comment">//指向队列存储区开始位置</span></span><br><span class="line">	<span class="keyword">int8_t</span> *pcTail;					<span class="comment">//指向队列存储区最后一个字节</span></span><br><span class="line">	<span class="keyword">int8_t</span> *pcWriteTo;				<span class="comment">//指向存储区中下一个空闲区域</span></span><br><span class="line">	<span class="keyword">union</span>							</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int8_t</span> *pcReadFrom;			<span class="comment">//用作队列时指向最后一个出队的队列项首地址</span></span><br><span class="line">		UBaseType_t uxRecursiveCallCount;<span class="comment">//用作递归互斥信号量时用来记录递归互斥信号量被调用的次数</span></span><br><span class="line">	&#125; u;</span><br><span class="line">	List_t xTasksWaitingToSend;		<span class="comment">//那些因为队列满导致入队失败而进入阻塞态的任务就会挂到此列表上，按照优先级排列</span></span><br><span class="line">	List_t xTasksWaitingToReceive;	<span class="comment">//那些因为队列空导致出队失败而进入阻塞态的任务就会挂到此列表上，按照优先级排列</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">volatile</span> UBaseType_t uxMessagesWaiting;<span class="comment">//队列中当前的消息数量</span></span><br><span class="line">	UBaseType_t uxLength;			<span class="comment">//队列中允许的最大的消息数量</span></span><br><span class="line">	UBaseType_t uxItemSize;			<span class="comment">//每个消息允许的最大长度</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span>( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )</span></span><br><span class="line">		<span class="keyword">uint8_t</span> ucStaticallyAllocated;	<span class="comment">//如果队列的内存是静态分配的，则为pdTRUE</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_QUEUE_SETS == 1 )</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">QueueDefinition</span> *<span class="title">pxQueueSetContainer</span>;</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">		UBaseType_t uxQueueNumber;</span><br><span class="line">		<span class="keyword">uint8_t</span> ucQueueType;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	portMUX_TYPE mux;		<span class="comment">//因为SMP的原因，所以需要互斥锁</span></span><br><span class="line"></span><br><span class="line">&#125; xQUEUE;</span><br><span class="line"><span class="keyword">typedef</span> xQUEUE Queue_t;</span><br></pre></td></tr></table></figure>
<h4 id="创建队列xQueueCreate"><a href="#创建队列xQueueCreate" class="headerlink" title="创建队列xQueueCreate"></a>创建队列xQueueCreate</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xQueueCreate( uxQueueLength, uxItemSize ) xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) )<span class="comment">//普通消息队列的类型是queueQUEUE_TYPE_BASE</span></span></span><br><span class="line"><span class="function">QueueHandle_t <span class="title">xQueueGenericCreate</span><span class="params">( <span class="keyword">const</span> UBaseType_t uxQueueLength, <span class="keyword">const</span> UBaseType_t uxItemSize, <span class="keyword">const</span> <span class="keyword">uint8_t</span> ucQueueType )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue_t *pxNewQueue;</span><br><span class="line">    <span class="keyword">size_t</span> xQueueSizeInBytes;</span><br><span class="line">    <span class="keyword">uint8_t</span> *pucQueueStorage;</span><br><span class="line">    configASSERT( uxQueueLength &gt; ( UBaseType_t ) <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span>( uxItemSize == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        xQueueSizeInBytes = ( <span class="keyword">size_t</span> ) <span class="number">0</span>;<span class="comment">//如果队列大小为0，那么就不需要存储区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        xQueueSizeInBytes = ( <span class="keyword">size_t</span> ) ( uxQueueLength * uxItemSize );</span><br><span class="line">    &#125;</span><br><span class="line">    pxNewQueue = ( Queue_t * ) pvPortMalloc( <span class="keyword">sizeof</span>( Queue_t ) + xQueueSizeInBytes );<span class="comment">//分配内存，这里申请的内存大小是队列结构体和队列中消息存储区的总大小</span></span><br><span class="line">    <span class="keyword">if</span>( pxNewQueue != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        pucQueueStorage = ( ( <span class="keyword">uint8_t</span> * ) pxNewQueue ) + <span class="keyword">sizeof</span>( Queue_t );</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span>( configSUPPORT_STATIC_ALLOCATION == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            pxNewQueue-&gt;ucStaticallyAllocated = pdFALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* configSUPPORT_STATIC_ALLOCATION */</span></span></span><br><span class="line">        prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );<span class="comment">//初始化队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pxNewQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化队列prvInitialiseNewQueue"><a href="#初始化队列prvInitialiseNewQueue" class="headerlink" title="初始化队列prvInitialiseNewQueue"></a>初始化队列prvInitialiseNewQueue</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prvInitialiseNewQueue</span><span class="params">( <span class="keyword">const</span> UBaseType_t uxQueueLength, <span class="keyword">const</span> UBaseType_t uxItemSize, <span class="keyword">uint8_t</span> *pucQueueStorage, <span class="keyword">const</span> <span class="keyword">uint8_t</span> ucQueueType, Queue_t *pxNewQueue )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	( <span class="keyword">void</span> ) ucQueueType;</span><br><span class="line">	<span class="keyword">if</span>( uxItemSize == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//没有队列存储区，这里将pcHead指向队列开始地址</span></span><br><span class="line">		pxNewQueue-&gt;pcHead = ( <span class="keyword">int8_t</span> * ) pxNewQueue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//设置pcHaed指向队列存储区首地址</span></span><br><span class="line">		pxNewQueue-&gt;pcHead = ( <span class="keyword">int8_t</span> * ) pucQueueStorage;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化队列结构体相关成员变量</span></span><br><span class="line">	pxNewQueue-&gt;uxLength = uxQueueLength;</span><br><span class="line">	pxNewQueue-&gt;uxItemSize = uxItemSize;</span><br><span class="line">	( <span class="keyword">void</span> ) xQueueGenericReset( pxNewQueue, pdTRUE );<span class="comment">//复位队列</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		pxNewQueue-&gt;ucQueueType = ucQueueType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* configUSE_TRACE_FACILITY */</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span>( configUSE_QUEUE_SETS == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		pxNewQueue-&gt;pxQueueSetContainer = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* configUSE_QUEUE_SETS */</span></span></span><br><span class="line">	traceQUEUE_CREATE( pxNewQueue );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="队列复位函数xQueueGenericReset"><a href="#队列复位函数xQueueGenericReset" class="headerlink" title="队列复位函数xQueueGenericReset"></a>队列复位函数xQueueGenericReset</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xQueueGenericReset</span><span class="params">( QueueHandle_t xQueue, BaseType_t xNewQueue )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Queue_t * <span class="keyword">const</span> pxQueue = ( Queue_t * ) xQueue;</span><br><span class="line">	configASSERT( pxQueue );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( xNewQueue == pdTRUE )</span><br><span class="line">	&#123;</span><br><span class="line">		vPortCPUInitializeMutex(&amp;pxQueue-&gt;mux);<span class="comment">//初始化互斥锁</span></span><br><span class="line">	&#125;</span><br><span class="line">	taskENTER_CRITICAL(&amp;pxQueue-&gt;mux);</span><br><span class="line">	&#123;</span><br><span class="line">		pxQueue-&gt;pcTail = pxQueue-&gt;pcHead + ( pxQueue-&gt;uxLength * pxQueue-&gt;uxItemSize );<span class="comment">//pcTail指向队列存储区的末尾</span></span><br><span class="line">		pxQueue-&gt;uxMessagesWaiting = ( UBaseType_t ) <span class="number">0U</span>;<span class="comment">//队列中当前的消息数量是0</span></span><br><span class="line">		pxQueue-&gt;pcWriteTo = pxQueue-&gt;pcHead;<span class="comment">//指向队列存储区中下一个可写入的位置</span></span><br><span class="line">		pxQueue-&gt;u.pcReadFrom = pxQueue-&gt;pcHead + ( ( pxQueue-&gt;uxLength - ( UBaseType_t ) <span class="number">1U</span> ) * pxQueue-&gt;uxItemSize );<span class="comment">//指向队列存储区中下一个可读取的位置</span></span><br><span class="line">		<span class="keyword">if</span>( xNewQueue == pdFALSE )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//由于复位队列以后队列依旧是空的，对于那些从队列中读取而被阻塞的任务来说依旧保持阻塞状态。但是对于那些向队列中写入数据而阻塞的任务来说，这些任务需要接触阻塞状态</span></span><br><span class="line">			<span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdTRUE )</span><br><span class="line">				&#123;</span><br><span class="line">					queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					mtCOVERAGE_TEST_MARKER();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				mtCOVERAGE_TEST_MARKER();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//初始化队列中的列表xTasksWaitingToSend和xTasksWaitingToReceive</span></span><br><span class="line">			vListInitialise( &amp;( pxQueue-&gt;xTasksWaitingToSend ) );</span><br><span class="line">			vListInitialise( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	taskEXIT_CRITICAL(&amp;pxQueue-&gt;mux);</span><br><span class="line">	<span class="keyword">return</span> pdPASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="向队列发送消息"><a href="#向队列发送消息" class="headerlink" title="向队列发送消息"></a>向队列发送消息</h4><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xQueueSend</td>
<td>发送消息到消息队列的尾部（后向入队）</td>
</tr>
<tr>
<td>xQueueSendToBack</td>
<td>发送消息到消息队列的尾部（后向入队）</td>
</tr>
<tr>
<td>xQueueSendToFront</td>
<td>发送消息到队列头（前向入队）</td>
</tr>
<tr>
<td>xQueueOverwrite</td>
<td>发送消息到消息队列，带覆写功能；队列满了以后自动覆盖掉旧的消息；通常用于向那些长度为1的队列发送消息</td>
</tr>
<tr>
<td>xQueueSendFromISR</td>
<td>发送消息到消息队列的尾部（后向入队），用于中断服务函数</td>
</tr>
<tr>
<td>xQueueSendToBackFromISR</td>
<td>发送消息到消息队列的尾部（后向入队），用于中断服务函数</td>
</tr>
<tr>
<td>xQueueSendToFrontFromISR</td>
<td>发送消息到队列头（前向入队），用于中断服务函数</td>
</tr>
<tr>
<td>xQueueOverwriteFromISR</td>
<td>发送消息到消息队列，带覆写功能；队列满了以后自动覆盖掉旧的消息，用于中断服务函数</td>
</tr>
</tbody>
</table>
<h4 id="xQueueGenericSend函数"><a href="#xQueueGenericSend函数" class="headerlink" title="xQueueGenericSend函数"></a>xQueueGenericSend函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xQueueGenericSend</span><span class="params">( QueueHandle_t xQueue, <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">const</span> pvItemToQueue, TickType_t xTicksToWait, <span class="keyword">const</span> BaseType_t xCopyPosition )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;</span><br><span class="line">	TimeOut_t xTimeOut;</span><br><span class="line">	Queue_t * <span class="keyword">const</span> pxQueue = ( Queue_t * ) xQueue;</span><br><span class="line"></span><br><span class="line">	configASSERT( pxQueue );</span><br><span class="line">	configASSERT( !( ( pvItemToQueue == <span class="literal">NULL</span> ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="number">0U</span> ) ) );</span><br><span class="line">	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) &amp;&amp; ( pxQueue-&gt;uxLength != <span class="number">1</span> ) ) );</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span></span><br><span class="line">	&#123;</span><br><span class="line">		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != <span class="number">0</span> ) ) );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>( ;; )</span><br><span class="line">	&#123;</span><br><span class="line">		taskENTER_CRITICAL(&amp;pxQueue-&gt;mux);</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>( ( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength ) || ( xCopyPosition == queueOVERWRITE ) )<span class="comment">//当队列未满或者是覆写入队，则可以将消息入队</span></span><br><span class="line">			&#123;</span><br><span class="line">				traceQUEUE_SEND( pxQueue );</span><br><span class="line">				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );<span class="comment">//将消息复制到队列中</span></span><br><span class="line">				<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_QUEUE_SETS == 1 )</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>( pxQueue-&gt;pxQueueSetContainer != <span class="literal">NULL</span> )</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span>( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="comment">/* The queue is a member of a queue set, and posting</span></span><br><span class="line"><span class="comment">							to the queue set caused a higher priority task to</span></span><br><span class="line"><span class="comment">							unblock. A context switch is required. */</span></span><br><span class="line">							queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							mtCOVERAGE_TEST_MARKER();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdTRUE )</span><br><span class="line">							&#123;</span><br><span class="line">								queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">							&#123;</span><br><span class="line">								mtCOVERAGE_TEST_MARKER();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> <span class="keyword">if</span>( xYieldRequired != pdFALSE )</span><br><span class="line">						&#123;</span><br><span class="line">							queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							mtCOVERAGE_TEST_MARKER();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* configUSE_QUEUE_SETS */</span></span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )<span class="comment">//检查是否有任务由于请求队列消息而阻塞，阻塞的任务会挂在队列的xTasksWaitingToReceive列表上</span></span><br><span class="line">					&#123;</span><br><span class="line">                        <span class="comment">//将阻塞的任务从列表xTasksWaitingToReceive上移除，并且把这个任务添加到就序列表中。如果调度器上锁，则这些任务就会挂到列表xPendingReadyList上。如果取消阻塞的任务的优先级比当前正在运行的任务优先级高，则还要标记需要进行任务切换。当函数xTaskRemoveFromEventList返回值为pdTRUE时，需要进行任务切换</span></span><br><span class="line">						<span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdTRUE )</span><br><span class="line">						&#123;</span><br><span class="line">							queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							mtCOVERAGE_TEST_MARKER();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>( xYieldRequired != pdFALSE )</span><br><span class="line">					&#123;</span><br><span class="line">						queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						mtCOVERAGE_TEST_MARKER();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* configUSE_QUEUE_SETS */</span></span></span><br><span class="line">				taskEXIT_CRITICAL(&amp;pxQueue-&gt;mux);</span><br><span class="line">				<span class="keyword">return</span> pdPASS;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//队列已满，入队有阻碍</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>( xTicksToWait == ( TickType_t ) <span class="number">0</span> )<span class="comment">//没有设置阻塞时间或者等待时间已到</span></span><br><span class="line">				&#123;</span><br><span class="line">					taskEXIT_CRITICAL(&amp;pxQueue-&gt;mux);</span><br><span class="line">					traceQUEUE_SEND_FAILED( pxQueue );</span><br><span class="line">					<span class="keyword">return</span> errQUEUE_FULL;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>( xEntryTimeSet == pdFALSE )</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//设置超时时间结构体，记录当前系统始终节拍计数器的值xTickCount和溢出次数xNumOfOverflows</span></span><br><span class="line">					vTaskSetTimeOutState( &amp;xTimeOut );</span><br><span class="line">					xEntryTimeSet = pdTRUE;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					mtCOVERAGE_TEST_MARKER();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		taskEXIT_CRITICAL(&amp;pxQueue-&gt;mux);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代码执行到这里说明队列已满，而且设置了不为0的阻塞时间</span></span><br><span class="line">		taskENTER_CRITICAL(&amp;pxQueue-&gt;mux);</span><br><span class="line">		<span class="keyword">if</span>( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )<span class="comment">//更新xTimeOut，并检查阻塞时间是否到了</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>( prvIsQueueFull( pxQueue ) != pdFALSE )<span class="comment">//队列依旧是满的</span></span><br><span class="line">			&#123;</span><br><span class="line">				traceBLOCKING_ON_QUEUE_SEND( pxQueue );</span><br><span class="line">				vTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ), xTicksToWait );<span class="comment">//将任务添加到队列的xTasksWaitingToSend列表和延时列表中，并且将任务从就绪列表中移除</span></span><br><span class="line">				taskEXIT_CRITICAL(&amp;pxQueue-&gt;mux);</span><br><span class="line">				portYIELD_WITHIN_API();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//阻塞时间还没有到，但是队列现在有空闲，那么就重新执行一次本循环</span></span><br><span class="line">			&#123;</span><br><span class="line">				taskEXIT_CRITICAL(&amp;pxQueue-&gt;mux);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//需要阻塞的时间到了</span></span><br><span class="line">		&#123;</span><br><span class="line">			taskEXIT_CRITICAL(&amp;pxQueue-&gt;mux);</span><br><span class="line">			traceQUEUE_SEND_FAILED( pxQueue );</span><br><span class="line">			<span class="keyword">return</span> errQUEUE_FULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="从队列读取消息"><a href="#从队列读取消息" class="headerlink" title="从队列读取消息"></a>从队列读取消息</h4><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xQueueReceive</td>
<td>从队列中读取消息，然后从队列中将其删除</td>
</tr>
<tr>
<td>xQueuePeek</td>
<td>从队列中读取消息，不会将其从队列中删除</td>
</tr>
<tr>
<td>xQueueReceiveFromISR</td>
<td>从队列中读取消息，然后从队列中将其删除，用于中断服务函数中</td>
</tr>
<tr>
<td>xQueuePeekFromISR</td>
<td>从队列中读取消息，不会将其从队列中删除，用于中断服务函数中</td>
</tr>
</tbody>
</table>
<h2 id="FreeRTOS信号量"><a href="#FreeRTOS信号量" class="headerlink" title="FreeRTOS信号量"></a>FreeRTOS信号量</h2><h4 id="二值信号量和互斥信号量的差别"><a href="#二值信号量和互斥信号量的差别" class="headerlink" title="二值信号量和互斥信号量的差别"></a>二值信号量和互斥信号量的差别</h4><blockquote>
<ol>
<li>互斥信号量拥有<strong>优先级继承机制</strong>，而二值信号量没有优先级继承</li>
<li>二值信号量更适用于同步，而互斥信号量适用于简单的互斥访问</li>
</ol>
</blockquote>
<h4 id="二值信号量"><a href="#二值信号量" class="headerlink" title="二值信号量"></a>二值信号量</h4><blockquote>
<p>二值信号量其实就是只有一个队列项的队列，这个特殊的队列要么是满的，要么是空的，正好就是二值。任务和中断使用这个特殊队列的时候不用在乎队列中存在的是什么消息，只需要知道这个队列是满的还是空的即可，可以利用这个机制来完成任务和中断之间的同步。二值信号量使用的队列是没有存储区的，队列是否为空可以通过队列结构体的成员变量uxMessagesWaiting来判断。</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xSemaphoreCreateBinary</td>
<td>动态创建二值信号量，新创建的二值信号量默认是空的</td>
</tr>
<tr>
<td>xSemaphoreCreateBinaryStatic</td>
<td>静态创建二值信号量</td>
</tr>
<tr>
<td>xSemaphoreGive</td>
<td>任务级信号量释放函数，可用于释放二值信号量、计数型信号量和互斥信号量</td>
</tr>
<tr>
<td>xSemaphoreGiveFromISR</td>
<td>中断级信号量释放函数，只能用于释放二值信号量和计数型信号量，不能释放互斥信号量(因为互斥信号量需要处理 优先级继承的问题，而中断不属于任务)</td>
</tr>
<tr>
<td>xSemaphoreTake</td>
<td>任务级获取信号量函数，可用于获取二值信号量、计数型信号量和互斥信号量</td>
</tr>
<tr>
<td>xSemaphoreTakeFromISR</td>
<td>中断级获取信号量函数，只能用于获取二值信号量和计数型信号量，不能获取互斥信号量(因为互斥信号量需要处理 优先级继承的问题，而中断不属于任务)</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xSemaphoreCreateBinary() xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xSemaphoreGive( xSemaphore ) xQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xSemaphoreTake( xSemaphore, xBlockTime ) xQueueGenericReceive( ( QueueHandle_t ) ( xSemaphore ), NULL, ( xBlockTime ), pdFALSE )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xSemaphoreTakeFromISR( xSemaphore, pxHigherPriorityTaskWoken )	xQueueReceiveFromISR( ( QueueHandle_t ) ( xSemaphore ), NULL, ( pxHigherPriorityTaskWoken ) )</span></span><br></pre></td></tr></table></figure>
<h4 id="计数型信号量"><a href="#计数型信号量" class="headerlink" title="计数型信号量"></a>计数型信号量</h4><blockquote>
<p>计数型信号量就是长度为大于1的队列，只是无需关心队列中存储了什么数据，计数型信号量主要应用场合是：</p>
<ol>
<li><p>事件计数</p>
<p>每次事件发生的时候就在事件处理函数中释放信号量（增加信号量的计数值），其他任务会获取信号量来处理事件。在这种场合中，创建的计数型信号量初始计数值为0</p>
</li>
<li><p>资源管理</p>
<p>信号量值代表当前资源的可用数量，一个任务想要获得资源的使用权，首先必须获取信号量，成功以后信号量的值就会减1，当信号量值为0的时候就说明没有资源了。一个任务使用完资源以后一定要释放信号量，释放信号量以后信号量值会加1.在这种场合中，创建的计数型信号量初始值应该是资源的数量</p>
</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xSemaphoreCreateCoumting</td>
<td>使用动态方法创建计数型信号量</td>
</tr>
<tr>
<td>xSemaphoreCreateCountingStatic</td>
<td>使用静态方法创建计数型信号量</td>
</tr>
<tr>
<td>xSemaphoreGetCount</td>
<td>获取计数型信号量的值</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xSemaphoreCreateCounting( uxMaxCount, uxInitialCount ) xQueueCreateCountingSemaphore( ( uxMaxCount ), ( uxInitialCount ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xSemaphoreCreateCountingStatic( uxMaxCount, uxInitialCount, pxSemaphoreBuffer ) xQueueCreateCountingSemaphoreStatic( ( uxMaxCount ), ( uxInitialCount ), ( pxSemaphoreBuffer ) )</span></span><br><span class="line"><span class="function">QueueHandle_t <span class="title">xQueueCreateCountingSemaphore</span><span class="params">( <span class="keyword">const</span> UBaseType_t uxMaxCount, <span class="keyword">const</span> UBaseType_t uxInitialCount )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueueHandle_t xHandle;</span><br><span class="line"></span><br><span class="line">    configASSERT( uxMaxCount != <span class="number">0</span> );</span><br><span class="line">    configASSERT( uxInitialCount &lt;= uxMaxCount );</span><br><span class="line"></span><br><span class="line">    xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );<span class="comment">//queueSEMAPHORE_QUEUE_ITEM_LENGTH=0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( xHandle != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        ( ( Queue_t * ) xHandle )-&gt;uxMessagesWaiting = uxInitialCount;<span class="comment">//使用uxMessagesWaiting来计数</span></span><br><span class="line"></span><br><span class="line">        traceCREATE_COUNTING_SEMAPHORE();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        traceCREATE_COUNTING_SEMAPHORE_FAILED();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    configASSERT( xHandle );</span><br><span class="line">    <span class="keyword">return</span> xHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优先级翻转"><a href="#优先级翻转" class="headerlink" title="优先级翻转"></a>优先级翻转</h4><blockquote>
<p>使用二值信号量的时候会遇到常见的问题——优先级翻转，优先级翻转在可剥夺内核中是非常常见的，在实时系统中不允许出现这种现场，这样会破坏任务的预期顺序。</p>
<p>常见场合描述如下：</p>
<p>当一个低优先级和一个高优先级任务同时使用同一个信号量，而系统中还有其他中等优先级任务时，如果低 优先级任务获得了信号量，那么高优先级的任务就会处于等待状态；但是，中等优先级的任务可以打断低优先级任务而先于高优先级任务运行（此时高优先级的任务在等待信号量，所以不能运行），这就出现了优先级翻转的现象。</p>
</blockquote>
<h4 id="互斥信号量"><a href="#互斥信号量" class="headerlink" title="互斥信号量"></a>互斥信号量</h4><blockquote>
<p>互斥信号量其实就是一个拥有优先级继承的二值信号量，在同步的应用中，二值信号量最适合。互斥信号量适合用于那些需要互斥访问的应用中。当一个互斥信号量正在被一个低优先级的任务使用，而此时有个高优先级的任务也尝试获取这个互斥信号量的话就会被阻塞。不过这个高优先级的任务会将低优先级任务的优先级提升到与自己相同的优先级，这个过程就是优先级继承。优先级继承尽可能地降低了高优先级任务处于阻塞态的时间，并且将已经出现的“优先级翻转“的影响降到最低。</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xSemaphoreCreateMutex</td>
<td>使用动态方法创建互斥信号量</td>
</tr>
<tr>
<td>xSemaphoreCreateMutexStatic</td>
<td>使用静态方法创建互斥信号量</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xSemaphoreCreateMutex() xQueueCreateMutex( queueQUEUE_TYPE_MUTEX )</span></span><br><span class="line"><span class="function">QueueHandle_t <span class="title">xQueueCreateMutex</span><span class="params">( <span class="keyword">const</span> <span class="keyword">uint8_t</span> ucQueueType )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue_t *pxNewQueue;</span><br><span class="line">    <span class="keyword">const</span> UBaseType_t uxMutexLength = ( UBaseType_t ) <span class="number">1</span>, uxMutexSize = ( UBaseType_t ) <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );</span><br><span class="line">    prvInitialiseMutex( pxNewQueue );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pxNewQueue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prvInitialiseMutex</span><span class="params">( Queue_t *pxNewQueue )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( pxNewQueue != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        pxNewQueue-&gt;pxMutexHolder = <span class="literal">NULL</span>;</span><br><span class="line">        pxNewQueue-&gt;uxQueueType = queueQUEUE_IS_MUTEX;</span><br><span class="line">        pxNewQueue-&gt;u.uxRecursiveCallCount = <span class="number">0</span>;<span class="comment">//针对递归互斥信号量的计数器</span></span><br><span class="line">        vPortCPUInitializeMutex(&amp;pxNewQueue-&gt;mux);<span class="comment">//初始化CPU内核的自旋锁</span></span><br><span class="line">        traceCREATE_MUTEX( pxNewQueue );</span><br><span class="line">        ( <span class="keyword">void</span> ) xQueueGenericSend( pxNewQueue, <span class="literal">NULL</span>, ( TickType_t ) <span class="number">0U</span>, queueSEND_TO_BACK );<span class="comment">//互斥信号量默认创建后就是有效的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        traceCREATE_MUTEX_FAILED();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vPortCPUInitializeMutex</span><span class="params">(portMUX_TYPE *mux)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mux-&gt;owner=portMUX_FREE_VAL;</span><br><span class="line">	mux-&gt;count=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 为了处理多核CPU带来的竞态，使用该结构体实现的“自旋锁” */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* owner field values:</span></span><br><span class="line"><span class="comment">	 * 0                - Uninitialized (invalid)</span></span><br><span class="line"><span class="comment">	 * portMUX_FREE_VAL - Mux is free, can be locked by either CPU</span></span><br><span class="line"><span class="comment">	 * CORE_ID_PRO / CORE_ID_APP - Mux is locked to the particular core</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Any value other than portMUX_FREE_VAL, CORE_ID_PRO, CORE_ID_APP indicates corruption</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> owner;</span><br><span class="line">	<span class="comment">/* count field:</span></span><br><span class="line"><span class="comment">	 * If mux is unlocked, count should be zero.</span></span><br><span class="line"><span class="comment">	 * If mux is locked, count is non-zero &amp; represents the number of recursive locks on the mux.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FREERTOS_PORTMUX_DEBUG</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *lastLockedFn;</span><br><span class="line">	<span class="keyword">int</span> lastLockedLine;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; portMUX_TYPE;</span><br></pre></td></tr></table></figure>
<h4 id="递归互斥信号量"><a href="#递归互斥信号量" class="headerlink" title="递归互斥信号量"></a>递归互斥信号量</h4><blockquote>
<p>已经获取了互斥信号量的任务就不能再次获取这个互斥信号量，但是递归互斥信号量不同，已经获取了递归互斥信号量的任务可以再次获取这个递归互斥信号量，而且次数不限。递归互斥信号量也有优先级继承的机制，所以任务使用完递归互斥信号量以后一定要记得释放。</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xSemaphoreCreateRecursiveMutex</td>
<td>使用动态方法创建递归互斥信号量</td>
</tr>
<tr>
<td>xSemaphoreCreateRecursiveMutexStatic</td>
<td>使用静态方法创建递归互斥信号量</td>
</tr>
<tr>
<td>xSemaphoreGiveRecursive</td>
<td>释放递归互斥信号量</td>
</tr>
<tr>
<td>xSemaphoreTakeRecursive</td>
<td>获取递归互斥信号量</td>
</tr>
</tbody>
</table>
<h2 id="FreeRTOS软件定时器"><a href="#FreeRTOS软件定时器" class="headerlink" title="FreeRTOS软件定时器"></a>FreeRTOS软件定时器</h2><blockquote>
<p>软件定时器的回调函数是在定时器服务任务中执行的，所以一定不能在回调函数中调用任何会阻塞任务的API函数，比如定时器回调函数中千万不能调用vTaskDelay、vTaskDelayUntil，还有一些访问队列或者信号量的非零阻塞时间的API函数也不能调用。FreeRTOS提供了很多定时器相关的API函数，这些API函数大多使用FreeRTOS的队列发送命令给定时器服务任务，这个队列叫定时器命令队列，是供给FreeRTOS的软件定时器使用的，用户不能直接访问。</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xTimerReset()</td>
<td>复位软件定时器</td>
</tr>
<tr>
<td>xTimerResetFromISR()</td>
<td>复位软件定时器，用在中断服务函数中</td>
</tr>
<tr>
<td>xTimerCreate()</td>
<td>使用动态方法创建软件定时器</td>
</tr>
<tr>
<td>xTimerCreateStatic()</td>
<td>使用静态方法创建软件定时器</td>
</tr>
<tr>
<td>xTimerStart()</td>
<td>开启软件定时器，用于任务中</td>
</tr>
<tr>
<td>xTimerStartFromISR()</td>
<td>开启软件定时器，用于中断中</td>
</tr>
<tr>
<td>xTimerStop()</td>
<td>停止软件定时器，用于任务中</td>
</tr>
<tr>
<td>xTimerStopFromISR()</td>
<td>停止软件定时器，用于中断中</td>
</tr>
</tbody>
</table>
<h2 id="FreeRTOS事件标志组"><a href="#FreeRTOS事件标志组" class="headerlink" title="FreeRTOS事件标志组"></a>FreeRTOS事件标志组</h2><blockquote>
<p>使用信号量同步时任务只能与单个的事件或任务进行同步，有时候某个任务可能需要与多个事件或任务进行同步，此时信号量就无能为力了。FreeRTOS为此提供了一个可选的解决办法——事件标志组。事件标志组的数据类型为EventGroupHandle_t，当configUSE_16_BIT_TICKS为1的时候，则事件标志组可以存储8个事件位；当configUSE_16_BIT_TICKS为0的时候，则事件标志组存储24个事件位。事件标志组中的所有事件位都存储在一个无符号的EventBits_t类型的变量中</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xEventGroupCreate()</td>
<td>使用动态方法创建事件标志组</td>
</tr>
<tr>
<td>xEventGroupCreateStatic()</td>
<td>使用静态方法创建事件标志组</td>
</tr>
<tr>
<td>xEventGroupClearBits()</td>
<td>将指定的事件位清零，用在任务中</td>
</tr>
<tr>
<td>xEventGroupClearBitsFromISR()</td>
<td>将指定的事件位清零，用在中断服务函数中</td>
</tr>
<tr>
<td>xEventGroupSetBits()</td>
<td>将指定的事件位置1，用在任务中</td>
</tr>
<tr>
<td>xEventGroupSetBitsFromISR()</td>
<td>将指定的事件位置1，用在中断服务函数中</td>
</tr>
<tr>
<td>xEventGroupGetBits()</td>
<td>获取当前事件标志组的值（各个事件的值），用在任务中</td>
</tr>
<tr>
<td>xEventGroupGetBitsFromISR()</td>
<td>获取当前事件标志组的值，用在中断服务函数中</td>
</tr>
<tr>
<td>xEventGroupWaitBits()</td>
<td>等待指定的事件位</td>
</tr>
</tbody>
</table>
<h2 id="FreeRTOS任务通知"><a href="#FreeRTOS任务通知" class="headerlink" title="FreeRTOS任务通知"></a>FreeRTOS任务通知</h2><blockquote>
<p>FreeRTOS的每个任务都有一个32位的通知值，任务控制块中的成员变量ulNotifiedValue就是这个通知值。任务通知是一个事件，假如某个任务通知的接收任务因为等待任务通知而阻塞，则向这个接收任务发送任务通知以后就会解除这个任务的阻塞状态。也可以更新接收任务的任务通知值，可以通过以下方法更新接收任务的通知值：</p>
<ol>
<li>不覆盖接收任务的通知值（如果上次发送给接收任务的通知还没被处理）</li>
<li>覆盖接收任务的通知值</li>
<li>更新接收任务的通知值的一个或多个bit</li>
<li>增加接收任务的通知值</li>
</ol>
<p>合理使用上面这些更改任务通知值的方法可以在一些场合中替代队列、二值信号量、计数型信号量和事件标志组，并且可以提高速度，减少RAM的使用量。</p>
<p>任务通知的局限：</p>
<ul>
<li>FreeRTOS的任务通知只能有一个接收任务，其实大多数的应用都是这种情况</li>
<li>接收任务可以因为接收任务通知而进入阻塞态，但是发送任务不会因为任务通知发送失败而阻塞</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xTaskNotify</td>
<td>发送通知，带有通知值并且不保留接收任务原通知值，用在任务中</td>
</tr>
<tr>
<td>xTaskNotifyFromISR</td>
<td>发送通知，函数xTaskNotify的中断版本</td>
</tr>
<tr>
<td>xTaskNotifyGive</td>
<td>发送通知，不带通知值并且不保留接收任务的通知值，此函数会将接收任务的通知值加1，用于任务中</td>
</tr>
<tr>
<td>vTaskNotifyGiveFromISR</td>
<td>发送通知，函数xTaskNotifyGive的中断版本</td>
</tr>
<tr>
<td>xTaskNotifyAndQuery</td>
<td>发送通知，带有通知值并且保留接收任务的原通知值，用在任务中</td>
</tr>
<tr>
<td>xTaskNotifyAndQueryFromISR</td>
<td>发送通知，函数xTaskNotifyAndQuery的中断版本，用在中断服务函数中</td>
</tr>
<tr>
<td>ulTaskNotifyTake</td>
<td>获取任务通知，可以设置在退出此函数的时候将任务通知值清零或者减一。当任务通知用作二值信号量或者计数信号量的时候，使用此函数来获取信号量</td>
</tr>
<tr>
<td>xTaskNotifyWait</td>
<td>等待任务通知，比ulTaskNotifyTask更为强大，全功能版任务通知获取函数</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xTaskNotify</span><span class="params">( TaskHandle_t xTaskToNotify, <span class="keyword">uint32_t</span> ulValue, eNotifyAction eAction )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCB_t * pxTCB;</span><br><span class="line">    eNotifyValue eOriginalNotifyState;</span><br><span class="line">    BaseType_t xReturn = pdPASS;</span><br><span class="line">    configASSERT( xTaskToNotify );</span><br><span class="line">    pxTCB = ( TCB_t * ) xTaskToNotify;</span><br><span class="line">    taskENTER_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">    &#123;</span><br><span class="line">        eOriginalNotifyState = pxTCB-&gt;eNotifyState;<span class="comment">//保存当前任务通知状态</span></span><br><span class="line">        pxTCB-&gt;eNotifyState = eNotified;<span class="comment">//更新任务通知状态为eNotified</span></span><br><span class="line">        <span class="keyword">switch</span>( eAction )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> eSetBits:</span><br><span class="line">                pxTCB-&gt;ulNotifiedValue |= ulValue;<span class="comment">//更新接收任务通知值的一个或多个bit</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> eIncrement:</span><br><span class="line">                ( pxTCB-&gt;ulNotifiedValue )++;<span class="comment">//将任务通知值加1</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> eSetValueWithOverwrite:</span><br><span class="line">                pxTCB-&gt;ulNotifiedValue = ulValue;<span class="comment">//直接覆写原来的任务通知值</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> eSetValueWithoutOverwrite:</span><br><span class="line">                <span class="keyword">if</span>( eOriginalNotifyState != eNotified )<span class="comment">//原来的任务通知已经被处理</span></span><br><span class="line">                &#123;</span><br><span class="line">                    pxTCB-&gt;ulNotifiedValue = ulValue;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//原来的任务通知没有被处理</span></span><br><span class="line">                &#123;</span><br><span class="line">                    xReturn = pdFAIL;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> eNoAction:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//判断任务是否因为等待任务通知值而进入了阻塞态</span></span><br><span class="line">        <span class="keyword">if</span>( eOriginalNotifyState == eWaitingNotification )</span><br><span class="line">        &#123;</span><br><span class="line">            ( <span class="keyword">void</span> ) uxListRemove( &amp;( pxTCB-&gt;xGenericListItem ) );<span class="comment">//将任务从状态列表中移除</span></span><br><span class="line">            prvAddTaskToReadyList( pxTCB );<span class="comment">//将任务重新添加到就绪列表</span></span><br><span class="line">            configASSERT( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) == <span class="literal">NULL</span> );</span><br><span class="line">            <span class="keyword">if</span>( tskCAN_RUN_HERE(pxTCB-&gt;xCoreID) &amp;&amp; pxTCB-&gt;uxPriority &gt; pxCurrentTCB[ xPortGetCoreID() ]-&gt;uxPriority )<span class="comment">//判断刚刚解除阻塞的任务优先级是否比当前正在运行的任务优先级高</span></span><br><span class="line">            &#123;</span><br><span class="line">                portYIELD_WITHIN_API();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( pxTCB-&gt;xCoreID != xPortGetCoreID() )</span><br><span class="line">            &#123;</span><br><span class="line">                taskYIELD_OTHER_CORE(pxTCB-&gt;xCoreID, pxTCB-&gt;uxPriority);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    taskEXIT_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xReturn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uint32_t</span> ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )</span><br><span class="line">&#123;</span><br><span class="line">    TickType_t xTimeToWake;</span><br><span class="line">    <span class="keyword">uint32_t</span> ulReturn;</span><br><span class="line">    taskENTER_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( pxCurrentTCB[ xPortGetCoreID() ]-&gt;ulNotifiedValue == <span class="number">0U</span>L )<span class="comment">//还没有接收到任务通知</span></span><br><span class="line">        &#123;</span><br><span class="line">            pxCurrentTCB[ xPortGetCoreID() ]-&gt;eNotifyState = eWaitingNotification;<span class="comment">//任务通知状态改为eWaitingNotification</span></span><br><span class="line">            <span class="keyword">if</span>( xTicksToWait &gt; ( TickType_t ) <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//将任务添加到延时列表，并进行任务调度</span></span><br><span class="line">                <span class="keyword">if</span>( uxListRemove( &amp;( pxCurrentTCB[ xPortGetCoreID() ]-&gt;xGenericListItem ) ) == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    portRESET_READY_PRIORITY( pxCurrentTCB[ xPortGetCoreID() ]-&gt;uxPriority, uxTopReadyPriority );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">if</span> ( INCLUDE_vTaskSuspend == 1 )</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( xTicksToWait == portMAX_DELAY )</span><br><span class="line">                    &#123;</span><br><span class="line">                        traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);</span><br><span class="line">                        vListInsertEnd( &amp;xSuspendedTaskList, &amp;( pxCurrentTCB[ xPortGetCoreID() ]-&gt;xGenericListItem ) );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        xTimeToWake = xTickCount + xTicksToWait;</span><br><span class="line">                        prvAddCurrentTaskToDelayedList( xPortGetCoreID(), xTimeToWake );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* INCLUDE_vTaskSuspend */</span></span></span><br><span class="line">                &#123;</span><br><span class="line">                    xTimeToWake = xTickCount + xTicksToWait;</span><br><span class="line">                    prvAddCurrentTaskToDelayedList( xTimeToWake );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* INCLUDE_vTaskSuspend */</span></span></span><br><span class="line">                portYIELD_WITHIN_API();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    taskEXIT_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">    taskENTER_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">    &#123;</span><br><span class="line">        ulReturn = pxCurrentTCB[ xPortGetCoreID() ]-&gt;ulNotifiedValue;<span class="comment">//任务通知值不为0，则先获取任务通知值</span></span><br><span class="line">        <span class="keyword">if</span>( ulReturn != <span class="number">0U</span>L )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( xClearCountOnExit != pdFALSE )</span><br><span class="line">            &#123;</span><br><span class="line">                pxCurrentTCB[ xPortGetCoreID() ]-&gt;ulNotifiedValue = <span class="number">0U</span>L;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ( pxCurrentTCB[ xPortGetCoreID() ]-&gt;ulNotifiedValue )--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">        pxCurrentTCB[ xPortGetCoreID() ]-&gt;eNotifyState = eNotWaitingNotification;<span class="comment">//更新任务通知状态为eNotWaitingNotification</span></span><br><span class="line">    &#125;</span><br><span class="line">    taskEXIT_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">    <span class="keyword">return</span> ulReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FreeRTOS中的空闲任务"><a href="#FreeRTOS中的空闲任务" class="headerlink" title="FreeRTOS中的空闲任务"></a>FreeRTOS中的空闲任务</h2><blockquote>
<p>空闲任务不仅仅是为了满足任务调度器启动以后至少有一个任务运行而创建的，空闲任务中还会去做一些其他的事情，如下：</p>
<ol>
<li>判断系统中是否有任务删除自己，如果有，则在空闲任务中释放被删除任务的任务堆栈和任务控制块的内存</li>
<li>运行用户设置的空闲任务钩子函数</li>
<li>判断是否开启低功耗tickless模式，如果开启，则还需要做相应的处理</li>
</ol>
<p>用户可以创建与空闲任务优先级相同的应用任务，当宏configIDLE_SHOULD_YIELD为1时，空闲任务会让出时间片给相同优先级的应用任务。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">portTASK_FUNCTION</span><span class="params">( prvIdleTask, pvParameters )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	( <span class="keyword">void</span> ) pvParameters;</span><br><span class="line">	<span class="keyword">for</span>( ;; )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//检查是否有任务要删除自己，如果有，则释放这些任务的任务控制块TCP和任务堆栈的内存</span></span><br><span class="line">		prvCheckTasksWaitingTermination();</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_PREEMPTION == 0 )</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果没有使用抢占式内核，则强制执行一次任务切换，查看是否有其他任务有效；如果有使用抢占式内核，则不需要这一步，因为只要有任何任务就绪，之后都会自动抢夺CPU使用权</span></span><br><span class="line">			taskYIELD();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* configUSE_PREEMPTION */</span></span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">if</span> ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configIDLE_SHOULD_YIELD == 1 ) )</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果使用抢占式内核并且使能时间片调度，则当有任务和空闲任务共享一个优先级，并且此任务处于就绪态时，空闲任务就应该放弃本时间片，将本时间片剩余的时间让给这个就绪任务。</span></span><br><span class="line">			<span class="keyword">if</span>( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) &gt; ( UBaseType_t ) <span class="number">1</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				taskYIELD();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				mtCOVERAGE_TEST_MARKER();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configIDLE_SHOULD_YIELD == 1 ) ) */</span></span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_IDLE_HOOK == 1 )</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">vApplicationIdleHook</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">			<span class="comment">//执行用户定义的空闲任务钩子函数，注意钩子函数里面不能使用任何可以引起阻塞空闲任务的API函数</span></span><br><span class="line">			vApplicationIdleHook();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* configUSE_IDLE_HOOK */</span></span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* Call the esp-idf hook system */</span></span><br><span class="line">			esp_vApplicationIdleHook();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果使能了Tickless模式，则执行相关的处理代码</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_TICKLESS_IDLE != 0 )</span></span><br><span class="line">		&#123;</span><br><span class="line">			TickType_t xExpectedIdleTime;</span><br><span class="line">			BaseType_t xEnteredSleep = pdFALSE;</span><br><span class="line">			<span class="comment">//获取处理器进入低功耗模式的时长</span></span><br><span class="line">			xExpectedIdleTime = prvGetExpectedIdleTime();</span><br><span class="line">			<span class="keyword">if</span>( xExpectedIdleTime &gt;= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )</span><br><span class="line">			&#123;</span><br><span class="line">				taskENTER_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//重新采集一次时间值</span></span><br><span class="line">					configASSERT( xNextTaskUnblockTime &gt;= xTickCount );</span><br><span class="line">					xExpectedIdleTime = prvGetExpectedIdleTime();</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span>( xExpectedIdleTime &gt;= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )</span><br><span class="line">					&#123;</span><br><span class="line">						traceLOW_POWER_IDLE_BEGIN();</span><br><span class="line">						xEnteredSleep = portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );<span class="comment">//FreeRTOS进入低功耗Tickless模式</span></span><br><span class="line">						traceLOW_POWER_IDLE_END();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						mtCOVERAGE_TEST_MARKER();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				taskEXIT_CRITICAL(&amp;xTaskQueueMutex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				mtCOVERAGE_TEST_MARKER();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ( !xEnteredSleep )<span class="comment">//FreeRTOS没有真的进入Tickless模式</span></span><br><span class="line">			&#123;</span><br><span class="line">				esp_vApplicationWaitiHook();<span class="comment">//CPU进入低功耗模式</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		esp_vApplicationWaitiHook();</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* configUSE_TICKLESS_IDLE */</span></span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FreeRTOS低功耗Tickless模式"><a href="#FreeRTOS低功耗Tickless模式" class="headerlink" title="FreeRTOS低功耗Tickless模式"></a>FreeRTOS低功耗Tickless模式</h2><blockquote>
<p>当处理器进入空闲任务周期以后就会关闭系统节拍中断（滴答定时器中断），只有其他中断发生或者其他任务需要处理的时候，处理器才会被从低功耗模式中唤醒。为此将会面临两大问题：</p>
<ol>
<li>关闭系统节拍中断会导致系统节拍计数器停止，系统时钟就会停止。<ul>
<li>我们需要记录下系统节拍中断的关闭时间，当系统节拍中断再次开启运行的时候补上这段时间即可，这时候就需要使用定时器来记录这段该补上的时间</li>
</ul>
</li>
<li>如何保证下一个要运行的任务能被准确地唤醒？<ul>
<li>处理器在进入低功耗模式之前获取还有多长时间运行下一个任务，开启定时器，定时周期设置为这个时间，定时时间到了则产生定时中断，处理器就从低功耗模式唤醒了</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="Tickless的具体实现"><a href="#Tickless的具体实现" class="headerlink" title="Tickless的具体实现"></a>Tickless的具体实现</h4><ol>
<li>要想使用Tickless模式，则必须首先将FreeRTOSConfig.h中的宏configUSE_TICKLESS_IDLE设置为1</li>
<li>使能Tickless模式以后，当下面两种情况都出现的时候，FreeRTOS内核就会调用宏portSUPPRESS_TICKS_AND_SLEEP来处理低功耗相关的工作:<ul>
<li>空闲任务是当前唯一可运行的任务，因为其他所有的任务都处于阻塞或者挂起态</li>
<li>系统处于低功耗模式的时间至少大于configEXPECTED_IDLE_TIME_BEFORE_SLEEP个时钟节拍</li>
</ul>
</li>
<li>处理器工作在低功耗模式的时间虽说没有任何限制，一个时钟节拍也行、滴答定时器所能计时的最大值也行，但是时间太短意义也不大，所以必须对工作在低功耗模式的时间做个限制，不能太短了，宏config EXPECTED_IDLE_TIME_BEFORE_SLEEP就是用来实现这个功能的</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> portSUPPRESS_TICKS_AND_SLEEP( idleTime ) vApplicationSleep( idleTime )</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> IRAM_ATTR <span class="title">vApplicationSleep</span><span class="params">( TickType_t xExpectedIdleTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    portENTER_CRITICAL(&amp;s_switch_lock);</span><br><span class="line">    <span class="keyword">if</span> (s_mode == PM_MODE_LIGHT_SLEEP &amp;&amp; !s_is_switching) &#123;</span><br><span class="line">        <span class="comment">//计算可以睡眠的时长</span></span><br><span class="line">        <span class="keyword">int64_t</span> next_esp_timer_alarm = esp_timer_get_next_alarm();</span><br><span class="line">        <span class="keyword">int64_t</span> now = esp_timer_get_time();</span><br><span class="line">        <span class="keyword">int64_t</span> time_until_next_alarm = next_esp_timer_alarm - now;</span><br><span class="line">        <span class="keyword">int64_t</span> wakeup_delay_us = portTICK_PERIOD_MS * <span class="number">1000L</span>L * xExpectedIdleTime;</span><br><span class="line">        <span class="keyword">int64_t</span> sleep_time_us = MIN(wakeup_delay_us, time_until_next_alarm);</span><br><span class="line">        <span class="keyword">if</span> (sleep_time_us &gt;= configEXPECTED_IDLE_TIME_BEFORE_SLEEP * portTICK_PERIOD_MS * <span class="number">1000L</span>L) &#123;</span><br><span class="line">            esp_sleep_enable_timer_wakeup(sleep_time_us - LIGHT_SLEEP_EARLY_WAKEUP_US);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM_TRACE</span></span><br><span class="line">            <span class="comment">/* to force tracing GPIOs to keep state */</span></span><br><span class="line">            esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_ON);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">int</span> core_id = xPortGetCoreID();</span><br><span class="line">            ESP_PM_TRACE_ENTER(SLEEP, core_id);</span><br><span class="line">            <span class="keyword">int64_t</span> sleep_start = esp_timer_get_time();</span><br><span class="line">            esp_light_sleep_start();<span class="comment">//开始睡眠</span></span><br><span class="line">            <span class="keyword">int64_t</span> slept_us = esp_timer_get_time() - sleep_start;</span><br><span class="line">            ESP_PM_TRACE_EXIT(SLEEP, core_id);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint32_t</span> slept_ticks = slept_us / (portTICK_PERIOD_MS * <span class="number">1000L</span>L);</span><br><span class="line">            <span class="keyword">if</span> (slept_ticks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//根据实际休眠的时间来调整系统滴答计数器的值</span></span><br><span class="line">                vTaskStepTick(slept_ticks);</span><br><span class="line">                <span class="comment">//触发tick中断</span></span><br><span class="line">                XTHAL_SET_CCOUNT(XTHAL_GET_CCOMPARE(XT_TIMER_INDEX) - <span class="number">16</span>);</span><br><span class="line">                <span class="keyword">while</span> (!(XTHAL_GET_INTERRUPT() &amp; BIT(XT_TIMER_INTNUM))) &#123;</span><br><span class="line">                    ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    portEXIT_CRITICAL(&amp;s_switch_lock);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-07-19T07:36:39.532Z" itemprop="dateUpdated">2018-07-19 15:36:39</time>
</span><br>


        
        <a href="/2018/05/30/freertos-introduce/" target="_blank" rel="external">https://suda-morris.github.io/2018/05/30/freertos-introduce/</a>
        
    </div>
    
    <footer>
        <a href="https://suda-morris.github.io">
            <img src="/img/avatar.jpg" alt="suda-morris">
            suda-morris
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FreeRTOS/">FreeRTOS</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://suda-morris.github.io/2018/05/30/freertos-introduce/&title=《FreeRTOS Introduction---Based on ESP32》 — suda-morris's Personal Blog&pic=https://suda-morris.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://suda-morris.github.io/2018/05/30/freertos-introduce/&title=《FreeRTOS Introduction---Based on ESP32》 — suda-morris's Personal Blog&source=茅小泰的个人博客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://suda-morris.github.io/2018/05/30/freertos-introduce/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《FreeRTOS Introduction---Based on ESP32》 — suda-morris's Personal Blog&url=https://suda-morris.github.io/2018/05/30/freertos-introduce/&via=https://suda-morris.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://suda-morris.github.io/2018/05/30/freertos-introduce/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/07/05/esp32-spi/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">esp32-spi</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/07/01/learn-altium-designer/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Learn Altium Designer</h4>
      </a>
    </div>
  
</nav>



    








<section class="comments" id="comments">
    <div id="gitment_thread"></div>
    <link rel="stylesheet" href="//unpkg.com/gitment/style/default.css">
    <script src="//unpkg.com/gitment/dist/gitment.browser.js"></script>
    <script>
        var gitment = new Gitment({
            id: 'Wed May 30 2018 20:56:00 GMT+0800',
            owner: 'suda-morris',
            repo: 'suda-morris.github.io',
            oauth: {
                client_id: 'c57bf626196975c975bd',
                client_secret: '2d6206807459e263b680e92344b96bc324ac4157',
            },
        })
        gitment.render('comments')
    </script>
</section>










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>suda-morris &copy; 2015 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://suda-morris.github.io/2018/05/30/freertos-introduce/&title=《FreeRTOS Introduction---Based on ESP32》 — suda-morris's Personal Blog&pic=https://suda-morris.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://suda-morris.github.io/2018/05/30/freertos-introduce/&title=《FreeRTOS Introduction---Based on ESP32》 — suda-morris's Personal Blog&source=茅小泰的个人博客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://suda-morris.github.io/2018/05/30/freertos-introduce/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《FreeRTOS Introduction---Based on ESP32》 — suda-morris's Personal Blog&url=https://suda-morris.github.io/2018/05/30/freertos-introduce/&via=https://suda-morris.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://suda-morris.github.io/2018/05/30/freertos-introduce/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACE0lEQVR42u3aS5KDMAwFQO5/6cwBpop5kiBTtturFAFCs1Csz3XF63O7kjPv7/z72uuNhYGBsSwjecTk2/z++Tn568PAwDiBkYTC/KocmTDunw0DAwMj+XwfKKs8DAwMjKcYOTIP2f8QcDEwMJZiVNPUvDSWFNS+motjYGAsyMir7t///Ep/AwMDYynGp7h6ATpvZPYWBgbG3oynCvd5Aa6aBifPg4GBgTEvriVjFtUjV1SBw8DA2JmRFMW+uQWMfgsDA+MYRpKsRhu1Fqz3Z4CBgXEOY7IFnIfLJA3+41sMDIxNGUmYm4fRSfoa3Q0DA+MYxlPpaLWpMH+hGBgYJzCiU4sNy/wOk3E0DAyM0xjz0Jm8giSJTbakf2ThGBgYWzOSbd9TKe78OAYGxgmMapJZHeHqDYfl4bvZ38DAwFiQkZz61PFqE7Q3ooGBgbEfo5eU3t+0t92cJNIYGBgnM5IhrWoS+8qmEAMD40hGueA1SGsfKPZhYGAcwJiU2PIwnSPLTVMMDIwDGPkWsDdCUQVU258YGBi7Mj7F1Us1e68mCdYYGBgnMPJ1/yjV9mQ+BNYb3cDAwNiP0Us+J0lsPkiRUDEwMM5h5IFv0nrMWxFlJAYGBkZrwGvy0OWrMDAwMOJyfx4i83y63InFwMDYlDEPo8nARN4GeLHchoGBsSCjN+JQLdIlTc3k10dNTQwMjPUYP4Lb8C7kK3AMAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
