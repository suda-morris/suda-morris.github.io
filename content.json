[{"title":"Vue","date":"2019-01-05T15:10:00.000Z","path":"2019/01/05/vue/","text":"数据绑定Vue在设计上使用MVVM模式，当View发生变化时会自动更新到ViewModel，反之亦然。View和ViewModel之间通过双向绑定建立联系。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 使用自定义过滤器对数据进行过滤 --&gt; &lt;h1&gt;&#123;&#123;date_time | formatDateTime&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;input type=&quot;text&quot; v-model=&quot;name&quot; placeholder=&quot;你的名字&quot;&gt; &lt;!-- 使用 v-pre 即可跳过这个元素和它的子元素的编译过程 --&gt; &lt;h3 v-pre&gt;&#123;&#123;这里的内容是不会被编译的&#125;&#125;&lt;/h3&gt; &lt;!-- 除了简单的绑定属性值外，还可以使用 JavaScript 表达式进行简单的运算、三元运算 --&gt; &lt;h3&gt;&#123;&#123;isDone?&quot;Done&quot;:&quot;Not Done&quot;&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;app&quot;, data: function() &#123; return &#123; name: &quot;Hello esp-desk&quot;, isDone: true, date_time: new Date() &#125;; &#125;, filters: &#123; formatDateTime: function(value) &#123; var date = new Date(value); var year = date.getFullYear(); var month = date.getMonth() + 1; var day = date.getDate(); var hours = date.getHours(); var minutes = date.getMinutes(); var seconds = date.getSeconds(); return ( year + &quot;-&quot; + month + &quot;-&quot; + day + &quot; &quot; + hours + &quot;:&quot; + minutes + &quot;:&quot; + seconds ); &#125; &#125;, created: function() &#123; // 实例创建完成后调用，此阶段完成了数据的观测等，但尚未挂载， 此时 $el 还不可用。需要初始化处理一些数据时会比较有用 console.log(this.name); &#125;, mounted: function() &#123; //el 挂载到实例上后调用，一般第一个业务逻辑会在这里开始 console.log(this.$el); var _this = this; //声明一个变量指向 Vue 实例 this ，保证作用域一致 this.timer = setInterval(() =&gt; &#123; _this.date_time = new Date(); &#125;, 1000); &#125;, beforeDestroy: function() &#123; //实例销毁之前调用。主要解绑一些使用 addEventListener 监听的事件等 console.log(&quot;beforeDestory&quot;); if (this.timer) &#123; clearInterval(this.timer); &#125; &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt; 计算属性模板内的表达式只能用于简单的运算，逻辑复杂时，使用vue实例的计算属性computed。计算属性可以完成各种复杂的逻辑，包括运算、函数调用等。计算属性还可以依赖多个vue实例的数据，只要其中任一数据有变化，计算属性就会重新执行。 计算属性与methods的主要区别在于，计算属性是基于它的依赖缓存的，只有当依赖的数据发生变化时才会执行计算。 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;reverseText&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;app&quot;, data() &#123; return &#123; text: &quot;192.168.10.11&quot; &#125;; &#125;, computed: &#123; reverseText: function() &#123; return this.text .split(&quot;.&quot;) .reverse() .join(&quot;.&quot;); &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; Vue指令v-bind及其语法糖123456789101112131415161718192021&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img :src=&quot;imgUrl&quot;&gt; &lt;a v-bind:href=&quot;url&quot;&gt;百度&lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;app&quot;, data: function() &#123; return &#123; url: &quot;https://www.baidu.com&quot;, imgUrl: &quot;https://s2.ax1x.com/2019/01/06/FHVUR1.jpg&quot; &#125;; &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt; 绑定class给v-bind:class设置一个对象，可以动态切换class 123&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;static&quot; :class=&quot;&#123;&apos;active&apos;:isActive, &apos;error&apos;:isError&#125;&quot;&gt;&lt;/div&gt;&lt;/div&gt; 类名active依赖于数据isActive，当其为true时，div会拥有类名Active，为false时则没有 :class可以与普通class共存 当:class的表达式过长或者逻辑复杂时，还可以绑定计算属性 给v-bind:class设置一个数组，应用一个class列表 123456789101112&lt;div id=&quot;app&quot;&gt; &lt;div :class=&quot;[&#123;&apos;active&apos;: isActive&#125;, errorCls]&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isActive: true, errorCls: &apos;error&apos; &#125; &#125;)&lt;/script&gt; 绑定style1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;div :style=&quot;styles&quot;&gt;文本&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; styles: &#123; color: &apos;red&apos;, fontSize: 14 + &apos;px&apos; &#125; &#125; &#125;)&lt;/script&gt; v-on及其语法糖1234567891011121314151617181920212223242526&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2 v-if=&quot;show&quot;&gt;这是一段文字&lt;/h2&gt; &lt;button v-on:click=&quot;hideLabel&quot;&gt;隐藏文字&lt;/button&gt; &lt;button @click=&quot;showLabel&quot;&gt;显示文字&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;app&quot;, data: function() &#123; return &#123; show: true &#125;; &#125;, methods: &#123; hideLabel: function() &#123; this.show = false; &#125;, showLabel: function() &#123; this.show = true; &#125; &#125;&#125;;&lt;/script&gt; v-oncev-once是一个不需要表达式的指令，作用是定义它的元素或组件只渲染一次，包括元素或组件的所有子节点。首次渲染后，不再随数据的变化重新渲染，将被视为静态内容。v-once在业务中很少使用，当需要进一步优化性能的时候，可能会用到。 v-if、v-else-if、v-else条件渲染指令123456789101112131415161718192021222324&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;template v-if=&quot;status===1&quot;&gt; &lt;h2&gt;status:1&lt;/h2&gt; &lt;/template&gt; &lt;template v-else-if=&quot;status===2&quot;&gt; &lt;h3&gt;status:2&lt;/h3&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;h4&gt;status:3&lt;/h4&gt; &lt;/template&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;app&quot;, data() &#123; return &#123; status: 3 &#125;; &#125;&#125;;&lt;/script&gt; Vue在渲染元素时，处于效率考虑，会尽可能复用已有的元素而非重新渲染。如果不希望这样做，可以使用Vue提供的key属性，它可以让你自己决定是否要复用元素，key的值必须是唯一的 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;template v-if=&quot;type===&apos;name&apos;&quot;&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder=&quot;输入用户名&quot; :key=&quot;name-input&quot;&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;label&gt;邮箱：&lt;/label&gt; &lt;input placeholder=&quot;输入邮箱&quot; :key=&quot;mail-input&quot;&gt; &lt;/template&gt; &lt;button @click=&quot;changeType&quot;&gt;切换输入类型&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;app&quot;, data() &#123; return &#123; type: &quot;name&quot; &#125;; &#125;, methods: &#123; changeType: function() &#123; this.type = this.type === &quot;name&quot; ? &quot;email&quot; : &quot;name&quot;; &#125; &#125;&#125;;&lt;/script&gt; v-showv-show的用法与v-if基本一致，只不过v-show是改变元素的CSS属性display，当v-show表达式的值为false时，元素会隐藏，查看DOM结构会看到元素上加载了内联样式display:none 12345678910111213141516&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;p v-show=&quot;status===1&quot;&gt;当status为1时显示该行&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;app&quot;, data() &#123; return &#123; status: 1 &#125;; &#125;&#125;;&lt;/script&gt; v-show只是简单的CSS属性切换，无论条件真与否，都会被编译，相比之下，v-if更适合条件不经常改变的场景，因为它切换开销相对较大，而v-show适用于频繁切换条件 v-show不能在\\&lt;template>上使用 列表渲染指令 v-for","tags":[{"name":"Vue","slug":"Vue","permalink":"https://suda-morris.github.io/tags/Vue/"}]},{"title":"Xtensa Assembly","date":"2019-01-04T08:08:00.000Z","path":"2019/01/04/xtensa-assembly/","text":"Xtensa 微处理器介绍Xtensa使用的指令集架构属于类RISC架构，主要针对嵌入式应用场合。在移植/编写操作系统的时候需要额外注意以下几点： 不同的指令其宽度可能不同 window寄存器的使用 处理器的可配置性 处理器的扩展性（指令集可扩展） Xtensa 硬件抽象层HAL编译时HAL——CHAL包括C语言预处理器和汇编语言的宏定义（用来表征不同xtensa处理器的不同配置） 链接时HAL——LHAL 给操作系统移植层调用 给底层软件（需要处理ISA相关的功能）调用，例如提供保存现场window frame的接口 窗寄存器函数调用规范(Windowed Calling Convention)现代处理器为了更好的支持高级编程语言的高效编译，通常处理器所拥有的通用寄存器的数目有16个甚至32个之多，如此多的寄存器在比较复杂的应用程序上实现深度嵌套调用的时候，为了保证程序的正确执行，寄存器要频繁地进行入栈和出栈的操作，这样频繁的堆栈memory的访问将明显恶化应用程序的性能。为了有效解决这一问题，Xtensa架构设计了一种Windows旋转方式的寄存器管理机制，将逻辑寄存器和物理寄存器分开，在函数调用的时候通过windows滑动切换逻辑寄存器，从而避免寄存器覆盖，减少压栈和出栈的操作。 AR物理寄存器环形Buffer AR物理寄存器环形buffer 基本实现原理：使用更多的物理AR寄存器组成一个环形的buffer。这些寄存器每4个为一组（pane），WindowStart中的每个比特依次表示该组是否作为逻辑寄存器窗口的起始位置或者被占用。当前的逻辑寄存器的起始位置则用WindowBase状态寄存器来表示。在发生函数调用的时候是通过修改WindowBase寄存器，滑动逻辑寄存器窗口，从而父子函数看到的是不同的物理寄存器，避免了寄存器的压栈和出栈。 以每4个寄存器（pane）为单位，函数调用的时候窗口可以滑动4个，8个或者12个物理寄存器，分别可以用call4,call8,call12指令来实现，而最典型的应用则为call8。 call8 Windows ABI调用规范 a0用来保存函数返回地址 a1保存sp堆栈指针 a2～a7用来传递函数入参，参数超过6个的时候则需要使用堆栈 对调用者函数和被调用函数来说，a0~a7是独立的寄存器，可以自由使用，而a8~a15则为scratch寄存器，随时会被子函数使用，调用者函数如果要使用，则在调用子函数前进行压栈保存 为了方便寄存器正常的保存与恢复，还要调用栈的高效回溯，还有必要对函数的Frame栈空间做统一的安排。 Window ABI 堆栈布局 Base Area用于存储其父函数的基本寄存器a0~a3 Windows寄存器覆盖问题在发生函数调用，执行call指令的时候，窗递增值（call4，call8，call12分别对应1,2,3）存入PS处理器状态寄存器的CALLINC域，在进入函数的入口处用entry指令进行Window重叠检测，条件满足的时候将触发相应的windows overflow异常，引导程序进行覆盖寄存器的入栈保护。 Windows寄存器underflow问题当子函数返回时，RETW或者RETW.N指令执行，此时也仅此时处理器将进行上溢检查。如果当Windowbase所在的位置的前3个windows pane的WindowStart比特都为0，则意味着它返回后的父函数发生过WindowOverflow，父函数的窗口寄存器曾经被压入stack。如果不是全为0，则应该不为零0的点和正常window返回的点对应，就返回，如果不同，则说明发生了不正常的调用，a0被破坏掉了，要产生非法指令错误。 参数传递前6个参数会传递给 AR 寄存器，剩余的参数会被保存在stack中。 对于callN指令（N取值4,8或者12）来说，函数调用者会将参数保存到寄存器AR[N+2]到AR[N+7]中（特别注意，call12指令是能用于调用只有两个或者更少参数的函数，只能使用AR[N+2]和AR[N+3]寄存器），函数被调用者会从寄存器AR[2]到AR[7]中接收这些参数。 如果参数的数量多于6个，剩下的参数就会被保存在函数调用者的堆栈，即第七个参数保存在[sp+0]处，第八个参数保存在[sp+4]处，依此类推。函数被调用者需要从内存的[sp+FRAMESIZE]处获取这些额外的参数，其中FRAMESIZE是被调用者的stack frame大小，通常会用entry指令指定。 以下C程序代码 1234567int func( int a, int b, int c, int d, int e, int f, int g, int h, int i )&#123; int j; j = a + b + c + d + e + f + g + h + i; return j;&#125; 对应的汇编程序代码为 12345678910111213141516171819.align 4 .global funcfunc: .frame a1, 32.LBB1_func: entry a1,32 // 此函数的 FRAMESIZE 是32字节 l32i.n a10,a1,40.LBB2_func: l32i.n a8,a1,32 add.n a12,a5,a6 add.n a11,a2,a3 l32i.n a2,a1,36 add.n a11,a4,a11 add.n a11,a11,a12 add.n a8,a8,a7 add.n a2,a2,a10 add.n a8,a8,a11 add.n a2,a2,a8 //返回值如果不超过4字节，就会被保存在 a2 寄存器中 retw.n 函数调用和返回编写Xtensa汇编代码部分底层驱动只能使用汇编语言编写，比如： 用户异常处理 内核异常处理 window处理 复位处理 使用汇编实现16比特点积运算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;dsls_dotprod_16s_m_ae32.S&quot;#include &quot;dsl_err_codes.h&quot; .text //保存在代码段 .align 4 // 与PC有关的跳转指令需要目标地址4字节对齐 .global dsls_dotprod_16s_ae32 // 声明该函数全局可访问 .type dsls_dotprod_16s_ae32,@function // 声明符号是函数类型（方便调试器更好地展示信息）// 良好的习惯是在汇编函数开始前，注释其C语言原型// esp_err_t dsls_dotprod_16s_ae32(int16_t* src1, int16_t* src2, int16_t* dest, int len, int8_t shift);dsls_dotprod_16s_ae32: // src1 - a2// src2 - a3// dest - a4// len - a5// shift - a6 entry a1, 32 // 每个函数都以一条entry指令开头，这是window寄存器调用规范所要求的 // Check minimum length movi a8, 4 blt a5, a8, dsls_dotprod_16s_ae32_error // Clear accumulator movi a8, 0 wsr a8, acchi // Prepare and load round value movi a8, 0x7fff ssr a6 srl a8, a8 wsr a8, acclo // initialize acc with shifted round value // Compensate for pre-increment // Right shift to 16 bits // RS = -shift + 15 neg a6, a6 addi a6, a6, 15 /* number of loop iterations (see below): * a7 = count / 4 - 1 */ srli a7, a5, 2 addi a7, a7, -1 movi.n a10, 0 // load 0 to the a10 to increment second array dotprod_16s_ae32_full a2, a3, a7, a5 /* Get accumulator */ ssr a6 rsr a2, acchi rsr a3, acclo src a2, a2, a3 s16i a2, a4, 0 movi.n a2, 0 //返回值保存在 a2 寄存器中 retw.ndsls_dotprod_16s_ae32_error: movi.n a2, ESP_ERR_DSL_INVALID_LENGTH retw.n 有些指令会以.n作为后缀，Xtensa处理器为了进一步提高代码密度，提供了一些常用指令的16比特版本，这里的n代表narrow","tags":[{"name":"Assembly","slug":"Assembly","permalink":"https://suda-morris.github.io/tags/Assembly/"},{"name":"Xtensa","slug":"Xtensa","permalink":"https://suda-morris.github.io/tags/Xtensa/"}]},{"title":"Inline Assembly","date":"2019-01-03T08:45:00.000Z","path":"2019/01/03/inline-assembly/","text":"GCC内联汇编的标准格式1asm volatile(\"Instruction List\" : Output : Input : Clobber/Modify); asm用来声明一个内联汇编表达式，任何一个内联汇编表达式都以它开头 Instruction List汇编指令序列，可以为空。比如Linux内核中的内存屏障： 1#define barrier() asm(\"\":::\"memory\"); //它向GCC声明“内存发生了改动，GCC在编译时会将此因素考虑进去。 每条指令必须被双引号括起来 两条指令必须用换行或者分号分开 例如，在ARM系统结构上关闭中断的操作 1234567891011int disable_interrupts (void) &#123; unsigned long old,temp; asm volatile(\"mrs %0, cpsr\\n\" \"orr %1, %0, #0x80\\n\" \"msr cpsr_c, %1\" : \"=r\" (old), \"=r\" (temp) : : \"memory\"); return (old &amp; 0x80) == 0; &#125; volatile向GCC声明不允许对该内联汇编进行优化，否则当使用了优化选项-O进行编译时，GCC会根据自己的判断决定是否将这个内联汇编表达式中的指令优化掉 Output指定当前内联汇编语句的输出，例如从arm协处理器p15中读出c1的值 123456789static unsigned long read_p15_c1 (void) &#123; unsigned long value; asm volatile(\"mrc p15, 0, %0, c1, c0, 0 @ read control reg\\n\" : \"=r\" (value) @编译器选择一个R*寄存器 : : \"memory\"); return value; &#125; Input指定当前内联汇编语句的输入，例如向arm协处理器p15中写入C1值 12345678static void write_p15_c1 (unsigned long value) &#123; asm volatile(\"mcr p15, 0, %0, c1, c0, 0 @ write it back\\n\" : : \"r\" (value) @编译器选择一个R*寄存器 : \"memory\"); read_p15_c1 (); &#125; Clobber/Modify有时候，你想通知GCC当前内联汇编语句可能会对某些寄存器或者内存进行修改，希望GCC在编译时能够将这点考虑进去。可以在这个区域声明这些寄存器或者内存。 这种情况一般发生在一个寄存器出现在“Instruction List”，但却不是由Input/Output操作表达式所指定的，也不是在一些Input/Output操作表达式使用“r”约束时由GCC为其选择的，同时此寄存器被“Instruction List”中的指令修改，而这个寄存器只是供当前内联汇编临时使用的情况。例如： 1asm(\"mov R0, #0x34\" : : : \"R0\");//寄存器R0出现在“Instruction List”中，并且被mov指令修改，但是却未被任何Input/Output操作表达式指定，所以需要在Clobber/Modify域指定“R0”，让GCC知道这一点 如果一个内联汇编语句的Clobber/Modify域存在“memory”，那么GCC会保证在此内联汇编之前，如果某个内存的内容被装入了寄存器，那么在这个内联汇编之后，如果需要使用这个内存处的内容，就会直接到这个内存处重新读取，而不是使用被存放在寄存器中的拷贝。因为这个时候寄存器中的拷贝已经很可能和内存处的内容不一致了。","tags":[{"name":"Assembly","slug":"Assembly","permalink":"https://suda-morris.github.io/tags/Assembly/"}]},{"title":"Electron Vue","date":"2019-01-03T08:14:00.000Z","path":"2019/01/03/electron-vue/","text":"安装 electron-vue 脚手架并新建工程 npm install -g vue-cli 新建工程 vue init simulatedgreg/electron-vue esp-desk 安装依赖 npm install 运行程序 npm run dev 参考文献 electron-vue官方中文文档","tags":[{"name":"Electron","slug":"Electron","permalink":"https://suda-morris.github.io/tags/Electron/"},{"name":"Vue","slug":"Vue","permalink":"https://suda-morris.github.io/tags/Vue/"}]},{"title":"QR-Code","date":"2018-11-07T02:41:58.000Z","path":"2018/11/07/qr-code/","text":"QR 码基本结构 QR码基本结构 格式信息：表示该二维码的纠错级别，分为L(7%)、M(15%)、Q(%25)、H(30%) 版本信息：即二维码的规格，共有40种规格的矩阵，从21x21（版本1）到177x177（版本40），每一个版本符号比前一版本每边增加4个模块 数据和纠错码字：实际保存的二维码信息和纠错码字（用于修正二维码损坏带来的错误） QR 码数据容量 类型 容量 数字 最多7089字符 字母 最多4296字符 二进制数 最多2593字节 日本汉字/片假名 最多1817字符（采用Shift JIS） 中文汉字 最多984字符（采用UTF-8） 中文汉字 最多1800字符（采用BIG5） QR数据模式指示符 模式 指示符 ECI 0111 数字 0001 字母数字 0010 8位字节 0100 日本汉字 1000 中国汉字 1101 结构链接 0011 FNC1 0101（第一位置），1001（第二位置） 终止符 0000 QR编码过程例如：对数据：01234567 进行编码（版本 1-H） 分组： 012 345 67 转成二进制： 012 → 0000001100 345 → 0101011001 67 → 1000011 转成序列： 0000001100 0101011001 1000011 字符数转成二进制： 8 → 0000001000 加入模式指示符：0001： 0001 0000001000 0000001100 0101011001 1000011 按需要将码字序列分块，并根据纠错等级和分块的码字产生纠错码字，并把纠错码字加入到数据码字序列后面，成为一个新的序列 在规格确定的条件下，将上面产生的序列按次序放入分块中，按规定把数据分块，然后对每一块进行计算，得出相应的纠错码字区块，把纠错码字区块按顺序构成一个序列，添加到原先的数据码字序列后面 构造矩阵，将探测图形、分隔符、定位图形、校正图形和码字模块放入矩阵中 将掩膜图形用于符号的编码区域，使得二维码图形中的深色和浅色区域能够比率最优的分布 生成格式和版本信息放入相应区域内","tags":[{"name":"QR-Code","slug":"QR-Code","permalink":"https://suda-morris.github.io/tags/QR-Code/"}]},{"title":"Q-learning","date":"2018-11-06T02:15:27.000Z","path":"2018/11/06/q-learning/","text":"Q学习——强化学习的具体方法在Q学习的框架中，作为学习对象的是称为Q值（Q-value）的数值，Q值是指在某种情况下，为了选择下一个要采取的行动的指标数值的集合。根据Q学习而获得Q值，在某个状态下选择下一个行动时，可以根据Q值来进行选择。 Q学习中，获得合适的Q值是学习的目标，在学习的初期，不清楚什么是合适的Q值，所以无法做决定。因此在学习的初期，Q值是由随机数来随机确定的。在此基础上，根据Q值进行行动的选择，更新状态。 Q值更新原则1&2 Q值更新原则3 Q值更新的计算公式$$Q(s_t,a_t)=Q(s_t,a_t)+\\alpha(r+\\gamma \\space maxQ(s_{t+1},a_{t+1})-Q(s_t,a_t))$$ $s_t$表示t时刻的状态，$a_t$表示在$s_t$时所选的行动 $\\max Q(s_{t+1},a_{t+1})$表示在下一个时刻（t+1）能够选择的行动中所对应的Q值中的最大值 $r$表示奖赏（仅限于能够获得时，不能获得的话，是0） $\\alpha$表示学习系数（0.1左右） $\\gamma$表示折扣率（0.9左右） Q-learning算法步骤 Q-learning算法步骤","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://suda-morris.github.io/tags/Algorithm/"}]},{"title":"Compilation Process","date":"2018-11-02T02:20:53.000Z","path":"2018/11/02/compilation-process/","text":"本文将介绍如何将高层的C/C++语言编写的程序转换成为处理器能够执行的二进制代码的过程，该过程即一般编译原理书籍所介绍的过程，包括四个步骤： 预处理（Preprocessing） 编译（Compilation） 汇编（Assembly） 链接（Linking） GCC工具链介绍GCC工具链概述通常所说的GCC是GUN Compiler Collection的简称，是Linux系统上常用的编译工具。GCC实质上不是一个单独的程序，而是多个程序的集合，因此通常称为GCC工具链。工具链软件包括GCC、C运行库、Binutils、GDB等。 GCC GCC（GNU C Compiler）是编译工具。本文所要介绍的将C/C++语言编写的程序转换成为处理器能够执行的二进制代码的过程即由编译器完成。有关编译过程的更多介绍请参见后文。 GCC既支持本地编译（即在一个平台上编译该平台运行的程序)，也支持交叉编译（即在一个平台上编译供另一个平台运行的程序）。 C运行库 由于C运行库的相关背景知识较多，请参见后文对其单独进行介绍。 Binutils 由于Binutils的相关信息较多，请参见后文对其单独进行介绍。 GDB GDB（GNU Project Debugger）是调试工具，可以用于对程序进行调试。 Binutils一组二进制程序处理工具，包括：addr2line、ar、objcopy、objdump、as、ld、ldd、readelf、size等。这一组工具是开发和调试不可缺少的工具，分别简介如下： addr2line：用来将程序地址转换成其所对应的程序源文件及所对应的代码行，也可以得到所对应的函数。该工具将帮助调试器在调试的过程中定位对应的源代码位置。 as：主要用于汇编，有关汇编的详细介绍请参见后文。 ld：主要用于链接，有关链接的详细介绍请参见后文。 ar：主要用于创建静态库。为了便于初学者理解，在此介绍动态库与静态库的概念： 如果要将多个.o目标文件生成一个库文件，则存在两种类型的库，一种是静态库，另一种是动态库。 在windows中静态库是以 .lib 为后缀的文件，共享库是以 .dll 为后缀的文件。在linux中静态库是以.a为后缀的文件，共享库是以.so为后缀的文件。 静态库和动态库的不同点在于代码被载入的时刻不同。静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。在Linux系统中，可以用ldd命令查看一个可执行程序依赖的共享库。 如果一个系统中存在多个需要同时运行的程序且这些程序之间存在共享库，那么采用动态库的形式将更节省内存。但是对于嵌入式系统，大多数情况下都是整个软件就是一个可执行程序且不支持动态加载的方式，即以静态库为主。 ldd：可以用于查看一个可执行程序依赖的共享库。 objcopy：将一种对象文件翻译成另一种格式，譬如将.bin转换成.elf、或者将.elf转换成.bin等。 objdump：主要的作用是反汇编。有关反汇编的详细介绍，请参见后文。 readelf：显示有关ELF文件的信息，请参见后文了解更多信息。 size：列出可执行文件每个部分的尺寸和总尺寸，代码段、数据段、总大小等，请参见后文了解使用size的具体使用实例。 Binutils的每个工具的功能均很强大，本节限于篇幅无法详细介绍其功能，读者可以自行查阅资料了解其详情。Binutils还有其他工具，在此不一一赘述，感兴趣的读者可以自行查阅其他资料学习。 C运行库为了解释C运行库，需要先回忆一下C语言标准。C语言标准主要由两部分组成：一部分描述C的语法，另一部分描述C标准库。C标准库定义了一组标准头文件，每个头文件中包含一些相关的函数、变量、类型声明和宏定义，譬如常见的printf函数便是一个C标准库函数，其原型定义在stdio头文件中。 C语言标准仅仅定义了C标准库函数原型，并没有提供实现。因此，C语言编译器通常需要一个C运行时库（C Run Time Libray，CRT）的支持。C运行时库又常简称为C运行库。与C语言类似，C++也定义了自己的标准，同时提供相关支持库，称为C++运行时库。 如上所述，要在一个平台上支持C语言，不仅要实现C编译器，还要实现C标准库，这样的实现才能完全支持C标准。glibc（GNU C Library）是Linux下面C标准库的实现，其要点如下： glibc本身是GNU旗下的C标准库，后来逐渐成为了Linux的标准C库。glibc 的主体分布在Linux系统的/lib与/usr/lib目录中，包括 libc 标准 C 函式库、libm数学函式库等等，都以.so做结尾。 注意：Linux系统下面的标准C库不仅有这一个，如uclibc、klibc、以及Linux libc，但是glibc使用最为广泛。而在嵌入式系统中使用较多的C运行库为Newlib。 Linux系统通常将libc库作为操作系统的一部分，它被视为操作系统与用户程序的接口。譬如：glibc不仅实现标准C语言中的函数，还封装了操作系统提供的系统服务，即系统调用的封装。 通常情况，每个特定的系统调用对应了至少一个glibc 封装的库函数，如系统提供的打开文件系统调用sys_open对应的是glibc中的open函数；其次，glibc 一个单独的API可能调用多个系统调用，如glibc提供的 printf 函数就会调用如 sys_open、sys_mmap、sys_write、sys_close等系统调用；另外，多个 glibc API也可能对应同一个系统调用，如glibc下实现的malloc、free 等函数用来分配和释放内存，都利用了内核的sys_brk的系统调用。 对于C++语言，常用的C++标准库为libstdc++。注意：通常libstdc++与GCC捆绑在一起的，即安装gcc的时候会把libstdc++装上。而glibc并没有和GCC捆绑于一起，这是因为glibc需要与操作系统内核打交道，因此其与具体的操作系统平台紧密耦合。而libstdc++虽然提供了c++程序的标准库，但其并不与内核打交道。对于系统级别的事件，libstdc++会与glibc交互，从而和内核通信。 GCC命令行选项GCC有着丰富的命令行选项支持各种不同的功能，本文由于篇幅有限，无法一一赘述，请读者自行查阅相关资料学习。 对于RISC-V的GCC工具链而言，还有其特有的编译选项。 准备Hello World程序123456#include &lt;stdio.h&gt;int main(void)&#123; printf(\"Hello World! \\n\"); return 0;&#125; 编译过程预处理预处理的过程主要包括以下过程： 将所有的#define删除，并且展开所有的宏定义，并且处理所有的条件预编译指令，比如#if #ifdef #elif #else #endif等。 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。 删除所有注释“//”和“/ /”。 添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号。 保留所有的#pragma编译器指令，后续编译过程需要使用它们。 使用gcc进行预处理的命令如下： 12gcc -E hello.c -o hello.i # 将源文件hello.c文件预处理生成hello.i # GCC的选项-E使GCC在进行完预处理后即停止 hello.i文件可以作为普通文本文件打开进行查看，其代码片段如下所示： 12345678910111213extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));# 942 \"/usr/include/stdio.h\" 3 4# 2 \"hello.c\" 2# 3 \"hello.c\"intmain(void)&#123; printf(\"Hello World!\" \"\\n\"); return 0;&#125; 编译编译过程就是对预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码。 使用gcc进行编译的命令如下： 12gcc -S hello.i -o hello.s # 将预处理生成的hello.i文件编译生成汇编程序hello.s # GCC的选项-S使GCC在执行完编译后停止，生成汇编程序 上述命令生成的汇编程序hello.s的代码片段如下所示，其全部为汇编代码。 123456789101112131415main:.LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $.LC0, %edi call puts movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc 汇编汇编过程调用对汇编代码进行处理，生成处理器能识别的指令，保存在后缀为.o的目标文件中。由于每一个汇编语句几乎都对应一条处理器指令，因此，汇编相对于编译过程比较简单，通过调用Binutils中的汇编器as根据汇编指令和处理器指令的对照表一一翻译即可。 当程序由多个源代码文件构成时，每个文件都要先完成汇编工作，生成.o目标文件后，才能进入下一步的链接工作。注意：目标文件已经是最终程序的某一部分了，但是在链接之前还不能执行。 使用gcc进行汇编的命令如下： 1234gcc -c hello.s -o hello.o # 将编译生成的hello.s文件汇编生成目标文件hello.o # GCC的选项-c使GCC在执行完汇编后停止，生成目标文件# 或者直接调用as进行汇编as -c hello.s -o hello.o # 使用Binutils中的as将hello.s文件汇编生成目标文件 注意：hello.o目标文件为ELF（Executable and Linkable Format）格式的可重定向文件，不能以普通文本形式的查看（vim文本编辑器打开看到的是乱码）。有关ELF文件的更多介绍，请参见后文。 链接经过汇编以后的目标文件还不能直接运行，为了变成能够被加载的可执行文件，文件中必须包含固定格式的信息头，还必须与系统提供的启动代码链接起来才能正常运行，这些工作都是由链接器来完成的。 GCC可以通过调用Binutils中的链接器ld来链接程序运行需要的所有目标文件，以及所依赖的其它库文件，最后生成一个ELF格式可执行文件。 如果直接调用Binutils中的ld进行链接，命令如下，则会报出错误： 12345# 直接调用ld试图将hello.o文件链接成为最终的可执行文件hellold hello.o –o hellold: warning: cannot find entry symbol _start; defaulting to 00000000004000b0hello.o: In function `main':hello.c:(.text+0xa): undefined reference to `puts' 之所以直接用ld进行链接会报错是因为仅仅依靠一个hello.o目标文件还无法链接成为一个完整的可执行文件，需要明确的指明其需要的各种依赖库和引导程序以及链接脚本，此过程在嵌入式软件开发时是必不可少的。而在Linux系统中，可以直接使用gcc命令执行编译直至链接的过程，gcc会自动将所需的依赖库以及引导程序链接在一起成为Linux系统可以加载的ELF格式可执行文件。使用gcc进行编译直至链接的命令如下： 123gcc hello.c -o hello # 将hello.c文件编译汇编链接生成可执行文件hello # GCC没有添加选项，则使GCC一步到位地执行到链接后停止，生成最终的可执行文件./hello # 成功执行该文件，在终端上会打印Hello World！字符串 Hello World! 注意：hello可执行文件为ELF（Executable and Linkable Format）格式的可执行文件，不能以普通文本形式的查看（vim文本编辑器打开看到的是乱码）。 在前文介绍了动态库与静态库的差别，与之对应的，链接也分为静态链接和动态链接，其要点如下： 静态链接是指在编译阶段直接把静态库加入到可执行文件中去，这样可执行文件会比较大。链接器将函数的代码从其所在地（不同的目标文件或静态链接库中）拷贝到最终的可执行程序中。为创建可执行文件，链接器必须要完成的主要任务是：符号解析（把目标文件中符号的定义和引用联系起来）和重定位（把符号定义和内存地址对应起来然后修改所有对符号的引用）。 而动态链接则是指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。 在Linux系统中，gcc编译链接时的动态库搜索路径的顺序通常为：首先从gcc命令的参数-L指定的路径寻找；再从环境变量LIBRARY_PATH指定的路径寻址；再从默认路径/lib、/usr/lib、/usr/local/lib寻找。 在Linux系统中，执行二进制文件时的动态库搜索路径的顺序通常为：首先搜索编译目标代码时指定的动态库搜索路径；再从环境变量LD_LIBRARY_PATH指定的路径寻址；再从配置文件/etc/ld.so.conf中指定的动态库搜索路径；再从默认路径/lib、/usr/lib寻找。 在Linux系统中，可以用ldd命令查看一个可执行程序依赖的共享库。 由于链接动态库和静态库的路径可能有重合，所以如果在路径中有同名的静态库文件和动态库文件，比如libtest.a和libtest.so，gcc链接时默认优先选择动态库，会链接libtest.so，如果要让gcc选择链接libtest.a则可以指定gcc选项-static，该选项会强制使用静态库进行链接。以本节的Hello World为例： 如果使用命令“gcc hello.c -o hello”则会使用动态库进行链接，生成的ELF可执行文件的大小（使用Binutils的size命令查看）和链接的动态库（使用Binutils的ldd命令查看）如下所示： 12345678$ gcc hello.c -o hello$ size hello # 使用size查看大小 text data bss dec hex filename 1183 552 8 1743 6cf hello$ ldd hello # 可以看出该可执行文件链接了很多其他动态库，主要是Linux的glibc动态库 linux-vdso.so.1 =&gt; (0x00007fffefd7c000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fadcdd82000) /lib64/ld-linux-x86-64.so.2 (0x00007fadce14c000) 如果使用命令“gcc -static hello.c -o hello”则会使用静态库进行链接，生成的ELF可执行文件的大小（使用Binutils的size命令查看）和链接的动态库（使用Binutils的ldd命令查看）如下所示： 123456$ gcc -static hello.c -o hello$ size hello # 使用size查看大小 text data bss dec hex filename 823726 7284 6360 837370 cc6fa hello # 可以看出text的代码尺寸变得极大$ ldd hello not a dynamic executable # 说明没有链接动态库 链接器链接后生成的最终文件为ELF格式可执行文件，一个ELF可执行文件通常被链接为不同的段，常见的段譬如.text、.data、.rodata、.bss等段。有关ELF文件和常见段的更多介绍，请参见后文。 一步到位的编译从功能上分，预处理、编译、汇编、链接是四个不同的阶段，但GCC的实际操作上，它可以把这四个步骤合并为一个步骤来执行。如下例所示： 12gcc –o test first.c second.c third.c# 该命令将同时编译三个源文件，即first.c、second.c和 third.c，然后将它们链接成一个可执行文件，名为test。 注意： 一个程序无论有一个源文件还是多个源文件，所有被编译和链接的源文件中必须有且仅有一个main函数。 但如果仅仅是把源文件编译成目标文件，因为不会进行链接，所以main函数不是必需的。 分析ELF文件ELF文件介绍在介绍ELF文件之前，首先将其与另一种常见的二进制文件格式bin进行对比： binary文件，其中只有机器码。 elf文件除了含有机器码之外还有其它信息，如：段加载地址，运行入口地址，数据段等。 ELF全称Executable and Linkable Format，可执行链接格式。ELF文件格式主要三种： 可重定向（Relocatable）文件： 文件保存着代码和适当的数据，用来和其他的目标文件一起来创建一个可执行文件或者是一个共享目标文件。 可执行（Executable）文件： 文件保存着一个用来执行的程序（例如bash，gcc等）。 共享（Shared）目标文件（Linux下后缀为.so的文件）： 即所谓共享库。 ELF文件的段ELF文件格式如图1中所示，位于ELF Header和Section Header Table之间的都是段（Section）。一个典型的ELF文件包含下面几个段： .text：已编译程序的指令代码段。 .rodata：ro代表read only，即只读数据（譬如常数const）。 .data：已初始化的C程序全局变量和静态局部变量。 注意：C程序普通局部变量在运行时被保存在堆栈中，既不出现在.data段中，也不出现在.bss段中。此外，如果变量被初始化值为0，也可能会放到bss段。 .bss：未初始化的C程序全局变量和静态局部变量。 注意：目标文件格式区分初始化和未初始化变量是为了空间效率，在ELF文件中.bss段不占据实际的存储器空间，它仅仅是一个占位符。 .debug：调试符号表，调试器用此段的信息帮助调试。 上述仅讲解了最常见的节，ELF文件还包含很多其他类型的节，本文在此不做赘述，请感兴趣的读者自行查阅其他资料了解学习。 ELF文件格式 查看ELF文件可以使用Binutils中readelf来查看ELF文件的信息，可以通过readelf –help来查看readelf的选项： 123456789$ readelf --helpUsage: readelf &lt;option(s)&gt; elf-file(s) Display information about the contents of ELF format files Options are: -a --all Equivalent to: -h -l -S -s -r -d -V -A -I -h --file-header Display the ELF file header -l --program-headers Display the program headers --segments An alias for --program-headers -S --section-headers Display the sections' header 以本文Hello World示例，使用readelf -S查看其各个section的信息如下： 12345678910111213141516$ readelf -S helloThere are 31 section headers, starting at offset 0x19d8:Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0…… [11] .init PROGBITS 00000000004003c8 000003c8 000000000000001a 0000000000000000 AX 0 0 4…… [14] .text PROGBITS 0000000000400430 00000430 0000000000000182 0000000000000000 AX 0 0 16 [15] .fini PROGBITS 00000000004005b4 000005b4…… 反汇编由于ELF文件无法被当做普通文本文件打开，如果希望直接查看一个ELF文件包含的指令和数据，需要使用反汇编的方法。反汇编是用于调试和定位处理器问题时最常用的手段。 可以使用Binutils中objdump来对ELF文件进行反汇编，可以通过objdump –help来查看其选项： 12345678$ objdump --helpUsage: objdump &lt;option(s)&gt; &lt;file(s)&gt; Display information from object &lt;file(s)&gt;. At least one of the following switches must be given:…… -D, --disassemble-all Display assembler contents of all sections -S, --source Intermix source code with disassembly…… 以本文Hello World示例，使用objdump -D对其进行反汇编如下： 12345678910111213$ objdump -D hello……0000000000400526 &lt;main&gt;: # main标签的PC地址# PC地址： 指令编码 指令的汇编格式 400526: 55 push %rbp 400527: 48 89 e5 mov %rsp,%rbp 40052a: bf c4 05 40 00 mov $0x4005c4,%edi 40052f: e8 cc fe ff ff callq 400400 &lt;puts@plt&gt; 400534: b8 00 00 00 00 mov $0x0,%eax 400539: 5d pop %rbp 40053a: c3 retq 40053b: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1)…… 使用objdump -S将其反汇编并且将其C语言源代码混合显示出来： 123456789101112131415161718192021$ gcc -o hello -g hello.c # 要加上-g选项$ objdump -S hello……0000000000400526 &lt;main&gt;:#include &lt;stdio.h&gt;intmain(void)&#123; 400526: 55 push %rbp 400527: 48 89 e5 mov %rsp,%rbp printf(\"Hello World!\" \"\\n\"); 40052a: bf c4 05 40 00 mov $0x4005c4,%edi 40052f: e8 cc fe ff ff callq 400400 &lt;puts@plt&gt; return 0; 400534: b8 00 00 00 00 mov $0x0,%eax&#125; 400539: 5d pop %rbp 40053a: c3 retq 40053b: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1)…… 嵌入式系统编译的特殊性为了易于读者理解，本文以一个Hello World程序为例讲解了在Linux环境中的编译过程以帮助初学者入门，但是了解这些基础背景知识对于嵌入式开发还远远不够。对于嵌入式开发，嵌入式系统的编译过程和开发有其特殊性，譬如： 嵌入式系统需要使用交叉编译与远程调试的方法进行开发。 需要自己定义引导程序。 需要注意减少代码尺寸。 需要移植printf从而使得嵌入式系统也能够打印输入。 使用Newlib作为C运行库。 每个特定的嵌入式系统都需要配套的板级支持包。 交叉编译和远程调试嵌入式平台上往往资源有限，嵌入式系统（譬如常见ARM MCU或8051单片机）的存储器容量通常只在几KB到几MB之间，且只有闪存而没有硬盘这种大容量存储设备，在这种资源有限的环境中，不可能将编译器等开发工具安装在嵌入式设备中，所以无法直接在嵌入式设备中进行软件开发。因此，嵌入式平台的软件一般在主机PC上进行开发和编译，然后将编译好的二进制代码下载至目标嵌入式系统平台上运行，这种编译方式属于交叉编译。 交叉编译可以简单理解为，在当前编译平台下，编译出来的程序能运行在体系结构不同的另一种目标平台上，但是编译平台本身却不能运行该程序，譬如，在x86平台的PC电脑上编写程序并编译成能运行在ARM平台的程序，编译得到的程序在x86平台上不能运行，必须放到ARM平台上才能运行。 与交叉编译同理，在嵌入式平台上往往也无法运行完整的调试器，因此当运行于嵌入式平台上的程序出现问题时，需要借助主机PC平台上的调试器来对嵌入式平台进行调试。这种调试方式属于远程调试。 常见的交叉编译和远程调试工具是GCC和GDB。GCC不仅能作为本地编译器，还能作为交叉编译器；同理GDB不仅可以作为本地调试器，还可以作为远程调试器。 当作为交叉编译器之时，GCC通常有不同的命名，譬如： arm-none-eabi-gcc和arm-none-eabi-gdb是面向裸机（Bare-Metal）ARM平台的交叉编译器和远程调试器。 所谓裸机（Bare-Metal）是嵌入式领域的一个常见形态，表示不运行操作系统的系统 而riscv-none-embed-gcc和riscv-none-embed-gdb是面向裸机RISC-V平台的交叉编译器和远程调试器。 移植newlib或newlib-nano作为C运行库newlib是一个面向嵌入式系统的C运行库。相对于glibc，newlib实现了大部分的功能函数，但体积却小很多。newlib独特的体系结构将功能实现与具体的操作系统分层，使之能够很好地进行配置以满足嵌入式系统的要求。由于专为嵌入式系统设计，newlib具有可移植性强、轻量级、速度快、功能完备等特点，已广泛应用于各种嵌入式系统中。 由于嵌入式操作系统和底层硬件的多样性，为了能够将C/C++语言所需要的库函数实现与具体的操作系统和底层硬件进行分层，newlib的所有库函数都建立在20个桩函数的基础上，这20个桩函数完成具体操作系统和底层硬件相关的功能： I/O和文件系统访问（open、close、read、write、lseek、stat、fstat、fcntl、link、unlink、rename）； 扩大内存堆的需求（sbrk）； 获得当前系统的日期和时间（gettimeofday、times）； 各种类型的任务管理函数（execve、fork、getpid、kill、wait、_exit）； 这20个桩函数在语义、语法上与POSIX（Portable Operating System Interface of UNIX）标准下对应的20个同名系统调用完全兼容。 所以，如果需要移植newlib至某个目标嵌入式平台，成功移植的关键是在目标平台下找到能够与newlib桩函数衔接的功能函数或者实现这些桩函数。 注意：newlib的一个特殊版本newlib-nano版本进一步为嵌入式平台减少了代码体积（Code Size），因为newlib-nano提供了更加精简版本的malloc和printf函数的实现，并且对库函数使用GCC的-Os（侧重代码体积的优化）选项进行编译优化。 嵌入式引导程序和中断异常处理前文介绍了如何在Linux系统的PC电脑上开发一个Hello World程序，对其进行编译，然后运行在此电脑上。在这种方式下，程序员仅仅只需要关注Hello World程序本身，程序的主体由main函数组织而成，程序员可以无需关注Linux操作系统在运行该程序的main函数之前和之后需要做什么。事实上，在Linux操作系统中运行应用程序（譬如简单的Hello World）时，操作系统需要动态地创建一个进程、为其分配内存空间、创建并运行该进程的引导程序，然后才会开始执行该程序的main函数，待其运行结束之后，操作系统还要清除并释放其内存空间、注销该进程等。 从上述过程中可以看出，程序的引导和清除这些“脏活累活”都是由Linux这样的操作系统来负责进行。但是在嵌入式系统中，程序员除了开发以main函数为主体的功能程序之外，还需要关注如下两个方面： 引导程序： 嵌入式系统上电后需要对系统硬件和软件运行环境进行初始化，这些工作往往由用汇编语言编写的引导程序完成。 引导程序是嵌入式系统上电后运行的第一段软件代码。引导程序对于嵌入式系统非常关键，引导程序所执行的操作依赖于所开发的嵌入式系统的软硬件特性，一般流程包括：初始化硬件、设置异常和中断向量表、把程序拷贝到片上SRAM中、完成代码的重映射等，最后跳转到main函数入口。 中断异常处理 中断和异常是嵌入式系统非常重要的一个环节，因此，嵌入式系统软件还必须正确地配置中断和异常处理函数。 嵌入式系统链接脚本上文中介绍了如何在Linux系统的PC电脑上开发一个Hello World程序，对其进行编译，然后运行在此电脑上。在这种方式下，程序员也无需关心编译过程中的“链接”这一步骤所使用的链接脚本，无需为程序分配具体的内存空间。 但是在嵌入式系统中，程序员除了开发以main函数为主体的功能程序之外，还需要关注“链接脚本”为程序分配合适的存储器空间，譬如程序段放在什么区间、数据段放在什么区间等等。 减小代码体积嵌入式平台上往往存储器资源有限，嵌入式系统（譬如常见的ARM MCU或8051单片机）的存储器容量通常只在几KB到几MB之间，且只有闪存而没有硬盘这种大容量存储设备，在这种资源有限的环境中，程序的代码体积（Code Size）显得尤其重要，因此，有效地降低降低代码体积（Code Size）是嵌入式软件开发必须要考虑的问题，常见的方法如： 使用newlib-nano作为C运行库以取得较小代码体积（Code Size）的C库函数。 尽量少使用C语言的大型库函数，譬如在正式发行版本的程序中避免使用printf和scanf等函数。 如果在开发的过程中一定需要使用printf函数，可以使用某些自己实现的阉割版printf函数（而不是C运行库中提供的printf函数）以生成较小的代码体积。 除此之外，在C/C++语言的语法和程序开发方面也有众多技巧以取得更小的代码体积（Code Size）。 支持printf函数上文中介绍了如何在Linux系统的PC电脑上开发一个Hello World程序，程序中使用C语言的标准库函数printf打印了一个“Hello World”字符串。该程序在Linux系统里面运行的时候字符串被成功的输出到了Linux的终端界面上。在这个过程中，程序员无需关心Linux系统到底是如何将printf函数的字符串输出到Linux终端上的。事实上，在Linux本地编译的程序会链接使用Linux系统的C运行库glibc，而glibc充当了应用程序和Linux操作系统之间的接口，glibc提供的 printf 函数就会调用如sys_write等操作系统的底层系统调用函数，从而能够将“字符串”输出到Linux终端上。 从上述过程中可以看出，由于有glibc的支持，所以printf函数能够在Linux系统中正确的进行输出。但是在嵌入式系统中，printf的输出却不那么容易了，基于如下几个原因： 嵌入式系统使用newlib作为C运行库，而newlib的C运行库所提供的printf函数最终依赖于如本文中所介绍的newlib桩函数write，因此必须实现此write函数才能够正确的执行printf函数。 嵌入式系统往往没有“显示终端”存在，譬如常见的单片机其作为一个黑盒子一般的芯片，根本没有显示终端。因此，为了能够支持显示输出，通常需要借助单片机芯片的UART接口将printf函数的输出重新定向到主机PC的COM口上，然后借助主机PC的串口调试助手显示出输出信息。同理，对于scanf输入函数，也需要通过主机PC的串口调试助手获取输入然后通过主机PC的COM口发送给单片机芯片的UART接口。 从以上两点可以看出，嵌入式平台的UART接口非常重要，往往扮演了输出管道的角色，为了能够将printf函数的输出定向到UART接口，需要实现newlib的桩函数write，使其通过编程UART的相关寄存器将字符通过UART接口输出。 提供板级支持包对于特定的嵌入式硬件平台，为了方便用户在硬件平台上开发嵌入式程序，硬件平台一般会提供板级支持包（Board Support Package，BSP）。板级支持包所包含的内容没有绝对的标准，通常说来，其必须包含如下内容： 底层硬件设备的地址分配信息 底层硬件设备的驱动函数 系统的引导程序 中断和异常处理服务程序 系统的链接脚本 如果使用newlib作为C运行库，一般还提供newlib桩函数的实现。","tags":[{"name":"Compile","slug":"Compile","permalink":"https://suda-morris.github.io/tags/Compile/"}]},{"title":"pyside2","date":"2018-10-29T02:46:38.000Z","path":"2018/10/29/pyside2/","text":"PySide2安装1sudo pip install pyside2 -i https://pypi.tuna.tsinghua.edu.cn/simple Get Started12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding:utf-8 -*- import sysimport randomfrom PySide2 import QtCore, QtWidgets, QtGuiclass MyWidget(QtWidgets.QWidget): def __init__(self): QtWidgets.QWidget.__init__(self) self.hello = [\"Hallo Welt\", \"你好，世界\", \"Hei maailma\", \"Hola Mundo\", \"Привет мир\"] self.button = QtWidgets.QPushButton(\"Click me!\") self.text = QtWidgets.QLabel(\"Hello World\") self.text.setAlignment(QtCore.Qt.AlignCenter) self.text.setFont(QtGui.QFont(\"Titillium\", 30)) self.button.setFont(QtGui.QFont(\"Titillium\", 20)) self.layout = QtWidgets.QVBoxLayout() self.layout.addWidget(self.text) self.layout.addWidget(self.button) self.setLayout(self.layout) self.button.clicked.connect(self.magic) def magic(self): self.text.setText(random.choice(self.hello))if __name__ == \"__main__\": app = QtWidgets.QApplication([]) widget = MyWidget() widget.resize(800, 600) widget.show() sys.exit(app.exec_()) 使用QML123456789101112# -*- coding:utf-8 -*-from PySide2.QtWidgets import QApplicationfrom PySide2.QtQuick import QQuickViewfrom PySide2.QtCore import QUrlif __name__ == \"__main__\": app = QApplication([]) view = QQuickView() url = QUrl(\"app.qml\") view.setSource(url) view.show() app.exec_() 12345678910import QtQuick 2.0Rectangle&#123; width:300 height:300 color:\"cyan\" Text&#123; text:\"Hello world\" anchors.centerIn:parent &#125;&#125; 参考文献 官方教程","tags":[{"name":"Python","slug":"Python","permalink":"https://suda-morris.github.io/tags/Python/"}]},{"title":"Python Socket","date":"2018-10-17T14:36:12.000Z","path":"2018/10/17/python-socket/","text":"Python中的Socket编程Python标准库中的socket模块 socket对象支持使用TCP或者UDP协议进行网络通信，并提供了socket编程所需要的对象、函数和常量 简单TCP服务器实例123456789101112131415161718192021222324# -*- coding: utf-8 -*-import socketserver_host = \"192.168.1.103\"server_port = 3629if __name__ == \"__main__\": server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 本套接字是建立在IPv4基础上的流式套接字 server_sock.bind((server_host, server_port)) # 绑定本地地址和端口号 server_sock.listen(5) # 使能监听 client_sock, client_addr_info = server_sock.accept() # 阻塞，等待客户端连接 while True: data = client_sock.recv(1024) # 接收数据 data = data.decode(\"utf-8\") # 数据解码 if data == \"bye\": break print(\"Receive from Client[&#123;addr_info&#125;]:&#123;content&#125;\".format(addr_info=client_addr_info, content=data)) data = data + \"--&gt; OK\" client_sock.send(data.encode(\"utf-8\")) # 发送数据给客户端 client_sock.close() # 关闭客户端套接字 server_sock.close() # 关闭服务端套接字 简单TCP客户端实例1234567891011121314151617181920# -*- coding: utf-8 -*-import socketserver_host = \"192.168.1.103\"server_port = 3629if __name__ == \"__main__\": client_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 本套接字是建立在IPv4基础上的流式套接字 client_sock.connect((server_host, server_port)) # 向服务器发起连接 while True: data = input(\"Please Enter a Message to Send: \") if data: client_sock.send(data.encode(\"utf-8\")) if data == \"bye\": break data = client_sock.recv(1024) data = data.decode(\"utf-8\") print(\"Receive from Server: &#123;content&#125;\".format(content=data)) client_sock.close() 简单UDP服务器实例1234567891011121314151617181920# -*- coding: utf-8 -*-import socketserver_host = \"192.168.1.103\"server_port = 3629if __name__ == \"__main__\": server_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 本套接字是建立在IPv4基础上的数据报套接字 server_sock.bind((server_host, server_port)) # 绑定IP地址和端口号 while True: data, client_addr_info = server_sock.recvfrom(1024) data = data.decode(\"utf-8\") if data == \"bye\": break print(\"Receive from Client[&#123;addr_info&#125;]:&#123;content&#125;\".format(addr_info=client_addr_info, content=data)) data = data + \" --&gt; OK\" server_sock.sendto(data.encode(\"utf-8\"), client_addr_info) server_sock.close() 简单UDP客户端实例12345678910111213141516171819# -*- coding: utf-8 -*-import socketserver_host = \"192.168.1.103\"server_port = 3629if __name__ == \"__main__\": client_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 本套接字是建立在IPv4基础上的数据报套接字 while True: data = input(\"Please Enter a Message to Send: \") if data: client_sock.sendto(data.encode(\"utf-8\"), (server_host, server_port)) if data == \"bye\": break data, server_addr_info = client_sock.recvfrom(1024) data = data.decode(\"utf-8\") print(\"Receive from Server[&#123;addr_info&#125;]:&#123;content&#125;\".format(addr_info=server_addr_info, content=data)) client_sock.close() 小项目—备份服务器与客户端的简单实现(多线程版) bak_server_protocol 服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231# -*- coding: utf-8 -*-import osimport pickleimport socketimport structimport threadingfrom tkinter import *from tkinter.ttk import *DEFAULT_BAK_PATH = r\"E:\\MyBak\" # 服务器端默认备份路径SERV_RUN_FLAG = True # 服务器运行标志flag_lock = threading.Lock() # 运行标志的指令锁def get_file_infos(client): \"\"\" 接受客户端传来的文件列表信息 :param client:客户端连接套接字 :return:data要备份的文件列表信息，compress是否是压缩文件 \"\"\" fmt_str = 'Q?' # 长整形+布尔型 headsize = struct.calcsize(fmt_str) data = client.recv(headsize) # 接受文件信息列表的长度 infos_len, compress = struct.unpack(fmt_str, data) # unpack字节数据 data = b\"\" # 保存文件列表信息 while True: # 每次最多接收1K字节 if infos_len &gt; 1024: data += client.recv(1024) infos_len -= 1024 else: data += client.recv(infos_len) break data = pickle.loads(data) # 使用pickle反序列化 return data, compressdef mk_file_path(filepath_rel): \"\"\" 根据文件的相对路径创建服务器端的路径 :param filepath_rel: 客户端文件的相对路径 \"\"\" paths = filepath_rel.split(os.path.sep)[:-1] # 按照目录级别切分，去掉最后一项(文件名) p = DEFAULT_BAK_PATH for path in paths: p = os.path.join(p, path) # 逐级创建文件夹 if not os.path.exists(p): os.mkdir(p)def get_compress_size(client): \"\"\" 获取压缩文件的大小 :param client: 客户端连接套接字 :return: size压缩文件的大小 \"\"\" fmt_str = 'Q' # 长整型 size = struct.calcsize(fmt_str) data = client.recv(size) size = struct.unpack(fmt_str, data)[0] return sizedef recv_file(client, filepath_rel, file_size, compress): \"\"\" 接收并保存单个文件 :param client:客户端连接套接字 :param filepath_rel:文件的相对地址 :param file_size:文件大小 :param compress:是否是压缩文件 :return:返回接收成功与否 \"\"\" res = True mk_file_path(filepath_rel) filepath = os.path.join(DEFAULT_BAK_PATH, filepath_rel) # 文件在服务器端的完整路径 if compress: file_size = get_compress_size(client) filepath = \"\".join([os.path.splitext(filepath)[0], \".tar.gz\"]) # 修改文件拓展名 f = open(filepath, \"wb+\") try: while True: if file_size &gt; 1024: data = client.recv(1024) f.write(data) file_size -= 1024 else: data = client.recv(file_size) f.write(data) break except socket.error as e: print(e) res = False else: res = True finally: f.close() return resdef send_echo(client, result): \"\"\" 发送当前文件的备份结果给客户端 :param client: 客户端连接的套接字 :param result: 当前文件备份的结果 \"\"\" if result: client.send(b\"success\") else: client.send(b\"failure\")def client_operate(client_sock): \"\"\" 客户端处理线程 :param client_sock:客户端连接套接字 \"\"\" files_infos, compress = get_file_infos(client_sock) # 获取客户端传送的文件列表信息以及是否发送压缩文件 for file_size, file_path_rel in files_infos: # 逐个接收文件 res = recv_file(client_sock, file_path_rel, file_size, compress) send_echo(client_sock, res) client_sock.close() # 关闭客户端套接字def start(host, port): \"\"\" 启动服务后运行的线程函数 :param host: 服务器IP地址 :param port: 服务器端口号 \"\"\" if not os.path.exists(DEFAULT_BAK_PATH): # 判断本地备份根目录是否存在 os.mkdir(DEFAULT_BAK_PATH) server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 创建流失套接字 server_sock.settimeout(1) # 设置超时时间1s server_sock.bind((host, int(port))) # 绑定服务器端的IP和端口号 server_sock.listen(1) # 同一时间只处理一个客户端的连接 flag_lock.acquire() # 访问SERV_RUN_FLAG之前需要先获取指令锁 while SERV_RUN_FLAG: flag_lock.release() # 访问完成后立马释放指令锁 client_sock = None # 客户端连接的套接字 try: client_sock, addr_info = server_sock.accept() # 1s内没有发生客户端连接动作就会产生超时异常 except socket.timeout: pass if client_sock: # 确实有客户端发起连接请求 t = threading.Thread(target=client_operate, args=(client_sock,)) # 单独开线程处理客户端的需求 t.start() flag_lock.acquire() # 访问SERV_RUN_FLAG之前需要先获取指令锁 server_sock.close()class MyFrame(Frame): def __init__(self, root): \"\"\" 自定义Frame :param root: 父类容器对象 \"\"\" super().__init__(root) self.root = root self.grid() # 网格布局 self.local_ip = \"127.0.0.1\" self.local_ports = [10888, 20888, 30888] self.serv_ip = None self.serv_port = None self.__init_components() def __init_components(self): \"\"\" 初始化界面组件 \"\"\" proj_name = Label(self, text=u\"远程备份服务器\") proj_name.grid(columnspan=2) # 横跨两列 serv_ip_label = Label(self, text=u\"服务地址\") serv_ip_label.grid(row=1) self.serv_ip = Combobox(self, values=self.__get_ip_address()) # 下拉列表 self.serv_ip.set(self.local_ip) # 下拉列表默认值 self.serv_ip.grid(row=1, column=1) serv_port_label = Label(self, text=u\"服务端口\") serv_port_label.grid(row=2) self.serv_port = Combobox(self, values=self.local_ports) self.serv_port.set(self.local_ports[0]) self.serv_port.grid(row=2, column=1) self.start_serv_btn = Button(self, text=u\"启动服务\", command=self.__start_serv) self.start_serv_btn.grid(row=3) self.exit_serv_btn = Button(self, text=u\"退出服务\", command=self.__exit_serv) self.exit_serv_btn.grid(row=3, column=1) def __get_ip_address(self): \"\"\" 获取服务器端可用的IP地址 :return: IP地址列表 \"\"\" hostname = socket.gethostname() # 获取主机名 info = socket.gethostbyname_ex(hostname) # 根据主机名获取IP地址信息 info = info[2] # 第3项才是ip地址列表 info.append(self.local_ip) # 加上回环地址 return info def __start_serv(self): \"\"\" 【启动服务】按键处理程序 \"\"\" host = self.serv_ip.get() # 从下拉列表中获取用户设置的IP地址 port = self.serv_port.get() # 从下拉列表中获取用户设置的端口号 t = threading.Thread(target=start, args=(host, port)) # 开启线程处理客户端连接请求 t.start() self.start_serv_btn.state([\"disabled\", ]) # 启动按钮变暗 def __exit_serv(self): \"\"\" 【退出服务】按键处理程序 \"\"\" global SERV_RUN_FLAG while True: if flag_lock.acquire(): SERV_RUN_FLAG = False flag_lock.release() break self.root.destroy() # 退出界面if __name__ == \"__main__\": root = Tk() root.title(u\"备份服务器\") root.resizable(False, False) app = MyFrame(root) app.mainloop() 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187# -*- coding: utf-8 -*-import osimport pickleimport socketimport structimport tarfileimport tempfileimport threadingfrom tkinter import *from tkinter.ttk import *def send_file_infos(client, file_infos, compress): \"\"\" 发送文件信息 :param client:客户端连接套接字 :param file_infos: 文件信息，列表 :param compress: 是否需要压缩 \"\"\" fmt_str = 'Q?' # 长整型+布尔类型 infos_bytes = pickle.dumps(file_infos) # 对file_infos序列化操作 infos_bytes_len = len(infos_bytes) infos_bytes_len_pack = struct.pack(fmt_str, infos_bytes_len, compress) # 用struct模块对长度值进行二进制编码 client.sendall(infos_bytes_len_pack) # 先发送长度 client.sendall(infos_bytes) # 再发送内容def send_file(client, file, compress): \"\"\" 发送单个文件至服务器 :param client:客户端连接套接字 :param file:#要发送文件的绝对路径 :param compress:是否需要压缩 \"\"\" if not compress: f = open(file, \"rb\") # 二进制只读方式读取文件 else: f = tempfile.NamedTemporaryFile() # 创建临时文件 tar = tarfile.open(mode=\"w:gz\", fileobj=f) # gzip 压缩 tar.add(file) tar.close() f.seek(0) # 调整文件指针位置 file_size = os.stat(f.name).st_size # 计算压缩文件的大小 file_size_pack = struct.pack('Q', file_size) # 压缩文件大小二进制编码 client.sendall(file_size_pack) try: while True: data = f.read(1024) # 每次发送1K字节，直到发送结束 if data: client.sendall(data) # 发送原文件或者时压缩文件 else: break finally: f.close()def get_bak_info(client, size=7): \"\"\" 从服务器获取当前备份结果信息 :param client:客户端连接套接字 :param size:返回结果信息[success,failure]的字节数 \"\"\" msg = client.recv(size) print(msg.decode(\"utf-8\"))def get_file_infos_paths(root_path): \"\"\" 获取文件夹下的所有文件信息和文件路径 :param root_path:文件夹根目录 :return:infos文件信息列表，元素是元祖(文件大小，文件相对路径)，paths文件绝对路径 \"\"\" infos = [] paths = [] if not root_path or not os.path.exists(root_path): return None, None for dirpath, dirnames, filenames in os.walk(root_path): # 递归遍历根目录下所有文件 # dirpath根目录，dirnames文件夹名，filenames文件名 for file_name in filenames: file_path = os.path.join(dirpath, file_name) # 获取文件的绝对路径 paths.append(file_path) file_size = os.stat(file_path).st_size # 获取文件大小 file_path_rel = file_path[len(root_path) + 1:] # 获取文件相对路径 infos.append((file_size, file_path_rel)) return infos, pathsdef start(host, port, root_path, compress): \"\"\" 开始备份工作的线程函数 :param host:服务器IP地址 :param port:服务器端口号 :param root_path:备份路径根目录 :param compress:是否需要压缩文件 \"\"\" if not os.path.exists(root_path): print(u\"备份的路径不存在!\", root_path) return client_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 建立流式套接字 client_sock.connect((host, port)) # 连接服务器 file_infos, file_paths = get_file_infos_paths(root_path) # 获取指定目录下的文件信息与文件路径 send_file_infos(client_sock, file_infos, compress) # 发送需要备份的文件信息 for fp in file_paths: send_file(client_sock, fp, compress) # 依次发送所有文件 print(fp) # 打印当前正在备份的文件 get_bak_info(client_sock) # 打印文件备份结果 client_sock.close()class MyFrame(Frame): def __init__(self, root): \"\"\" 自定义Frame :param root: 父类容器对象 \"\"\" super().__init__(root) self.root = root # 保存父类容器控件 self.grid() # 整体使用网格布局 self.remote_ip_default = \"127.0.0.1\" # 默认连接的服务器IP地址 self.remote_port_default = 10888 # 默认连接的服务器端口号 self.remote_ip_var = StringVar() # 保存用户输入的服务器IP地址 self.remote_port_var = IntVar() # 保存用户输入的服务器端口号 self.bak_src_var = StringVar() # 保存用户输入的本地备份路径 self.compress_var = BooleanVar() # 保存用户是否需要对文件进行压缩处理 self.__init_components() # 初始化界面上的所有组件 def __init_components(self): \"\"\" 初始化界面组件 \"\"\" proj_name = Label(self, text=u\"远程备份客户端\") proj_name.grid(columnspan=2) # 横跨两列 serv_ip_label = Label(self, text=u\"服务器地址：\") serv_ip_label.grid(row=1) self.serv_ip = Entry(self, textvariable=self.remote_ip_var) # 输入框 self.remote_ip_var.set(self.remote_ip_default) self.serv_ip.grid(row=1, column=1) serv_port_label = Label(self, text=u\"服务器端口：\") serv_port_label.grid(row=2) self.serv_port = Entry(self, textvariable=self.remote_port_var) self.remote_port_var.set(self.remote_port_default) self.serv_port.grid(row=2, column=1) bak_src_label = Label(self, text=u\"备份的目标：\") bak_src_label.grid(row=3) self.bak_src = Entry(self, textvariable=self.bak_src_var) self.bak_src.grid(row=3, column=1) compress_label = Label(self, text=u\"压缩备份：\") compress_label.grid(row=4) self.compress_on = Checkbutton(self, text=u\"开启压缩\", variable=self.compress_var, onvalue=1, offvalue=0) # 单选框 self.compress_on.grid(row=4, column=1) self.start_serv_btn = Button(self, text=u\"开始备份\", command=self.__start_bak) # 按钮，绑定事件处理函数 self.start_serv_btn.grid(row=5) self.exit_serv_btn = Button(self, text=u\"退出程序\", command=self.__exit_bak) self.exit_serv_btn.grid(row=5, column=1) def __start_bak(self): \"\"\" 【开始备份】事件处理 \"\"\" host = self.remote_ip_var.get() port = self.remote_port_var.get() bak_path = self.bak_src_var.get() compress = self.compress_var.get() self.bak_src_var.set(\"\") # 清空备份路径输入框 t = threading.Thread(target=start, args=(host, port, bak_path, compress)) # 创建子线程 t.start() def __exit_bak(self): \"\"\" 【退出程序】事件处理 \"\"\" self.root.destroy() # 退出界面if __name__ == \"__main__\": root = Tk() root.title(u\"备份客户端\") root.resizable(False, False) # 大小不允许伸缩 app = MyFrame(root) app.mainloop() SocketServer框架 Python提供了SocketServer框架用来编写网络服务器，它预定义了一个基本的服务器框架 步骤： 建立客户端处理类 初始化服务器类，传入相关参数 启动服务器 SocketServer框架下的TCP服务器1234567891011121314151617181920212223242526import socketserverimport threadingHOST = \"127.0.0.1\"PORT = 3629def shut_server_down(): if server: server.shutdown()class MyHandler(socketserver.StreamRequestHandler): def handle(self): while True: data = self.rfile.readline() # 按行读取数据(需要数据中包含换行符) if not data: break print(\"Receive From Client: \", data.decode(\"utf-8\").strip('\\n')) self.wfile.write(data) threading.Thread(target=shut_server_down).start() # 服务器的shutdown方法需要在别的线程中调用if __name__ == \"__main__\": server = socketserver.TCPServer((HOST, PORT), MyHandler) # 创建TCP服务器 server.serve_forever() # 运行服务器 配套的TCP客户端12345678910111213141516171819# -*- coding: utf-8 -*-import socketserver_host = \"192.168.1.104\"server_port = 3629if __name__ == \"__main__\": client_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 本套接字是建立在IPv4基础上的流式套接字 client_sock.connect((server_host, server_port)) # 向服务器发起连接 data = True while data: data = input(\"Please Enter a Message to Send: \") data += '\\n' client_sock.send(data.encode(\"utf-8\")) data = client_sock.recv(1024) data = data.decode(\"utf-8\").strip('\\n') print(\"Receive from Server: &#123;content&#125;\".format(content=data)) client_sock.close() SocketServer框架下的UDP服务器123456789101112131415161718192021222324252627import socketserverimport threadingHOST = \"192.168.1.104\"PORT = 3629def shut_server_down(): if server: server.shutdown()class MyHandler(socketserver.DatagramRequestHandler): def handle(self): data, client_sock = self.request data = data.decode(\"utf-8\") if data == \"bye\": threading.Thread(target=shut_server_down).start() return print(\"Receive From Client: \", data) data = data + \"---&gt;OK\" client_sock.sendto(data.encode(\"utf-8\"), self.client_address)if __name__ == \"__main__\": server = socketserver.UDPServer((HOST, PORT), MyHandler) server.serve_forever() 配套的UDP客户端123456789101112131415161718192021# -*- coding: utf-8 -*-import socketserver_host = \"192.168.1.104\"server_port = 3629if __name__ == \"__main__\": client_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 本套接字是建立在IPv4基础上的数据报套接字 while True: data = input(\"Please Enter a Message to Send: \") if data: client_sock.sendto(data.encode(\"utf-8\"), (server_host, server_port)) if data == \"bye\": break data = b\"\" while len(data) == 0: # 防止接收到空数据 data, server_addr_info = client_sock.recvfrom(1024) data = data.decode(\"utf-8\") print(\"Receive from Server[&#123;addr_info&#125;]:&#123;content&#125;\".format(addr_info=server_addr_info, content=data)) client_sock.close() 使用SocketServer框架改写备份服务器程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196# -*- coding: utf-8 -*-import osimport pickleimport socketimport socketserverimport structimport threadingfrom tkinter import *from tkinter.ttk import *DEFAULT_BAK_PATH = r\"E:\\MyBak\" # 服务器端默认备份路径def mk_file_path(filepath_rel): \"\"\" 根据文件的相对路径创建服务器端的路径 :param filepath_rel: 客户端文件的相对路径 \"\"\" paths = filepath_rel.split(os.path.sep)[:-1] # 按照目录级别切分，去掉最后一项(文件名) p = DEFAULT_BAK_PATH for path in paths: p = os.path.join(p, path) # 逐级创建文件夹 if not os.path.exists(p): os.mkdir(p)class BakHandler(socketserver.StreamRequestHandler): def handle(self): self.__client_operate() def __client_operate(self): \"\"\" 客户端处理线程 \"\"\" files_infos, compress = self.__get_file_infos() # 获取客户端传送的文件列表信息以及是否发送压缩文件 for file_size, file_path_rel in files_infos: # 逐个接收文件 res = self.__recv_file(file_path_rel, file_size, compress) # request就是客户端连接的套接字 self.__send_echo(res) self.request.close() # 关闭客户端套接字 def __get_file_infos(self): \"\"\" 接受客户端传来的文件列表信息 :return:data要备份的文件列表信息，compress是否是压缩文件 \"\"\" fmt_str = 'Q?' # 长整形+布尔型 headsize = struct.calcsize(fmt_str) data = self.request.recv(headsize) # 接受文件信息列表的长度 infos_len, compress = struct.unpack(fmt_str, data) # unpack字节数据 data = b\"\" # 保存文件列表信息 while True: # 每次最多接收1K字节 if infos_len &gt; 1024: data += self.request.recv(1024) infos_len -= 1024 else: data += self.request.recv(infos_len) break data = pickle.loads(data) # 使用pickle反序列化 return data, compress def __send_echo(self, result): \"\"\" 发送当前文件的备份结果给客户端 :param result: 当前文件备份的结果 \"\"\" if result: self.request.send(b\"success\") else: self.request.send(b\"failure\") def __recv_file(self, filepath_rel, file_size, compress): \"\"\" 接收并保存单个文件 :param filepath_rel:文件的相对地址 :param file_size:文件大小 :param compress:是否是压缩文件 :return:返回接收成功与否 \"\"\" res = True mk_file_path(filepath_rel) filepath = os.path.join(DEFAULT_BAK_PATH, filepath_rel) # 文件在服务器端的完整路径 if compress: file_size = self.__get_compress_size() filepath = \"\".join([os.path.splitext(filepath)[0], \".tar.gz\"]) # 修改文件拓展名 f = open(filepath, \"wb+\") try: while True: if file_size &gt; 1024: data = self.request.recv(1024) f.write(data) file_size -= 1024 else: data = self.request.recv(file_size) f.write(data) break except socket.error as e: print(e) res = False else: res = True finally: f.close() return res def __get_compress_size(self): \"\"\" 获取压缩文件的大小 :return: size压缩文件的大小 \"\"\" fmt_str = 'Q' # 长整型 size = struct.calcsize(fmt_str) data = self.request.recv(size) size = struct.unpack(fmt_str, data)[0] return sizeclass MyFrame(Frame): def __init__(self, root): \"\"\" 自定义Frame :param root: 父类容器对象(根窗口) \"\"\" super().__init__(root) self.root = root self.server = None self.grid() # 网格布局 self.local_ip = \"127.0.0.1\" self.local_ports = [10888, 20888, 30888] self.serv_ip = None self.serv_port = None self.__init_components() def __init_components(self): \"\"\" 初始化界面组件 \"\"\" proj_name = Label(self, text=u\"远程备份服务器\") proj_name.grid(columnspan=2) # 横跨两列 serv_ip_label = Label(self, text=u\"服务地址\") serv_ip_label.grid(row=1) self.serv_ip = Combobox(self, values=self.__get_ip_address()) # 下拉列表 self.serv_ip.set(self.local_ip) # 下拉列表默认值 self.serv_ip.grid(row=1, column=1) serv_port_label = Label(self, text=u\"服务端口\") serv_port_label.grid(row=2) self.serv_port = Combobox(self, values=self.local_ports) self.serv_port.set(self.local_ports[0]) self.serv_port.grid(row=2, column=1) self.start_serv_btn = Button(self, text=u\"启动服务\", command=self.__start_serv) self.start_serv_btn.grid(row=3) self.exit_serv_btn = Button(self, text=u\"退出服务\", command=self.__exit_serv) self.exit_serv_btn.grid(row=3, column=1) def __get_ip_address(self): \"\"\" 获取服务器端可用的IP地址 :return: IP地址列表 \"\"\" hostname = socket.gethostname() # 获取主机名 info = socket.gethostbyname_ex(hostname) # 根据主机名获取IP地址信息 info = info[2] # 第3项才是ip地址列表 info.append(self.local_ip) # 加上回环地址 return info def __start_serv(self): \"\"\" 【启动服务】按键处理程序 \"\"\" if not os.path.exists(DEFAULT_BAK_PATH): # 判断本地备份根目录是否存在 os.mkdir(DEFAULT_BAK_PATH) host = self.serv_ip.get() # 从下拉列表中获取用户设置的IP地址 port = self.serv_port.get() # 从下拉列表中获取用户设置的端口号 self.start_serv_btn.state([\"disabled\", ]) # 启动按钮变暗 self.server = socketserver.ThreadingTCPServer((host, int(port)), BakHandler) # 创建多线程TCP服务器 threading.Thread(target=self.server.serve_forever).start() # 在新线程中启动服务器 def __exit_serv(self): \"\"\" 【退出服务】按键处理程序 \"\"\" if self.server: threading.Thread(target=self.server.shutdown).start() self.root.destroy() # 退出界面if __name__ == \"__main__\": root = Tk() # 根窗口 root.title(u\"备份服务器\") root.resizable(False, False) app = MyFrame(root) app.mainloop() 项目：简单FTP服务器与客户端的实现FTP服务器的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276import osimport socketserverimport threadingimport timedef add_opr_file(client_addr, item): \"\"\" 向FTPDataHandler类的操作列表中添加新操作 命令通道和数据通道，实际上是通过FTPDataHandler类中的client_oper字典联系在一起的 :param client_addr: 客户端的ip地址 :param item: 新操作 \"\"\" if client_addr in FTPDataHandler.client_oper: FTPDataHandler.client_oper[client_addr].append(item) else: FTPDataHandler.client_oper[client_addr] = [item, ]class FTPHandler(socketserver.StreamRequestHandler): def __init__(self, request=None, client_addr=None, server=None): \"\"\" FTP服务器的处理类 :param request: 请求对象，即连接的客户端socket :param client_addr: 客户端地址 :param server: 与自己绑定的服务器对象(即后面的MyThreadFTPServer对象) \"\"\" self.cmd_keys = (\"QUIT\", \"USER\", \"NOOP\", \"TYPE\", \"PASV\", \"PORT\", \"RETR\", \"STOR\") # FTP服务器支持的命令 self.coms = &#123;&#125; # 字典，&#123;命令:执行方法&#125; self.__init_coms() # 初始化字典coms self.server = server # 与服务类绑定的服务器的引用 self.cmd_port = 21 # 命令端口号 self.data_port = 20 # 数据端口号 self.pasv_data_ip = None # 被动模式下，数据模块线程服务器的IP地址 self.pasv_data_port = None # 被动模式下，数据模块线程服务器的端口号 self.args = None # 某条命令对应的参数 self.loged = False # 用户是否登陆 self.pasv_mode = None # 当前服务器是否工作在被动模式 super().__init__(request, client_addr, server) # 调用父类的构造函数 def __init_coms(self): \"\"\" 初始化字典coms，键为命令名字，值为具体的方法 \"\"\" for key in self.cmd_keys: self.coms[key] = getattr(self, \"exe_\" + key.lower()) # 获取exe_开头的成员方法 def handle(self): \"\"\" 重写父类的处理函数 \"\"\" while True: cmds = self.rfile.readline() # 读取一行用户发来的命令 if not cmds: continue cmds = cmds.decode(\"utf-8\") # 解码 cmd = self.__parse_cmd(cmds) # 解析命令 if cmd in self.cmd_keys: self.coms[cmd]() # 执行命令对应的方法 else: self.__send(500, \"Invalid command.\") if cmd == \"QUIT\": break def __parse_cmd(self, cmds): \"\"\" 从字符串中提取命令动词和参数 :param cmds:包含命令、参数的字符串 :return:命令动词，大写 \"\"\" if ' ' in cmds: # 根据空格来判断是否包含命令参数 cmd, args = cmds.split(' ') # 切分命令动词与命令参数 self.args = args.strip('\\n').strip() # 清除换行符与空格 else: cmd = cmds.strip('\\n').strip() return cmd.upper() def __send(self, code, info): \"\"\" 向客户端返回命令执行状态 :param code:状态码 :param info:状态信息 \"\"\" infos = \"%d %s\\n\" % (code, info) self.request.sendall(infos.encode(\"utf-8\")) def __make_pasv_info(self): \"\"\" 返回进入主动模式的信息 :return: 返回给客户端的信息，包括主动模式数据通道的IP地址和端口号，按照FTP协议的格式要求发送 \"\"\" ip_info = self.pasv_data_ip.split('.') # IP地址之间的.号使用,号来替代 ip_info = ','.join(ip_info) porta_info = str(self.pasv_data_port // 256) portb_info = str(self.pasv_data_port % 256) return ','.join((ip_info, porta_info, portb_info)) def __enter_pasv(self): \"\"\" 进入被动模式，开启数据服务器 \"\"\" if not self.server.data_server: self.pasv_data_ip, self.pasv_data_port = self.server.create_data_server() def exe_quit(self): \"\"\" QUIT命令的执行动作 \"\"\" self.__send(221, \"bye.\") def exe_user(self): \"\"\" USER命令的执行动作 \"\"\" user = self.args # 获取登陆的用户名 if user in (\"\", \"anonymous\"): self.loged = True self.__send(230, \"identified!\") else: self.__send(530, \"Only use anonymous.\") def exe_noop(self): \"\"\" NOOP命令的执行动作 \"\"\" self.__send(200, \"ok.\") def exe_type(self): \"\"\" TYPE命令的执行动作 \"\"\" self.__send(200, \"ok.\") def exe_pasv(self): \"\"\" PASV命令的执行动作 \"\"\" if not self.loged: self.__send(332, \"Please login.\") return if self.pasv_mode: # 已经passive模式了 info = \"entering passive mode (%s)\" % self.__make_pasv_info() self.__send(227, info) return try: self.__enter_pasv() # 进入passive模式 info = \"entering passive mode (%s)\" % self.__make_pasv_info() self.pasv_mode = True self.__send(227, info) except Exception as e: # 进入passive模式失败 print(e) self.pasv_mode = False self.__send(500, \"Fail to enter passvie mode.\") def exe_port(self): \"\"\" PORT命令的执行动作 \"\"\" self.__send(500, \"Do not support port mode.\") def exe_retr(self): \"\"\" RETR命令的执行动作 \"\"\" if not os.path.exists(os.path.join(\"/root\", \"server\", self.args)): # 确保要下载的文件是存在的 self.__send(550, \"File &#123;file_path&#125; not exist!\".format(file_path=self.args)) return client_addr = self.request.getpeername()[0] # 获取客户端的IP地址 add_opr_file(client_addr, (\"RETR\", self.args)) # 向数据通道中添加新的任务 self.__send(150, \"ok.\") def exe_stor(self): \"\"\" STOR命令的执行动作 \"\"\" client_addr = self.request.getpeername()[0] add_opr_file(client_addr, (\"STOR\", self.args)) # 向数据通道中添加新的任务 self.__send(150, \"ok.\")class FTPDataHandler(socketserver.StreamRequestHandler): client_oper = &#123;&#125; # 字典，键为客户端IP地址，值为列表，存放具体的操作 def handle(self): \"\"\" 数据服务器针对每个连接的客户端的操作 \"\"\" peerip = self.request.getpeername()[0] # 获取连接的客户端的IP地址 opr = self.__get_opr_args(peerip) # 根据IP地址查询该客户端具体的操作 if opr: if opr[0] == \"RETR\": self.retr_file(opr[1]) # 下载文件 elif opr[0] == \"STOR\": self.stor_file(opr[1]) # 上传文件 self.request.close() # 处理完依次上传或者下载任务后就关闭客户端套接字 def __get_opr_args(self, peerip): \"\"\" 根据IP地址查询客户端需要服务的内容 :param peerip: 远端的IP地址 :return: opr具体的操作 \"\"\" if peerip in self.client_oper: opr = self.client_oper[peerip].pop(0) # 弹出列表中的第一个 if not self.client_oper[peerip]: # 针对该IP地址，列表中没有其余操作了 self.client_oper.pop(peerip) # 在字段中删除这个IP地址为键的项目 return opr def retr_file(self, filepath): \"\"\" 客户端下载文件(对应服务器端的发送文件) :param filepath: 文件路径 \"\"\" filepath = os.path.join(\"/root\", \"server\", filepath) print(filepath) f = open(filepath, \"rb\") while True: data = f.read(1024) if data: self.request.sendall(data) else: break f.close() def stor_file(self, filepath): \"\"\" 客户端上传文件(对应服务器端的接收并保存文件) :param filepath:文件路径 \"\"\" filepath = os.path.join(\"/root\", \"server\", filepath) print(filepath) f = open(filepath, \"wb\") # 将新文件保存到当前目录的bakt文件夹下 while True: data = self.request.recv(1024) if data: f.write(data) else: break f.close()class MyThreadFTPServer(socketserver.ThreadingTCPServer): def __init__(self, addr, handler): \"\"\" 自定义多线程FTP服务器 :param addr: 服务器地址，元祖(IP地址，端口号)，21命令端口，20数据端口 :param handler:处理客户端连接的对象 \"\"\" self.data_server = None # 专门负责数据通道的服务器 super().__init__(addr, handler) def shutdown(self): \"\"\" 重写父类的shutdown函数 \"\"\" if self.data_server: # 是否有数据通道服务器没有关闭 threading.Thread(target=self.data_server.shutdown).start() super().shutdown() # 调用父类的挂机函数 def create_data_server(self): \"\"\" 创建数据通道专用服务器 :return:pasv_data_ip数据服务器的IP地址；pasv_data_port数据服务器的端口号 \"\"\" self.data_server = socketserver.ThreadingTCPServer((\"127.0.0.1\", 0), FTPDataHandler) pasv_data_ip, pasv_data_port = self.data_server.server_address # 获取数据服务器的ip地址和端口号 threading.Thread(target=self.data_server.serve_forever).start() # 开启新线程，启动数据服务器 return pasv_data_ip, pasv_data_portif __name__ == \"__main__\": ftp_server = MyThreadFTPServer((\"127.0.0.1\", 21), FTPHandler) threading.Thread(target=ftp_server.serve_forever).start() # 开启新线程，启动FTP服务器 print(\"FTP Server Start...\") # time.sleep(30) # ftp_server.shutdown() FTP客户端的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173import osimport socketimport threadingdef get_file(host, port, file_path): \"\"\" 从服务器下载文件 :param host: 服务器IP地址 :param port: 服务器端口号 :param file_path: 文件路径 \"\"\" s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) file_path = os.path.join(\"/root\", \"client\", file_path) # 文件保存在服务器的bakt文件夹下 print(file_path) f = open(file_path, \"wb\") data = True while data: data = s.recv(1024) if data: f.write(data) s.close() f.close()def put_data(host, port, file_path): \"\"\" 上传文件至服务器 :param host: 服务器的IP地址 :param port: 服务器的端口号 :param file_path: 本地文件路径 \"\"\" s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) print(file_path) f = open(file_path, \"rb\") while True: data = f.read(1024) if data: s.sendall(data) else: break s.close() f.close()class FTPClient(object): def __init__(self, host=\"localhost\", port=21): \"\"\" 自定义FTP客户端 :param host:服务器IP地址 :param port:服务器端口号 \"\"\" self.host = host # 服务器ip地址 self.port = port # 服务器端口号 self.cmds = (\"QUIT\", \"USER\", \"NOOP\", \"TYPE\", \"PASV\", \"PORT\", \"RETR\", \"STOR\") # 支持的FTP命令 self.line_sep = '\\n' self.loged = False # 是否已经登陆服务器 self.sock = None # 连接服务器端的套接字 self.pasv_mode = None # 是否处于被动模式 self.pasv_host = None # 被动模式的服务器ip地址 self.pasv_port = None # 被动模式的服务器端口号 def __cmd_connect(self): \"\"\" 连接服务器 \"\"\" self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.connect((self.host, self.port)) def __login(self): \"\"\" 登录服务器 \"\"\" if self.sock: self.send_cmd(\"USER\") res = self.read_line(self.sock) if res.startswith(\"230\"): print(\"Log in Successfully!\") self.loged = True def read_line(self, sock): \"\"\" 按行读取服务器返回数据 :param sock: 套接字 :return: data接收到的一行数据 \"\"\" data = \"\" while not data.endswith(self.line_sep): d = sock.recv(1) data += d.decode(\"utf-8\") return data def __parse_cmd(self, cmd_str): \"\"\" 从字符串中解析命令 :param cmd_str: 命令字符串 :return: 返回命令动词(大写)，命令参数 \"\"\" if ' ' in cmd_str: cmd_lst = cmd_str.split(' ') cmd = cmd_lst[0] args = ' '.join(cmd_lst[1:]) else: cmd = cmd_str args = '' return cmd.upper(), args def send_cmd(self, cmd, args=\"\"): \"\"\" 发送命令 :param cmd: 命令动词 :param args: 命令参数 :return: 返回命令发送成功与否 \"\"\" if self.sock: if args: cmd = ' '.join((cmd, args)) if cmd.startswith(\"RETR\") or cmd.startswith(\"STOR\"): if not self.pasv_mode: print(\"Please enter passive mode first\") return False if not args: print(\"Please specify a file\") return False if cmd.startswith(\"STOR\"): if not os.path.exists(args): print(\"File not exist\") return False cmd += self.line_sep self.sock.sendall(cmd.encode(\"utf-8\")) return True def start(self): \"\"\" 循环执行用户输入的命令 \"\"\" print(\"Supported Commands: \", self.cmds) self.__cmd_connect() # 连接 self.__login() # 登陆 while True: cmd_str = input(\"Enter your commands: \") if not cmd_str: print(\"FTP command can not be empty\") continue cmd, args = self.__parse_cmd(cmd_str) if not self.send_cmd(cmd, args): print(\"Fail to send your command: \", cmd) continue res = self.read_line(self.sock) print(res) if cmd.startswith(\"PASV\") and res.startswith(\"227\"): self.pasv_mode = True server_info = res[res.index('(') + 1:res.index(')')] self.pasv_host = '.'.join(server_info.split(',')[:4]) server_info = server_info.split(',')[-2:] self.pasv_port = int(server_info[0]) * 256 + int(server_info[1]) if cmd.startswith(\"RETR\"): # 下载文件 if self.pasv_mode: threading.Thread(target=get_file, args=(self.pasv_host, self.pasv_port, args)).start() if cmd.startswith(\"STOR\"): # 上传文件 if self.pasv_mode: threading.Thread(target=put_data, args=(self.pasv_host, self.pasv_port, args)).start() if cmd.startswith(\"QUIT\"): break self.sock.close() self.sock = Noneif __name__ == \"__main__\": ftp_client = FTPClient() ftp_client.start()","tags":[{"name":"Socket","slug":"Socket","permalink":"https://suda-morris.github.io/tags/Socket/"}]},{"title":"Logistic Regression","date":"2018-10-15T04:36:12.000Z","path":"2018/10/15/logistic-regression/","text":"Logistic Regression Logistic回归虽然是名字中带有“回归”，但实际上它是一种分类算法，主要应用与二分类问题(输出只有两种结果，比如0和1) 逻辑回归实质上可以看作是一种简单的神经网络 LogReg_kiank 数学公式推导假设神经元的突触的权重向量为w，线性偏置为b(标量)，对于第i个样本$x^{(i)}$来说： $$z^{(i)} = w^T x^{(i)} + b\\tag{1}$$ 得到的$z^{(i)}$需要进一步输入激活函数，激活函数的选择有很多种，考虑到Logistic回归的输出只有0和1两种情况，因此选用sigmoid函数会比较符合要求： $$\\hat{y}^{(i)}=a^{(i)}=sigmoid(z^{(i)})\\tag{2}$$ sigmoid函数的导数： $$\\frac{da}{dz}=a(1-a)\\tag{3}$$ Sigmoid 如何衡量预测结果的好坏，需要定义损失函数L： $$ L(a^{(i)},y^{(i)})=- y^{(i)}\\ln(a^{(i)})-(1-y^{(i)})\\ln(1-a^{(i)})\\tag{4}$$ 那么价值函数J就是所有样本的损失值的平均： $$ J=\\frac{1}{m}\\sum_{i=1}^mL(a^{(i)}, y^{(i)})\\tag{5}$$ 我们的目标是通过多次的迭代，求得使得J最小的自变量参数w和b，这里使用的优化算法为梯度下降法，其中α称为学习率，是0~1之间的浮点数： $$\\theta=\\theta-\\alpha d\\theta\\tag{6}$$ 我们把求解价值函数的过程称为正向传播，把求解梯度的过程称为反向传播 价值函数对于第j个突触$w_j$的梯度：$$\\frac{\\partial J}{\\partial w_j}=\\frac{1}{m}\\sum_{i=1}^m\\frac{\\partial}{\\partial w_j}[-y^{(i)}\\ln{(a^{(i)})}-(1-y^{(i)})\\ln{(1-a^{(i)})}]\\=\\frac{1}{m}\\sum_{i=1}^{m}[\\frac{-y^{(i)}}{a^{(i)}}\\cdot\\frac{\\partial{a^{(i)}}}{\\partial{w_j}}+\\frac{(1-y^{i})}{1-a^{(i)}}\\cdot\\frac{\\partial{a^{i}}}{\\partial{w_j}}]\\=\\frac{1}{m}\\sum_{i=1}^{m}[\\frac{\\partial{a^{(i)}}}{\\partial{w_j}}\\cdot(\\frac{1-y^{(i)}}{1-a^{(i)}}-\\frac{y^{(i)}}{a^{(i)}})]\\=\\frac{1}{m}\\sum_{i=1}^{m}[\\frac{d{a^{(i)}}}{d{z^{(i)}}}\\cdot\\frac{\\partial{z^{(i)}}}{\\partial{w_j}}\\cdot(\\frac{1-y^{(i)}}{1-a^{(i)}}-\\frac{y^{(i)}}{a^{(i)}})]\\=\\frac{1}{m}\\sum_{i=1}^{m}[a^{(i)}\\cdot(1-a^{(i)})\\cdot x_j^{(i)}\\cdot\\frac{a^{(i)}-y^{(i)}}{a^{(i)}\\cdot(1-a^{(i)})}]\\=\\frac{1}{m}\\sum_{i=1}^{m}[x_j^{(i)}\\cdot(a^{(i)}-y^{(i)})]$$价值函数J对于所有突触的权重向量w的梯度： $$ \\frac{\\partial J}{\\partial w}=\\frac{1}{m}X(A-Y)^T\\tag{7}$$ 价值函数J对偏置b的梯度： $$ \\frac{\\partial J}{\\partial b}=\\frac{1}{m}\\sum_{i=1}^m (a^{(i)}-y^{(i)})\\tag{8}$$ 所以，每一次迭代的过程中，对w和b的更新规则为： $$w:=w-\\alpha\\frac{\\partial{J}}{\\partial{w}}\\tag{9}$$ $$b:=b-\\alpha\\frac{\\partial{J}}{\\partial{b}}\\tag{10}$$ Python程序编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npimport pandas as pddef sigmoid(z): \"\"\" Compute the sigmoid of z :param z: A scalar or numpy array of any size. :return: sigmoid(z) \"\"\" s = 1.0 / (1 + np.exp(-1 * z)) return sclass LogisticRegression(object): def __init__(self, num_iterations=2000, learning_rate=0.001, print_cost=False): \"\"\" Builds the logistic regression model :param num_iterations: hyperparameter representing the number of iterations to optimize the parameters :param learning_rate: hyperparameter representing the learning rate when update the parameters :param print_cost: Set to true to print the cost every 100 iterations \"\"\" self.n_iter = num_iterations self.learn_rate = learning_rate self.print_cost = print_cost self.w = None # weights, a numpy array of size self.b = None # bias, a scalar def __initialize_with_zeros(self, dim): \"\"\" This function creates a vector of zeros of shape (dim, 1) for w and initializes b to 0. :param dim: size of the w vector we want :return: w -- initialized vector of shape (dim, 1); b -- initialized scalar (corresponds to the bias) \"\"\" w = np.zeros((dim, 1)) b = 0 assert (w.shape == (dim, 1)) assert (isinstance(b, float) or isinstance(b, int)) return w, b def __propagate(self, X, Y): \"\"\" Implement the cost function and its gradient for the propagation :param X: input data :param Y: label vector :return: grads --- results of backward propagation; cost --- results of forward propagation \"\"\" m = X.shape[1] # FORWARD PROPAGATION (FROM X TO COST) Z = np.dot(self.w.T, X) + self.b A = sigmoid(Z) # compute activation cost = -1 / m * (np.dot(Y, np.log(A).T) + np.dot(1 - Y, np.log((1 - A)).T)) # compute cost # BACKWARD PROPAGATION (TO FIND GRAD) dw = 1 / m * (np.dot(X, (A - Y).T)) # gradient of the loss with respect to w, thus same shape as w db = np.sum(A - Y) / m # gradient of the loss with respect to b, thus same shape as b assert (dw.shape == self.w.shape) assert (db.dtype == float) cost = np.squeeze(cost) assert (cost.shape == ()) grads = &#123;\"dw\": dw, \"db\": db&#125; return grads, cost def fit(self, X_train, Y_train): \"\"\" This function optimizes w and b by running a gradient descent algorithm :param X_train: input data :param Y_train: label vector :return: costs -- list of all the costs computed during the optimization \"\"\" # initialize parameters with zeros self.w, self.b = self.__initialize_with_zeros(X_train.shape[0]) costs = [] for i in range(self.n_iter): grads, cost = self.__propagate(X_train, Y_train) # Cost and gradient calculation dw = grads[\"dw\"] db = grads[\"db\"] # update rule self.w -= self.learn_rate * dw self.b -= self.learn_rate * db # Record the costs if i % 100 == 0: costs.append(cost) # Print the cost every 100 training examples if self.print_cost and i % 100 == 0: print(\"Cost after iteration %i: %f\" % (i, cost)) return costs def predict(self, X_test): \"\"\" Predict whether the label is 0 or 1 using learned logistic regression parameters (w, b) :param X_test: input data :return: Y_prediction -- a numpy array (vector) containing all predictions (0/1) for the examples in X_test \"\"\" m = X_test.shape[1] Y_prediction = np.zeros((1, m)) w = self.w.reshape(X_test.shape[0], 1) # Compute vector \"A\" predicting the probabilities A = sigmoid(np.dot(w.T, X_test) + self.b) # Convert probabilities A[0,i] to actual predictions p[0,i] Y_prediction = np.where(A &gt; 0.5, [1], [0]) assert (Y_prediction.shape == (1, m)) return Y_predictionif __name__ == \"__main__\": train_size = 150 df = pd.read_csv(\"iris.csv\", header=None) Y_train = df.loc[0:train_size - 1, 4].values Y_train = np.where(Y_train == \"Iris-setosa\", [1], [0]) Y_train = Y_train.reshape((1, train_size)) X_train = df.loc[0:train_size - 1, [0, 2]].values feature1_min, feature1_max = X_train[:, 0].min() - 1, X_train[:, 0].max() + 1 feature2_min, feature2_max = X_train[:, 1].min() - 1, X_train[:, 1].max() + 1 X_train = X_train.T.reshape((2, train_size)) clf = LogisticRegression(num_iterations=2000, learning_rate=0.001, print_cost=True) clf.fit(X_train, Y_train) # 将向量扩充为二维矩阵，作为测试样本 xx1, xx2 = np.meshgrid(np.arange(feature1_min, feature1_max, 0.02), np.arange(feature2_min, feature2_max, 0.02)) X_test = np.array([xx1.ravel(), xx2.ravel()]) # 预测结果 Y_prediction = clf.predict(X_test) Y_prediction = Y_prediction.reshape(xx1.shape) # 数据可视化 markers = ('s', 'x') colors = (\"red\", \"blue\") plt.contourf(xx1, xx2, Y_prediction, c=\"gray\") plt.xlim(feature1_min, feature1_max) plt.ylim(feature2_min, feature2_max) for idx, y_train in enumerate(np.unique(Y_train)): plt.scatter(x=X_train[0, np.squeeze(Y_train == y_train)], y=X_train[1, np.squeeze(Y_train == y_train)], alpha=0.8, c=colors[idx], marker=markers[idx], label=y_train) plt.xlabel(u\"花瓣长度\", fontproperties='SimHei') plt.ylabel(u\"花茎长度\", fontproperties='SimHei') plt.legend(loc=\"upper left\") plt.show()","tags":[{"name":"Logistic","slug":"Logistic","permalink":"https://suda-morris.github.io/tags/Logistic/"}]},{"title":"NFC-PN532","date":"2018-08-14T09:45:14.000Z","path":"2018/08/14/nfc-pn532/","text":"NFC——PN532介绍概述 PN532是一个高度集成的非接触式读写芯片，它包含80C51微控制器内核，集成了13.56MHz下的各种主动/被动式非接触通信方法和协议。 PN532传输模块支持6种不同的工作模式： 读写器模式，支持ISO/IEC 14443A/MIFARE机制 读写器模式，支持FeliCa机制 读写器模式，支持ISO/IEC 14443B机制 卡操作模式，支持ISO 14443A/MIFARE机制 卡操作模式，支持FeliCa机制 ISO/IEC18092，ECM340点对点","tags":[{"name":"NFC","slug":"NFC","permalink":"https://suda-morris.github.io/tags/NFC/"}]},{"title":"chisel-notes","date":"2018-08-03T06:36:15.000Z","path":"2018/08/03/chisel/","text":"简介 Chisel是UC Berkeley开发的一种开源硬件建模语言，支持高度参数化的生成器和分层的特定领域的硬件语言进行高级硬件设计。 安装 安装Java环境 1sudo apt-get install default-jdk 安装sbt（Chisel使用的编译系统） 1234echo \"deb https://dl.bintray.com/sbt/debian /\" | sudo tee -a /etc/apt/sources.list.d/sbt.listsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 642AC823sudo apt-get updatesudo apt-get install sbt 安装Verilator（将Verilog文件编译成C++来做仿真） 12345678910sudo apt-get install git make autoconf g++ flex bisongit clone http://git.veripool.org/git/verilatorcd verilatorgit pullgit checkout verilator_3_922unset VERILATOR_ROOT # For bash, unsetenv for cshautoconf # Create ./configure script./configuremakesudo make install 上手实验 下载教程需要的代码仓库 1234git clone https://github.com/ucb-bar/chisel-tutorial.gitcd chisel-tutorialgit fetch origingit checkout release 运行Chisel（期间会下载Chisel3软件，测试工具，Scala） 1sbt run Chisel入门导入必要的软件包123import chisel3._import chisel3.util._import chisel3.iotesters.&#123;ChiselFlatSpec, Driver, PeekPokeTester&#125; 第一个模块1234567class PassthroughGenerator(width: Int) extends Module &#123; val io = IO(new Bundle &#123; val in = Input(UInt(width.W)) val out = Output(UInt(width.W)) &#125;) io.out := io.in&#125; 所有的硬件模块都要继承Module类 所有的输入输出端口都需要在名字为io的常量中声明，该变量必须是IO类的实例，在实例化的时候需要传入Bundle类型的实例对象 在Bundle实例中指定输入和输入的信号 :=运算符是Chisel自定义的，用来表示左边的信号由右边的信号来驱动 编译成Verilog/FIRRTL12println(getVerilog(new PassthroughGenerator(10)))println(getFirrtl(new PassthroughGenerator(20))) 测试123456789101112val testResult = Driver(() =&gt; new Passthrough()) &#123; c =&gt; new PeekPokeTester(c) &#123; poke(c.io.in, 0) // Set our input to value 0 expect(c.io.out, 0) // Assert that the output correctly has 0 poke(c.io.in, 1) // Set our input to value 1 expect(c.io.out, 1) // Assert that the output correctly has 1 poke(c.io.in, 2) // Set our input to value 2 expect(c.io.out, 2) // Assert that the output correctly has 2 &#125;&#125;assert(testResult) // Scala Code: if testResult == false, will throw an errorprintln(\"SUCCESS!!\") // Scala Code: if we get here, our tests passed! 调用poke可以设置某个输入信号的值 调用except可以检查某个输出信号是否和预期的相同 调用peek可以获取某个输出信号的值 关于printf123456789101112131415161718192021class PrintingModule extends Module &#123; val io = IO(new Bundle &#123; val in = Input(UInt(4.W)) val out = Output(UInt(4.W)) &#125;) io.out := io.in printf(\"Print during simulation: Input is %d\\n\", io.in) // chisel printf has its own string interpolator too printf(p\"Print during simulation: IO is $io\\n\") println(s\"Print during generation: Input is $&#123;io.in&#125;\")&#125;class PrintingModuleTester(c: PrintingModule) extends PeekPokeTester(c) &#123; poke(c.io.in, 3) step(5) // circuit will print println(s\"Print during testing: Input is $&#123;peek(c.io.in)&#125;\")&#125;chisel3.iotesters.Driver( () =&gt; new PrintingModule ) &#123; c =&gt; new PrintingModuleTester(c) &#125; 以下三种情况中使用打印功能会有所差别 在编译生成硬件电路的时候 在运行电路仿真的时候 在运行测试模块的时候 println不能在电路仿真的时候用来打印，因为此时的电路已经是Verilog或者Firrtl语言描述的 上述代码的运行结果为123456789101112131415161718192021[info] [0.002] Elaborating design...Print during generation: Input is chisel3.core.UInt@7[info] [0.115] Done elaborating.Total FIRRTL Compile Time: 176.6 msTotal FIRRTL Compile Time: 14.3 msEnd of dependency graphCircuit state created[info] [0.001] SEED 1536679256727Print during simulation: Input is 3Print during simulation: IO is Bundle(in -&gt; 3, out -&gt; 3)Print during simulation: Input is 3Print during simulation: IO is Bundle(in -&gt; 3, out -&gt; 3)Print during simulation: Input is 3Print during simulation: IO is Bundle(in -&gt; 3, out -&gt; 3)Print during simulation: Input is 3Print during simulation: IO is Bundle(in -&gt; 3, out -&gt; 3)Print during simulation: Input is 3Print during simulation: IO is Bundle(in -&gt; 3, out -&gt; 3)[info] [0.007] Print during testing: Input is 3test cmd2WrapperHelperPrintingModule Success: 0 tests passed in 10 cycles taking 0.033230 seconds[info] [0.008] RAN 5 CYCLES PASSED 数字组合逻辑电路多路选择与级联12345678910111213141516171819class MyOperatorsTwo extends Module &#123; val io = IO(new Bundle &#123; val in = Input(UInt(4.W)) val out_mux = Output(UInt(4.W)) val out_cat = Output(UInt(4.W)) &#125;) val s = true.B io.out_mux := Mux(s, 3.U, 0.U) // should return 3.U, since s is true io.out_cat := Cat(2.U, 1.U) // concatenates 2 (b10) with 1 (b1) to give 5 (101)&#125;println(getVerilog(new MyOperatorsTwo))class MyOperatorsTwoTester(c: MyOperatorsTwo) extends PeekPokeTester(c) &#123; expect(c.io.out_mux, 3) expect(c.io.out_cat, 5)&#125;assert(Driver(() =&gt; new MyOperatorsTwo) &#123;c =&gt; new MyOperatorsTwoTester(c)&#125;)println(\"SUCCESS!!\") Chisel内置了Mux和Cat运算符，Mux使用起来就像是C语言中的三元运算符，Cat的级联方式是：先MSB后LSB，并且一次运算只能操作两个参数 MAC（乘加）运算12345678910111213141516171819202122232425class MAC extends Module &#123; val io = IO(new Bundle &#123; val in_a = Input(UInt(4.W)) val in_b = Input(UInt(4.W)) val in_c = Input(UInt(4.W)) val out = Output(UInt(8.W)) &#125;) io.out := io.in_a * io.in_b + io.in_c&#125;class MACTester(c: MAC) extends PeekPokeTester(c) &#123; val cycles = 100 import scala.util.Random for (i &lt;- 0 until cycles) &#123; val in_a = Random.nextInt(16) val in_b = Random.nextInt(16) val in_c = Random.nextInt(16) poke(c.io.in_a, in_a) poke(c.io.in_b, in_b) poke(c.io.in_c, in_c) expect(c.io.out, in_a*in_b+in_c) &#125;&#125;assert(Driver(() =&gt; new MAC) &#123;c =&gt; new MACTester(c)&#125;)println(\"SUCCESS!!\") 条件控制when , elsewhen, otherwise1234567891011121314151617181920212223242526272829303132333435363738// Max3 returns the max of its 3 argumentsclass Max3 extends Module &#123; val io = IO(new Bundle &#123; val in1 = Input(UInt(16.W)) val in2 = Input(UInt(16.W)) val in3 = Input(UInt(16.W)) val out = Output(UInt(16.W)) &#125;) when(io.in1 &gt; io.in2 &amp;&amp; io.in1 &gt; io.in3) &#123; io.out := io.in1 &#125;.elsewhen(io.in2 &gt; io.in1 &amp;&amp; io.in2 &gt; io.in3) &#123; io.out := io.in2 &#125;.otherwise &#123; io.out := io.in3 &#125;&#125;// verify that the max of the three inputs is correctclass Max3Tester(c: Max3) extends PeekPokeTester(c) &#123; poke(c.io.in1, 6) poke(c.io.in2, 4) poke(c.io.in3, 2) expect(c.io.out, 6) // input 1 should be biggest poke(c.io.in2, 7) expect(c.io.out, 7) // now input 2 is poke(c.io.in3, 11) expect(c.io.out, 11) // and now input 3 poke(c.io.in3, 3) expect(c.io.out, 7) // show that decreasing an input works as well&#125;// Test Max3val works = Driver(() =&gt; new Max3) &#123; c =&gt; new Max3Tester(c)&#125;assert(works) // Scala Code: if works == false, will throw an errorprintln(\"SUCCESS!!\") // Scala Code: if we get here, our tests passed! 不同于Scala中的if语句，Chisel中的when语句不会有返回值 wire构造器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** Sort4 sorts its 4 inputs to its 4 outputs */class Sort4 extends Module &#123; val io = IO(new Bundle &#123; val in0 = Input(UInt(16.W)) val in1 = Input(UInt(16.W)) val in2 = Input(UInt(16.W)) val in3 = Input(UInt(16.W)) val out0 = Output(UInt(16.W)) val out1 = Output(UInt(16.W)) val out2 = Output(UInt(16.W)) val out3 = Output(UInt(16.W)) &#125;) val row10 = Wire(UInt(16.W)) val row11 = Wire(UInt(16.W)) val row12 = Wire(UInt(16.W)) val row13 = Wire(UInt(16.W)) when(io.in0 &lt; io.in1) &#123; row10 := io.in0 // preserve first two elements row11 := io.in1 &#125;.otherwise &#123; row10 := io.in1 // swap first two elements row11 := io.in0 &#125; when(io.in2 &lt; io.in3) &#123; row12 := io.in2 // preserve last two elements row13 := io.in3 &#125;.otherwise &#123; row12 := io.in3 // swap last two elements row13 := io.in2 &#125; val row21 = Wire(UInt(16.W)) val row22 = Wire(UInt(16.W)) when(row11 &lt; row12) &#123; row21 := row11 // preserve middle 2 elements row22 := row12 &#125;.otherwise &#123; row21 := row12 // swap middle two elements row22 := row11 &#125; val row20 = Wire(UInt(16.W)) val row23 = Wire(UInt(16.W)) when(row10 &lt; row13) &#123; row20 := row10 // preserve middle 2 elements row23 := row13 &#125;.otherwise &#123; row20 := row13 // swap middle two elements row23 := row10 &#125; when(row20 &lt; row21) &#123; io.out0 := row20 // preserve first two elements io.out1 := row21 &#125;.otherwise &#123; io.out0 := row21 // swap first two elements io.out1 := row20 &#125; when(row22 &lt; row23) &#123; io.out2 := row22 // preserve first two elements io.out3 := row23 &#125;.otherwise &#123; io.out2 := row23 // swap first two elements io.out3 := row22 &#125;&#125;// verify the all possible ordering of 4 numbers are sortedclass BetterSort4Tester(c: Sort4) extends PeekPokeTester(c) &#123; List(1, 2, 3, 4).permutations.foreach &#123; case i0 :: i1 :: i2 :: i3 :: Nil =&gt; println(s\"Sorting $i0 $i1 $i2 $i3\") poke(c.io.in0, i0) poke(c.io.in1, i1) poke(c.io.in2, i2) poke(c.io.in3, i3) expect(c.io.out0, 1) expect(c.io.out1, 2) expect(c.io.out2, 3) expect(c.io.out3, 4) &#125;&#125;// Here's the testerval works = iotesters.Driver(() =&gt; new Sort4) &#123;c =&gt; new BetterSort4Tester(c)&#125;assert(works) // Scala Code: if works == false, will throw an errorprintln(\"SUCCESS!!\") // Scala Code: if we get here, our tests passed! 参考文献 Chisel3 Wiki Chisel3 教程 Chisel3 工程模板 Chisel3 API查询 Chisel3 小抄","tags":[{"name":"Chisel","slug":"Chisel","permalink":"https://suda-morris.github.io/tags/Chisel/"}]},{"title":"LwIP Introduction---Based on ESP32","date":"2018-07-30T05:20:23.000Z","path":"2018/07/30/lwip/","text":"TCP/IP协议栈 TCP/IP协议栈 LwIP架构 LwIP架构 进程模型 进程模型是指TCP/IP协议栈的各协议入IP协议、TCP协议、ICMP协议等是如何实现的。 TCP/IP协议栈的每个协议都通过一个不同的进程实现。在该模型下，每个进程都严格地与一个协议相对应。这种进程模型的优点是网络协议的每一层都很清晰，每一层都可以随时参与系统运行。该模型的缺点是进程间的上下文切换比较频繁，系统将为频繁的上下文切换付出较大的代价。 TCP/IP协议栈驻留在操作系统的内核中，应用程序通过系统调用与TCP/IP协议栈通信。该模型下，各协议栈并非严格地与一个进程相对应。 TCP/IP协议栈驻留在同一个进程中，独立于操作系统内核空间。LwIP采用正是这种方式，LwIP作为一个独立的进程，运行在用户空间内，其优点是可以方便地移植到不同的操作系统中运行。 内存管理 LwIP的动态内存管理机制大致上可以分成三种：标准C运行库自带的内存分配策略、LwIP的动态内存堆分配策略、LwIP的动态内存池分配策略。 LwIP内存管理 将MEM_LIBC_MALLOC设置为1，表明使用标准C库自带的内存分配策略 将MEMP_MEM_MALLOC设置为1，表明使用LwIP自己的动态内存堆分配策略 LwIP还支持内存池，不过在ESP-IDF中并没有被使能。相较于内存堆的动态分配，内存池效率更高，碎片少，但是会消耗更多的内存 缓冲管理 LwIP的缓冲管理机制的功能是尽量避免内存拷贝，尽量较少对内存和空间的需求，提高程序的执行效率。LwIP使用数据结构pbuf来描述内存的缓冲数据包。 pbuf结构体 由于实际发送或接收的数据包长度不一，而每个pbuf只能管理一部分数据，因此对于大容量的数据包，就必须使用多个pbuf才能完整地描述它 type表明了该pbuf的类型，目前LwIP定义了四种类型的pbuf，分别是：PBUF_RAM，PBUF_ROM，PBUF_REF，PBUF_POOL pbuf类型定义 PBUF_RAM类型的pbuf是通过内存堆分配得到的，LwIP协议栈和应用程序要传递的数据一般都使用该类型的pbuf。 PBUF_POOL类型的pbuf是通过内存池分配得到的，由于分配此类型的pbuf可以快速完成，适合中断处理，因此它更多地应用在网络设备驱动层。 PBUF_REF和PBUF_ROM类型的pbuf基本相同，他们都是从内存池中申请分配pbuf结构首部空间，而不申请数据区的空间。两者的区别在于，前者指向RAM空间内的某段数据，后者指向ROM空间内的某段数据。 pbuf结构 pbuf管理API 当使用Netconn API时，则使用netbuf（网络缓冲）发送/接收数据，netbuf只是pbuf结构的封装，它可容纳分配的或引用的数据。 pbuf管理API 网络接口层 在LwIP中，物理网络硬件的设备驱动通过网络接口结构体netif来描述一个硬件网络接口，并通过netif_add函数向全局变量netif链表结构增加一个硬件网络接口。 网络接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153/** Generic data structure used for all lwIP network interfaces. * The following fields should be filled in by the initialization * function for the device driver: hwaddr_len, hwaddr[], mtu, flags */struct netif &#123; /** pointer to next in linked list */ struct netif *next;#if LWIP_IPV4 /** IP address configuration in network byte order */ ip_addr_t ip_addr; ip_addr_t netmask; ip_addr_t gw;#endif /* LWIP_IPV4 */#if LWIP_IPV6 /** Array of IPv6 addresses for this netif. */ ip_addr_t ip6_addr[LWIP_IPV6_NUM_ADDRESSES]; /** The state of each IPv6 address (Tentative, Preferred, etc). * @see ip6_addr.h */ u8_t ip6_addr_state[LWIP_IPV6_NUM_ADDRESSES];#if ESP_LWIP void (*ipv6_addr_cb)(struct netif* netif, u8_t ip_idex); /* callback for ipv6 addr states changed */#endif#endif /* LWIP_IPV6 */ /** This function is called by the network device driver * to pass a packet up the TCP/IP stack. */ netif_input_fn input;#if LWIP_IPV4 /** This function is called by the IP module when it wants * to send a packet on the interface. This function typically * first resolves the hardware address, then sends the packet. */ netif_output_fn output;#endif /* LWIP_IPV4 */ /** This function is called by the ARP module when it wants * to send a packet on the interface. This function outputs * the pbuf as-is on the link medium. */ netif_linkoutput_fn linkoutput;#if LWIP_IPV6 /** This function is called by the IPv6 module when it wants * to send a packet on the interface. This function typically * first resolves the hardware address, then sends the packet. */ netif_output_ip6_fn output_ip6;#endif /* LWIP_IPV6 */#if LWIP_NETIF_STATUS_CALLBACK /** This function is called when the netif state is set to up or down */ netif_status_callback_fn status_callback;#endif /* LWIP_NETIF_STATUS_CALLBACK */#if LWIP_NETIF_LINK_CALLBACK /** This function is called when the netif link is set to up or down */ netif_status_callback_fn link_callback;#endif /* LWIP_NETIF_LINK_CALLBACK */#if LWIP_NETIF_REMOVE_CALLBACK /** This function is called when the netif has been removed */ netif_status_callback_fn remove_callback;#endif /* LWIP_NETIF_REMOVE_CALLBACK */ /** This field can be set by the device driver and could point * to state information for the device. */ void *state;#if LWIP_DHCP /** the DHCP client state information for this netif */ struct dhcp *dhcp;#if ESP_LWIP struct udp_pcb *dhcps_pcb; dhcp_event_fn dhcp_event;#endif #endif /* LWIP_DHCP */#if LWIP_AUTOIP /** the AutoIP client state information for this netif */ struct autoip *autoip;#endif#if LWIP_IPV6_AUTOCONFIG /** is this netif enabled for IPv6 autoconfiguration */ u8_t ip6_autoconfig_enabled;#endif /* LWIP_IPV6_AUTOCONFIG */#if LWIP_IPV6_SEND_ROUTER_SOLICIT /** Number of Router Solicitation messages that remain to be sent. */ u8_t rs_count;#endif /* LWIP_IPV6_SEND_ROUTER_SOLICIT */#if LWIP_IPV6_DHCP6 /** the DHCPv6 client state information for this netif */ struct dhcp6 *dhcp6;#endif /* LWIP_IPV6_DHCP6 */#if LWIP_NETIF_HOSTNAME /* the hostname for this netif, NULL is a valid value */ const char* hostname;#endif /* LWIP_NETIF_HOSTNAME */#if LWIP_CHECKSUM_CTRL_PER_NETIF u16_t chksum_flags;#endif /* LWIP_CHECKSUM_CTRL_PER_NETIF*/ /** maximum transfer unit (in bytes) */ u16_t mtu; /** number of bytes used in hwaddr */ u8_t hwaddr_len; /** link level hardware address of this interface */ u8_t hwaddr[NETIF_MAX_HWADDR_LEN]; /** flags (see NETIF_FLAG_ above) */ u8_t flags; /** descriptive abbreviation */ char name[2]; /** number of this interface */ u8_t num; #if MIB2_STATS /** link type (from \"snmp_ifType\" enum from snmp_mib2.h) */ u8_t link_type; /** (estimate) link speed */ u32_t link_speed; /** timestamp at last change made (up/down) */ u32_t ts; /** counters */ struct stats_mib2_netif_ctrs mib2_counters;#endif /* MIB2_STATS */#if LWIP_IPV4 &amp;&amp; LWIP_IGMP /** This function could be called to add or delete an entry in the multicast filter table of the ethernet MAC.*/ netif_igmp_mac_filter_fn igmp_mac_filter;#endif /* LWIP_IPV4 &amp;&amp; LWIP_IGMP */#if LWIP_IPV6 &amp;&amp; LWIP_IPV6_MLD /** This function could be called to add or delete an entry in the IPv6 multicast filter table of the ethernet MAC. */ netif_mld_mac_filter_fn mld_mac_filter;#endif /* LWIP_IPV6 &amp;&amp; LWIP_IPV6_MLD */#if LWIP_NETIF_HWADDRHINT u8_t *addr_hint;#endif /* LWIP_NETIF_HWADDRHINT */#if ENABLE_LOOPBACK /* List of packets to be queued for ourselves. */ struct pbuf *loop_first; struct pbuf *loop_last;#if LWIP_LOOPBACK_MAX_PBUFS u16_t loop_cnt_current;#endif /* LWIP_LOOPBACK_MAX_PBUFS */#endif /* ENABLE_LOOPBACK */#if ESP_LWIP void (*l2_buffer_free_notify)(void *user_buf); /* Allows LWIP to notify driver when a L2-supplied pbuf can be freed */ ip_addr_t last_ip_addr; /* Store last non-zero ip address */#endif&#125;; IP信息 ip_addr，netmask，gw分别表示了IP地址、子网掩码、网关，建议这样子设定：IP4_ADDR(&amp;ipaddr,192,168,1,100) 硬件信息 mtu表明最大的网络传输个数，以字节为单位 hwaddr存放了硬件接口的地址，对于以太网而言，就是MAC地址 flags是硬件接口状态信息标志位，如是否建立连接状态，是否允许广播功能等 name用来表示硬件接口使用的驱动类型，缩写，2个字节，比如蓝牙设备为“bl”，wifi设备为”wl” num用来表示硬件接口的编号，当两个硬件接口的name字段相同时，该字段可以用来区分是哪一个硬件接口 驱动功能 input是一个函数指针，它指向的函数用于将网络硬件接口接收到的数据包传递给上层TCP/IP协议栈 output是一个函数指针，它所指向的函数用于将IP层的数据包发送到网络硬件接口上 linkoutput是一个函数指针，在ARP模块中调用，output指向的函数也是通过调用linkoutput指向的函数实现数据报发送的 ARP处理 ARP协议是TCP/IP协议的基础，本质是实现IP地址与底层物理地址的相互转换。ARP协议的核心是ARP缓存表，而ARP协议的实质就是对缓存表的建立、更新、查询等操作。ARP缓存表是由若干缓存表项组成，在LwIP中，描述缓存表项的数据结构叫etharp_entry。 ARP协议数据包格式 1234567891011121314struct etharp_entry &#123;#if ARP_QUEUEING /** Pointer to queue of pending outgoing packets on this ARP entry. */ struct etharp_q_entry *q;#else /* ARP_QUEUEING */ /** Pointer to a single pending outgoing packet on this ARP entry. */ struct pbuf *q;#endif /* ARP_QUEUEING */ ip4_addr_t ipaddr; struct netif *netif; struct eth_addr ethaddr; u16_t ctime; u8_t state;&#125;; ipaddr存放IP地址，ethaddr存放物理地址，state表示缓存项的状态（例如是否为空，是否稳定），ctime记录ARP缓存项处于某个状态的时间，当某表项的ctime值大于规定的表项最大生存值时，LwIP内核会删除该表项。因此使用ARP功能时，必须设置一个ARP超时事件，该超时事件的基本功能就是对每个表项的ctime字段值加1，然后删除那些生存时间大于最大生存值的表项 ARP处理流程 函数ethernet_input根据报文首部的帧类型字段判断接收到的报文类型，如果是IP包，则将该包传递给etharp_ip_input，如果是ARP包，则将该包递交给etharp_arp_input 函数etharp_ip_input调用函数update_arp_entry，它是将报文首部的MAC地址和IP地址更新到ARP缓存中 函数etharp_arp_input首先判断接收到的ARP数据包的类型，如果是ARP请求包，那么首先判断这个包是否是给自己的，如果是给自己的，就在原有包的基础上重组一个ARP应答包发送出去；如果不是给自己的，则直接忽略而如果接收到的数据包是ARP应答包，那么就调用update_arp_entry更新ARP缓存表 IP处理 LwIP软件大致框架 LwIP整体框架图 ip_input会做各项检查，包括协议版本号，IP首部的校验值，源IP地址是否有效等，然后检测IP数据包中的目的IP地址是否与本节点的IP地址相符，如果是本节点的IP地址，则根据该IP数据包首部的协议字段判断该数据包应该被递交到哪个上层协议，并调用相应的函数。如果是UDP协议，则调用udp_input函数；如果是TCP协议，则调用tcp_input函数；如果是ICMP协议，则调用icmp_input函数；如果是IGMP协议，则调用igmp_input函数；如果都不是，则调用函数icmp_dest_unreach返回一个协议不可达ICMP数据包给源主机。如果不是本节点的IP地址，则通过调用函数ip_forward对数据包进行转发。需要注意，由于一个节点可能含有多个IP地址，因此ip_input函数会遍历网络接口链表netif_list上的netif结构变量，来查找与IP数据包中相匹配的IP地址。 ip_output使用ip_route函数查找目标网络接口netif来发送IP数据包。当网络接口netif确定后，IP数据包通过函数ip_output_if发送出去。若ip_route没有找到合适的网络接口，则丢弃该报文，终止本次发送。函数ip_route通过遍历网络接口链表netif_list，查找与目的IIP地址在同一个子网中的网络接口，并将该网络接口返回给变量netif。 ICMP处理 ICMP协议数据包格式 icmp_input在ip_input中被调用，它处理接收到的ICMP数据包，并根据包类型做相应的处理。在LwIP协议栈中，它只处理ICMP回显请求包，对其他类型的ICMP包不作响应。icmp_input在处理ICMP回显请求时，首先判断该数据包是否为广播或者组播包，如果是，则直接返回，不再继续处理；如果不是，则继续判断该数据包长度是否小于ICMP回显请求头部长度，如果是则丢弃数据包；如果不是则将该ICMP报文类型字段变为0，重新计算校验和，并将IP报文首部的源IP地址和目的IP地址交换位置，并通过调用函数ip_output_if将数据包发送出去。 函数icmp_dest_unreach在ip_input、udp_input中被调用，它的功能是通过调用函数icmp_send_response发送一个“目的不可到达”类型的icmp报文。在函数ip_input中，当所接收的IP报文协议字段不可识别时，icmp_dest_unreach就被调用。而在UDP处理器中，若不能找到与接收的报文相对应的端口号，则icmp_dest_unreach也将被调用。 函数icmp_time_exceeded在ip_forward中被调用，它的功能是通过调用函数icmp_send_response发送一个“超时”类型的ICMP报文。在函数ip_forward中，当TTL减小为0时，调用该函数。 UDP处理 UDP协议数据包 函数udp_input将检查报文的UDP校验，最终调用函数recv，将收到的报文传递给应用层程序 当应用层程序要通过UDP协议向外发送IP报文时，将通过调用函数udp_send实现，函数udp_send通过调用IP层的函数ip_output_if实现报文的发送 LwIP使用链表结构体udp_pcb来保存每一个UDP会话的状态 1234567891011121314151617181920212223242526272829struct udp_pcb &#123;/* Common members of all PCB types */ IP_PCB;/* Protocol specific PCB members */ struct udp_pcb *next; u8_t flags; /** ports are in host byte order */ u16_t local_port, remote_port;#if LWIP_MULTICAST_TX_OPTIONS /** outgoing network interface for multicast packets */ ip_addr_t multicast_ip; /** TTL for outgoing multicast packets */ u8_t mcast_ttl;#endif /* LWIP_MULTICAST_TX_OPTIONS */#if LWIP_UDPLITE /** used for UDP_LITE only */ u16_t chksum_len_rx, chksum_len_tx;#endif /* LWIP_UDPLITE */ /** receive callback function */ udp_recv_fn recv; /** user-supplied argument for the recv callback */ void *recv_arg;&#125;; TCP处理 TCP协议数据包 TCP的滑动窗口协议是用于实现流量控制的 TCP的超时和重传机制提高了数据传输的可靠性 拥塞控制是通过慢启动算法和拥塞避免算法来实现的 LwIP中含有两个定时器函数：tcp_fasttmr和tcp_slowtmr，tcp_fasttmr每250ms调用一次，tcp_slowtmr每500ms调用一次。快速定时器主要做两个方面的事情：向上层递交上层一直未接收的数据，二是发送该连接上的延迟ACK请求数据段。慢速定时器参与了较多功能，如超时与重传、拥塞控制等。 常用API接口 LwIP提供了3种应用程序接口： 直接调用协议栈各模块的函数，它是基于回调函数的API接口，也成为RAW API接口，回调函数直接被协议栈代码调用，因此应用程序代码和TCP/IP协议栈运行在同一个进程里，无需使用操作系统，两者之间这种良好的结合可以使得程序的执行效率更高，而且在运行中它占用更少的内存资源 使用LwIP提供的专用API接口，也称为Sequential API接口，程序的执行过程基于open-read-write-close模型，需要操作系统的支持，另外需要在文件lwipopts.h中把宏定义NO_SYS定义为0。Sequential API被分成两部分实现，一部分驻留在应用程序进程中，另一部分在TCP/IP协议栈进程内实现。这两部分API之间采用由操作系统模拟层提供的进程间通信机制进行通信。在LwIP中，操作系统模拟层是LwIP协议栈的一部分，它存在的目的是方面LwIP的移植，它在底层操作系统和LwIP协议栈之间提供了一个接口，当用户移植LwIP到一个新的目标系统的时候，只需要修改这个接口内的函数即可。驻留在应用程序进程中的API接口与TCP/IP协议栈进程中的API之间通过共享内存传递数据，对该共享内存区的描述是采用netbuf结构体 BSD Socket兼容的Socket函数接口，但是BSD套接字需要将发送的数据从应用程序复制到TCP/IP协议栈的内部缓冲区，将会消耗系统有限的资源 TCP RAW API TCP RAW API 函数 说明 struct tcp_pcb* tcp_new() 新建tcp协议控制块 ert_t tcp_bind(struct tcp_pcb pcb,struct ip_addr ipaddr,u16_t port) 绑定本地IP地址和端口号，如果ipaddr为IP_ADDR_ANY，则将连接绑定到所有的本地IP地址上 struct tcp_pcb tcp_listen(struct tcp_pcb pcb) 使指定的连接开始进入监听状态，如果监听成功，就返回一个新的连接控制块pcb void tcp_accepted(struct tcp_pcb* pcb) 通知LwIP一个新来的连接已经被接收，这个函数通常在由tcp_accept指定的回调函数中被调用 void tcp_accept(struct tcp_pcb* pcb,err_t (*accept)(void* arg,struct tcp_pcb* newpcb,err_t err)) 指定处于监听状态的连接，在成功建立连接后要调用的回调方法 err_t tcp_connect(struct tcp_pcb* pcb,struct ip_addr* ipaddr,u16_t port,err_t (* connected)(void* arg,struct tcp_pcb* tpcb,err_t err)) 请求连接到执行的远程主机 err_t tcp_write(struct tcp_pcb* pcb,void* dataptr,u16_t len,u8_t copy) 发送TCP数据，将要发送的数据放入发送队列中，由协议栈内核发送，copy为0则不会为发送的数据分配新的内存空间 void tcp_sent(struct tcp_pcb* pcb,err_t (*sent)(void* arg,struct tcp_pcb* tpcb,u16_t len)) 指定当远程主机成功接收数据后，应用程序调用的回调函数 void tcp_recv(struct tcp_pcb* pcb,err_t (* recv)(void* arg,struct tcp_pcb* tpcb,struct pbuf* p,err_t err)) 指定接收数据时调用的回调函数 void tcp_recved(struct tcp_pcb* pcb,u16_t len) 用于获取接收到的数据的长度，必须在tcp_recv指定的回调函数中被调用 err_t tcp_close(struct tcp_pcb* pcb) 关闭一个指定的TCP连接，调用该函数后将会释放pcb控制块所占用的内存空间 void tcp_abort(struct tcp_pcb* pcb) 终止一个指定的连接，调用该函数后，pcb控制块所占用的内存空间将被释放 void tcp_err(struct tcp_pcb* pcb,void (*err)(void* arg,err_t err)) 指定处理错误的回调函数 TCP RAW API UDP RAW API Netconn API 数据结构netconn描述了应用程序要使用API函数机那里一个连接的各种属性，包括了连接的类型、最近的故障代码、回调函数等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** A netconn descriptor */struct netconn &#123; /** type of the netconn (TCP, UDP or RAW) */ enum netconn_type type; /** current state of the netconn */ enum netconn_state state; /** the lwIP internal protocol control block */ union &#123; struct ip_pcb *ip; struct tcp_pcb *tcp; struct udp_pcb *udp; struct raw_pcb *raw; &#125; pcb; /** the last error this netconn had */ err_t last_err; #if !LWIP_NETCONN_SEM_PER_THREAD /** sem that is used to synchronously execute functions in the core context */ sys_sem_t op_completed;#endif /** mbox where received packets are stored until they are fetched by the netconn application thread (can grow quite big) */ sys_mbox_t recvmbox;#if LWIP_TCP /** mbox where new connections are stored until processed by the application thread */ sys_mbox_t acceptmbox;#endif /* LWIP_TCP */ /** only used for socket layer */#if LWIP_SOCKET int socket;#endif /* LWIP_SOCKET */#if LWIP_SO_SNDTIMEO /** timeout to wait for sending data (which means enqueueing data for sending in internal buffers) in milliseconds */ s32_t send_timeout;#endif /* LWIP_SO_RCVTIMEO */#if LWIP_SO_RCVTIMEO /** timeout in milliseconds to wait for new data to be received (or connections to arrive for listening netconns) */ int recv_timeout;#endif /* LWIP_SO_RCVTIMEO */#if LWIP_SO_RCVBUF /** maximum amount of bytes queued in recvmbox not used for TCP: adjust TCP_WND instead! */ int recv_bufsize; /** number of bytes currently in recvmbox to be received, tested against recv_bufsize to limit bytes on recvmbox for UDP and RAW, used for FIONREAD */ int recv_avail;#endif /* LWIP_SO_RCVBUF */#if LWIP_SO_LINGER /** values &lt;0 mean linger is disabled, values &gt; 0 are seconds to linger */ s16_t linger;#endif /* LWIP_SO_LINGER */ /** flags holding more netconn-internal state, see NETCONN_FLAG_* defines */ u8_t flags;#if LWIP_TCP /** TCP: when data passed to netconn_write doesn't fit into the send buffer, this temporarily stores how much is already sent. */ size_t write_offset; /** TCP: when data passed to netconn_write doesn't fit into the send buffer, this temporarily stores the message. Also used during connect and close. */ struct api_msg_msg *current_msg;#endif /* LWIP_TCP */ /** A callback function that is informed about events for this netconn */ netconn_callback callback;&#125;; Netconn API 函数 说明 struct netconn* netconn_new_with_proto_and_callback(enum netconn_type t,u8_t proto,netconn_callback callback) 建立一个新的netconn连接 err_t netconn_delete(struct netconn* conn) 删除netconn所指向的连接 err_t netconn_getaddr(struct netconn* conn,struct ip_addr* addr,u16_t* port,u8_t local) 获取conn连接的主机IP地址和端口号 err_t netconn_bind(struct netconn* conn,struct ip_addr* addr,u16_t port) 将一个IP地址及端口号与conn指向的而连接绑定 err_t netconn_connect(struct netconn* conn,struct ip_addr* addr,u16_t port) 将服务器端的IP地址和端口号与conn指向的连接绑定 err_t netconn_disconnect(struct netconn* conn) 断开conn指向的连接 err_t netconn_listen_with_backlog(struct netconn* conn，u8_t backlog) 将conn指向的连接设定为监听状态 struct netconn* netconn_accept(struct netconn* conn) 接收客户端的连接，该函数会阻塞在acceptmbox邮箱上 struct netbuf* netconn_recv(struct netconn* conn) 接收数据，接收到的数据被封装为netbuf结构 err_t netconn_sendto(struct netconn* conn,struct netbuf* buf,struct ip_addr* addr,u16_t port) 向一个指定的IP地址和端口号发送数据，这个函数只能用在conn类型为UDP或者RAW的连接中 err_t netconn_write(struct netconn* conn,const void* dataptr,size_t size,u8_t apiflag) 向相应的TCP连接上发送数据，这个函数只能用于发送TCP的报文 err_t nnetconn_close(struct netconn* conn) 关闭conn指向的连接 netconn_new_with_proto_and_callback首先调用netconn_alloc函数分配并初始化一个netconn结构，接下来该函数会构建一个api_msg消息，该消息要求内核执行函数do_newconn，最后调用函数tcpip_apimsg来将消息包装成tcpip_msg结构并发送出去。tcpip_thread函数解析该消息并调用函数do_newconn，do_newconn根据参数的类型调用函数tcp_new创建一个TCP控制块 tcpip_thread是处理TCP/IP的内核协议栈进程，它只接收tcpip_msg结构封装的消息，并根据消息的类型来判定该消息来自物理网卡或应用层程序。如果接收到网卡的IP报文，则将该报文递交给ip_input函数；如果是应用层程序发送的消息，则通过调用消息指定的内核处理函数来完成相应的功能 Socket API LwIP提供了标准BSD套接字API，它也是有序API，在内存构建于Netconn API之上。所谓“有序”是指其执行模型基于典型的阻塞式打开-读-写-关闭机制。 Socket API LwIP移植 以太网接口任务用于接收来自物理网卡的数据报文，同时将收到的报文通过FreeRTOS提供的邮箱传递给TCP/IP协议栈任务。以太网接口任务平时处于挂起状态，当硬件收到报文时，将产生接收报文中断，该终端以信号量的方式将以太网接口任务激活 应用程序使用TCP/IP协议栈提供的Sequential API接口访问LwIP，同时这两个独立的任务需要使用FreeRTOS提供的邮箱机制实现彼此之间信息的交互。Sequential API接口函数在FreeRTOS操作系统运行环境下是“阻塞”函数，也就是说应用程序任务在调用Sequential API接口函数时，将会被阻塞，直到收到来自TCP/IP协议栈返回的消息应答 基于LwIP的TCP/IP协议栈与应用程序运行在两个独立的任务中 网卡驱动移植 以太网接口文件ethernetif.c的移植，主要包含ethernet_low_level_init，ethernet_low_level_output，ethernetif_input，ethernetif_init这几个函数的功能 ethernetif_input函数用于从底层物理网卡读取报文，并将该报文向上传递给LwIP协议栈函数ethernet_input进行处理 ethernetif_init函数指定了网络接口netif对应的主机名及网卡描述，并指定了该网卡的MAC地址，同事还指定了netif的发送数据报文函数 操作系统模拟层文件sys_arch.c的移植，总的来时操作系统模拟层主要完成了与信号量、消息邮箱机制、线程相关的功能 在sys_arch.h文件中对信号量、邮箱、线程对象进行重定义 sys_mbox_new函数，使用FreeRTOS提供的消息队列机制创建一个空的消息队列 sys_mbox_free函数，删除一个队列，当该队列中还有未被取出的消息时，该函数应当报错，并通知应用程序 sys_mbox_post函数，将消息发送到消息队列中，该函数是一个阻塞函数，当消息被发送至队列后，该函数才会退出阻塞状态 sys_mbox_trypost函数，用于尝试将某个消息发送至消息队列中，当消息被成功投递后，则返回成功，否则返回失败 sys_arch_mbox_fetch函数，用于从消息队列中取出一条消息，该函数是一个阻塞函数，调用该函数的线程若未取到消息，则在形参timeout所指定的时间内，该线程被阻塞。当超过timeout所指定的时间后，该线程恢复至就绪状态。若timeout为0，则调用该函数的线程一直被阻塞，直到收到消息 sys_arch_mbox_tryfetch函数尝试从消息队列中取出消息，它是一个非阻塞函数，当取到消息时，则返回成功，否则立即退出，返回队列空 sys_sem_new函数创建一个信号量，并根据形参的值指定好当前信号量的状态 sys_arch_sem_wait函数在形参timeout指定的时间被阻塞，若timeout为0，则调用该函数的线程将一直被阻塞，直到等待的信号量被释放。但该函数取到信号量时，它将返回取到的该信号量所占的时间 sys_sem_signal函数用于释放一个信号量 sys_sem_free函数用于删除一个信号量 sys_thread_new函数用于创建一个新的线程 sys_init函数是操作系统模拟层的初始化函数，主要对定时器管理数组进行了初始化 sys_zrch_timeouts函数用于返回当前任务的定时器管理链表首地址 sys_arch_protect函数和sys_arch_unprotect函数在访问临界区资源时成对使用 ethernet_input函数的实现在独立模式和RTOS模式时是不同的： 在独立应用中，此函数必须被插入到应用的主循环中，以便轮询任何收到的包 在RTOS应用中，此函数为一个阻塞线程，只有当得到所等待的信号量时才处理接收到的数据包。当以太网外设收到数据并产生中断时，会在中断处理函数中释放此信号量 LwIP配置 LwIP提供了名为lwipopts.h的文件，它允许用户充分配置栈及其所有模块。用户不需要定义所有LwIP选项：如果未定义某选项，则使用opt.h文件中定义的默认值 内存配置 LwIP内存配置","tags":[{"name":"LwIP","slug":"LwIP","permalink":"https://suda-morris.github.io/tags/LwIP/"}]},{"title":"ESP32 介绍","date":"2018-07-05T01:48:00.000Z","path":"2018/07/05/esp32/","text":"ESP32关键特征简介 双核CPU，集成WiFi(802.11bgn)和双模蓝牙(经典蓝牙+蓝牙BLE) CPU最高主频240MHz(600MIPS)，内部集成8MHz的高速振荡器和低速RC谐振器(通常是150KHz，可调) CPU支持DSP指令，包括32比特的乘法，32比特的除法和40比特的MAC（乘加操作） 支持32个中断向量 448 kB ROM（存放启动代码和核心功能函数），520 kB SRAM（存放指令和数据），16 kB SRAM in RTC（包括8kB的快速内存和8kB的慢速内存，快速内存可以用来保存数据，主CPU从Deepsleep模式唤醒时候会访问这块内存；慢速内存在Deep-sleep模式下由RTC协处理器访问） 1kbit的熔丝位，其中256比特用于配置系统的MAC地址和芯片的相关设定，剩余部分供用户保存flash秘钥，芯片ID等 支持片外SPI接口的Flash和SRAM 两组定时器，每组包括两个64位的常规定时器和1个看门狗定时器 一个RTC定时器和RTC看门狗 34个GPIO 18通道的SAR ADC（12比特） 2个8比特DAC 10路电容触摸传感器 4个SPI接口，2个I2S接口，2个I2C接口，3个UART接口 1个SDIO主控制器，1个SDIO从控制器 一路以太网MAC(包括专用DMA，支持1588协议) 一路CAN2.0 一路红外收发器 电机PWM 16通道LED PWM调试器 霍尔传感器 秘钥加密加速(AES，SHA-2，RSA，ECC) 随机数发生器 ESP32芯片内部框图 ESP32 Strapping 引脚配置 strapping引脚配置 ESP32 内存映射 内存映射 ESP32可以通过高速缓存来访问片外的QSPI Flash，最高16MB的外部Flash可以被映射到CPU的指令内存空间和只读空间。如果映射到指令空间，一次最多可以映射11MB+248KB（超过3MB+24KB后，cache的性能会下降）；如果映射到只读空间，一次最对可以映射4MB，并且支持8bit、16bit和32bit的读操作 ESP32可以通过高速缓存来访问片外的QSPI SRAM，最高8MB的外部SRAM可以被映射到CPU的数据空间，并且一次最多可以映射4MB，支持8bit、16bit和32bit的读写操作 ESP32内存映射表 ESP32的低功耗管理 低功耗模式 ESP32 GPIO-MUX GPIO-MUX ESP32系统时钟 系统时钟结构 外设支持的时钟源","tags":[{"name":"ESP32","slug":"ESP32","permalink":"https://suda-morris.github.io/tags/ESP32/"}]},{"title":"FreeRTOS Introduction---Based on ESP32","date":"2018-05-30T12:56:00.000Z","path":"2018/05/30/freertos/","text":"FreeRTOS系统配置 FreeRTOS的系统配置文件为FreeRTOSConfig.h，在此配置文件中可以完成FreeRTOS的裁剪和配置。FreeRTOS中的裁剪和配置使用条件编译的方式来实现。 “INCLUDE_”开始的宏，用来表示使能或者失能FreeRTOS中的相应API函数，比如INCLUDE_vTaskPrioritySet用来决定是否可以使用vTaskPrioritySet函数 “config”开始的宏也用来对FreeRTOS的进行裁剪和配置，比如 configAPPLICATION_ALLOCATED_HEAP宏，如果不开启，那么FreeRTOS的堆内存由编译器分配，开启后，堆内存将由用户自行设置 configASSERT设置 configCHECK_FOR_STACK_OVERFLOW宏如果不为零，用户必须提供一个钩子函数vApplicationStackOverflowHook PEB4SS.png 当堆栈溢出太严重时可能会损毁该函数的两个参数，这时可以通过查看变量pxCurrentTCB来确定哪个任务发生了堆栈溢出 vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB[ xPortGetCoreID() ], pxCurrentTCB[ xPortGetCoreID() ]-&gt;pcTaskName ); 堆栈溢出有两种检测方法： 方法1：上下文切换的时候需要保存现场，现场是保存在堆栈中的，这个时候任务堆栈使用率很可能达到最大值，方法1就是不断检测任务堆栈指针是否指向有效空间，如果指向了无效空间，则调用钩子函数。该方法的特点是快，缺点是不能检测所有的堆栈溢出 方法2：在创建任务的时候向任务堆栈填充一个已知的标记值，然后检测堆栈后面的几个字节是否被改写，如果被改写，则调用钩子函数，方法2几乎能够检测到所有的堆栈溢出 configMAX_PRIORITIES设置任务的优先级数量，设置好后任务就可以使用从0～configMAX_PRIORITIES-1的优先级，其中0是最低优先级 PEsHwd.png configMINIMAL_STACK_SIZE设置空闲任务的最小任务堆栈大小，以字为单位 PEyFkn.png configTOTAL_HEAP_SIZE设置堆的大小，如果使用了动态内存管理，则FreeRTOS在创建任务、信号量、队列等的时候就会从用户指定的内存中获取空间 PEyUne.png configKERNEL_INTERRUPT_PRIORITY设置了内核中断系统中systick中断的优先级(FreeRTOS中systick的中断优先级是最低的) PEv1LF.png configMAX_SYSCALL_INTERRUPT_PRIORITY设置了FreeRTOS系统可管理的最大优先级，这里实际值为3，高于此优先级的中断是不会被FreeRTOS内核屏蔽的，对实时性要求严格的任务就可以使用这些优先级，中断服务函数也不能调用FreeRTOS的API函数；低于（包括本身）此优先级的中断可以安全地调用以FromISR结尾的API函数 PExpTJ.png FreeRTOS中的Task 任务控制块 xTaskCreate()创建任务的时候，会自动给每个任务分配一个任务控制块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* * Task control block. A task control block (TCB) is allocated for each task, * and stores task state information, including a pointer to the task's context * (the task's run time environment, including register values) */typedef struct tskTaskControlBlock&#123; volatile StackType_t *pxTopOfStack; //任务堆栈栈顶 #if ( portUSING_MPU_WRAPPERS == 1 ) xMPU_SETTINGS xMPUSettings; //MPU相关的设置 #endif ListItem_t xGenericListItem; //状态列表项 ListItem_t xEventListItem; //事件列表项 UBaseType_t uxPriority; //任务优先级 StackType_t *pxStack; //任务堆栈起始地址 char pcTaskName[ configMAX_TASK_NAME_LEN ];//任务名字 BaseType_t xCoreID; //执行任务的处理器核ID #if ( portSTACK_GROWTH &gt; 0 || configENABLE_TASK_SNAPSHOT == 1 ) StackType_t *pxEndOfStack; //任务堆栈栈底 #endif #if ( portCRITICAL_NESTING_IN_TCB == 1 ) UBaseType_t uxCriticalNesting; //临界区嵌套深度 uint32_t uxOldInterruptState; /*&lt; Interrupt state before the outer taskEnterCritical was called */ #endif #if ( configUSE_TRACE_FACILITY == 1 ) UBaseType_t uxTCBNumber; /*&lt; Stores a number that increments each time a TCB is created. It allows debuggers to determine when a task has been deleted and then recreated. */ UBaseType_t uxTaskNumber; /*&lt; Stores a number specifically for use by third party trace code. */ #endif #if ( configUSE_MUTEXES == 1 ) UBaseType_t uxBasePriority; //任务基础优先级 UBaseType_t uxMutexesHeld; //任务获取到的互斥信号量个数 #endif #if ( configUSE_APPLICATION_TASK_TAG == 1 ) TaskHookFunction_t pxTaskTag; #endif #if( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 ) void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ]; #if ( configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS ) TlsDeleteCallbackFunction_t pvThreadLocalStoragePointersDelCallback[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ]; #endif #endif #if ( configGENERATE_RUN_TIME_STATS == 1 ) uint32_t ulRunTimeCounter; //记录任务运行总时间 #endif #if ( configUSE_NEWLIB_REENTRANT == 1 ) /* Allocate a Newlib reent structure that is specific to this task. Note Newlib support has been included by popular demand, but is not used by the FreeRTOS maintainers themselves. FreeRTOS is not responsible for resulting newlib operation. User must be familiar with newlib and must provide system-wide implementations of the necessary stubs. Be warned that (at the time of writing) the current newlib design implements a system-wide malloc() that must be provided with locks. */ struct _reent xNewLib_reent; #endif #if ( configUSE_TASK_NOTIFICATIONS == 1 ) volatile uint32_t ulNotifiedValue; //任务通知值 volatile eNotifyValue eNotifyState; //任务通知状态 #endif /* See the comments above the definition of tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */ #if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) uint8_t ucStaticallyAllocated; //如果任务是静态创建的，该变量就为pdTRUE #endif&#125; tskTCB;typedef tskTCB TCB_t; 任务堆栈 任务调度器在进行任务切换的时候，会将当前任务的现场(CPU寄存器值等等)保存在此任务的任务堆栈中；此任务下次运行的时候就会先用堆栈中保存的值来恢复现场，之后任务就会接着从上次中断的地方开始运行。使用动态的方法创建任务时，任务堆栈会自动创建；使用静态的方法创建任务时，任务堆栈需要用户自行定义。任务堆栈的数据类型为StackType_t，其大小为4字节，所以动态创建的任务，其堆栈大小是传入数值4倍 12#define portSTACK_TYPE uint32_ttypedef portSTACK_TYPE StackType_t 尾调用 调度任务创建和删除API函数 函数 描述 xTaskCreate() 使用动态的方法创建一个任务 xTaskCreateStatic() 使用静态的方法创建一个任务 xTaskCreateRestricted() 创建一个使用MPU进行限制的任务，相关内存使用动态内存分配 vTaskDelete() 删除一个任务 任务挂起和恢复API函数 函数 描述 vTaskSuspend() 挂起一个任务，传入某个任务的句柄，NULL表示当前任务 vTaskResume() 恢复一个任务的运行 xTaskResumeFromISR() 中断服务函数中恢复一个任务的运行。返回pdTRUE表示恢复运行的任务的优先级等于或者高于正在运行的任务（被中断打断的任务），这意味着在退出中断服务函数的时候必须进行一次上下文切换（调用portYIELD_FROM_ISR）。返回pdFALSE表示恢复运行的任务的优先级低于当前正在运行的任务（被中断打断的任务），这意味着在退出中断服务函数的以后不需要进行上下文切换 其他常用API函数(部分函数需要在配置文件中开启相关的宏) 函数 描述 xTaskGetHandle() 根据任务名字获取某个任务的任务句柄 vTaskStartScheduler() 开启任务调度 vTaskSuspendAll() 挂起任务调度器，支持嵌套 vTaskResumeAll() 恢复调度器 vTaskDelay() 任务延时，单位是时钟节拍 uxTaskPriorityGet() 获取指定任务的优先级 vTaskPrioritySet() 改变一个任务的任务优先级 uxTaskGetSystemState() 获取系统中所有任务的任务状态 vTaskGetInfo() 获取单个任务的状态 xTaskGetCurrentTaskHandle() 获取当前任务的任务句柄 xTaskGetHandle() 根据任务名字获取任务的任务句柄 xTaskGetIdleTaskHandle() 返回空闲任务的任务句柄 uxTaskGetStackHighWaterMark() 检查任务从创建好到现在的历史剩余最小值，FreeRTOS把这个历史剩余最小值叫“高水位线” eTaskGetState() 查询某个任务的运行状态 pcTaskGetName() 根据某个任务的任务句柄来查询这个任务对应的任务名 xTaskGetTickCount()/xTaskGetTickCountFromISR() 查询任务调度器从启动到现在的时间计数器xTickCount的值，每个滴答定时器中断时xTickCount就会加1 xTaskGetSchedulerState() 获取FreeRTOS的任务调度器运行情况：运行、关闭还是挂起 uxTaskGetNumberOfTasks() 查询系统当前存在的任务数量 vTaskList() 创建一个表格来描述每个任务的详细信息 vTaskGetRunTimeStats() 统计任务的运行时间信息，任务的运行时间信息提供了每个任务获取到CPU使用权总的时间 SetThreadLocalStoragePointer() 设置线程本地存储指针的值，每个任务都有自己的指针数组来作为线程本地存储，使用这些线程本地存储可以用来在任务控制块中存储一些应用信息，这些信息只属于线程自己 GetThreadLocalStoragePointer() 获取线程本地存储指针的值 FreeRTOS开关中断 PEzUKK.png 关闭中断是指优先级低于XCHAL_EXCM_LEVEL的中断将会被屏蔽 FreeRTOS临界段代码保护 函数/宏 描述 taskENTER_CRITICAL() 任务级进入临界段 taskEXIT_CRITICAL() 任务级退出临界段 taskENTER_CRITICAL_FROME_ISR() 中断级进入临界段（中断优先级不能高于configMAX_SYSCALL_INTERRUPT_PRIORITY） taskEXIT_CRITICAL_FROM_ISR() 中断级退出临界段 FreeRTOS列表（双向循环链表）和列表项12345678typedef struct xLIST&#123; listFIRST_LIST_INTEGRITY_CHECK_VALUE //用来检查列表的完整性 configLIST_VOLATILE UBaseType_t uxNumberOfItems;//记录列表中列表项的数量 ListItem_t * configLIST_VOLATILE pxIndex; //记录最新的列表项，用于遍历列表 MiniListItem_t xListEnd; //标记列表的最后一项 listSECOND_LIST_INTEGRITY_CHECK_VALUE //用来检查列表的完整性&#125; List_t; 1234567891011struct xLIST_ITEM&#123; listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE configLIST_VOLATILE TickType_t xItemValue; //序号，用来对列表项进行排列 struct xLIST_ITEM * configLIST_VOLATILE pxNext; //指向下一个列表项 struct xLIST_ITEM * configLIST_VOLATILE pxPrevious; //指向前一个列表项 void * pvOwner; //指向实际包含有该列表项的对象 void * configLIST_VOLATILE pvContainer; //指向此列表项归属的列表 listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE&#125;;typedef struct xLIST_ITEM ListItem_t; 12345678struct xMINI_LIST_ITEM&#123; listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE configLIST_VOLATILE TickType_t xItemValue; struct xLIST_ITEM * configLIST_VOLATILE pxNext; struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;&#125;;typedef struct xMINI_LIST_ITEM MiniListItem_t; 列表操作相关API 函数名 描述 void vListInitialise( List_t * const pxList ) 列表初始化 void vListInitialiseItem( ListItem_t * const pxItem ) 列表项初始化 void vListInsert( List_t const pxList, ListItem_t const pxNewListItem ) 列表项插入（指定位置） void vListInsertEnd( List_t const pxList, ListItem_t const pxNewListItem ) 列表项插入（末尾） UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) 列表项删除 listGET_OWNER_OF_NEXT_ENTRY(pxTCB,pxList) 列表的遍历 vListInsert中，列表项的插入位置是根据列表项中的xItemValue来决定，按照升序方式排列，例如xItemValue的值为portMAX_DELAY就表示要插入的位置是列表的最末尾 vListInsertEnd中，列表项插入的位置是pxList中pxIndex指向的列表项的前面 uxListRemove函数会返回删除后列表的剩余长度，该函数只是将指定的列表项从列表中删除掉，并不会将这个列表项的内存释放掉 列表中的成员变量pxIndex是用来便利列表的，每调用一次宏listGET_OWNER_OF_NEXT_ENTRY，列表的pxIndex就会指向下一个列表项，并且返回这个列表项的pxOwner变量值 FreeRTOS的调度器vTaskStartScheduler函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void vTaskStartScheduler( void )&#123; BaseType_t xReturn; BaseType_t i; //给每个内核都创建一个空闲任务，优先级设为最低（0），任务名为“IDLE” for ( i=0; i&lt;portNUM_PROCESSORS; i++) &#123; #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) &#123; xReturn = xTaskCreatePinnedToCore( prvIdleTask, \"IDLE\", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &amp;xIdleTaskHandle[i], i ); &#125; #else &#123; xReturn = xTaskCreatePinnedToCore( prvIdleTask, \"IDLE\", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL, i); &#125; #endif /* INCLUDE_xTaskGetIdleTaskHandle */ /* Event lists are always in priority order. */ &#125; //创建软件定时器任务，任务名为“Tmr Svc”，此任务只在内核0上运行 #if ( configUSE_TIMERS == 1 ) &#123; if( xReturn == pdPASS ) &#123; xReturn = xTimerCreateTimerTask(); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; #endif /* configUSE_TIMERS */ if( xReturn == pdPASS ) &#123; //在开启调度器之前不允许被中断打扰，在这里将中断关闭。之前创建的任务堆栈中包含有一个状态字，指示这中断是打开状态，所以当第一个任务运行起来后，中断将会再一次被开启。 portDISABLE_INTERRUPTS(); xTickCount = ( TickType_t ) 0U; //如果需要使用时间统计功能，下面的这个宏需要用户自定义（配置一个计数器或定时器） portCONFIGURE_TIMER_FOR_RUN_TIME_STATS(); xSchedulerRunning = pdTRUE;//表示调度器开始运行 //初始化相关硬件：滴答定时器等，这需要用户自行实现 if( xPortStartScheduler() != pdFALSE ) &#123; //一旦调度器起来后就永远不会执行到这里 &#125; else &#123; //只有调用了xTaskEndScheduler函数后才会执行到这里 &#125; &#125; else &#123; //如果创建空闲任务或者定时器任务时内存不够就会执行到这里 configASSERT( xReturn ); &#125;&#125; xPortStartScheduler函数12345678910111213141516BaseType_t xPortStartScheduler( void )&#123; #if XCHAL_CP_NUM &gt; 0 //初始化任务的协处理器 _xt_coproc_init(); #endif //初始化滴答计数器的分频系数 _xt_tick_divisor_init(); //配置、使能滴答计数器 _frxt_tick_timer_init(); port_xSchedulerRunning[xPortGetCoreID()] = 1; //_frxt_dispatch函数不能直接用C语言调用。调度最高优先级的任务 __asm__ volatile (\"call0 _frxt_dispatch\\n\"); //永远不会返回 return pdTRUE;&#125; xTaskCreatePinnedToCore函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//在某个具体的核上创建任务BaseType_t xTaskCreatePinnedToCore( TaskFunction_t pxTaskCode, const char * const pcName, const uint32_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, const BaseType_t xCoreID )&#123; TCB_t *pxNewTCB; BaseType_t xReturn; //如果任务栈向上生长，那么先开辟任务控制块TCB的内存，再开辟任务栈的内存，任务栈的地址保存在TCB中 #if( portSTACK_GROWTH &gt; 0 ) &#123; pxNewTCB = ( TCB_t * ) pvPortMallocTcbMem( sizeof( TCB_t ) ); if( pxNewTCB != NULL ) &#123; pxNewTCB-&gt;pxStack = ( StackType_t * ) pvPortMallocStackMem( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); if( pxNewTCB-&gt;pxStack == NULL ) &#123; vPortFree( pxNewTCB ); pxNewTCB = NULL; &#125; &#125; &#125; #else //如果任务栈向下生长，那么先开辟任务栈的内存，再开辟任务控制块TCB的内存，任务栈的地址保存在TCB中 &#123; StackType_t *pxStack; pxStack = ( StackType_t * ) pvPortMallocStackMem( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); if( pxStack != NULL ) &#123; pxNewTCB = ( TCB_t * ) pvPortMallocTcbMem( sizeof( TCB_t ) ); if( pxNewTCB != NULL ) &#123; pxNewTCB-&gt;pxStack = pxStack; &#125; else &#123; vPortFree( pxStack ); &#125; &#125; else &#123; pxNewTCB = NULL; &#125; &#125; #endif /* portSTACK_GROWTH */ if( pxNewTCB != NULL ) &#123; #if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) &#123; //标记该任务后期不需要的时候需要删除 pxNewTCB-&gt;ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB; &#125; #endif /* configSUPPORT_STATIC_ALLOCATION */ //初始化任务 prvInitialiseNewTask( pxTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL, xCoreID ); //将新创建的任务加入就绪列表中 prvAddNewTaskToReadyList( pxNewTCB, pxTaskCode, xCoreID ); xReturn = pdPASS; &#125; else &#123; xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY; &#125; return xReturn;&#125; prvInitialiseNewTask函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163static void prvInitialiseNewTask( TaskFunction_t pxTaskCode, const char * const pcName, const uint32_t ulStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, TCB_t *pxNewTCB, const MemoryRegion_t * const xRegions, const BaseType_t xCoreID )&#123;StackType_t *pxTopOfStack;UBaseType_t x; #if( portUSING_MPU_WRAPPERS == 1 ) //任务使用特权模式创建任务 BaseType_t xRunPrivileged; if( ( uxPriority &amp; portPRIVILEGE_BIT ) != 0U ) &#123; xRunPrivileged = pdTRUE; &#125; else &#123; xRunPrivileged = pdFALSE; &#125; uxPriority &amp;= ~portPRIVILEGE_BIT; #endif /* portUSING_MPU_WRAPPERS == 1 */ #if( ( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) &#123; //将任务栈初始化相同的值(0xA5) ( void ) memset( pxNewTCB-&gt;pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) ); &#125; #endif //根据栈的不同生长方向来计算栈顶位置 #if( portSTACK_GROWTH &lt; 0 ) &#123; pxTopOfStack = pxNewTCB-&gt;pxStack + ( ulStackDepth - ( uint32_t ) 1 ); pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); //检查堆栈栈顶地址是否字节对齐 configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) ); #if ( configENABLE_TASK_SNAPSHOT == 1 ) &#123; pxNewTCB-&gt;pxEndOfStack = pxTopOfStack; &#125;#endif &#125; #else /* portSTACK_GROWTH */ &#123; pxTopOfStack = pxNewTCB-&gt;pxStack; configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB-&gt;pxStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) ); pxNewTCB-&gt;pxEndOfStack = pxNewTCB-&gt;pxStack + ( ulStackDepth - ( uint32_t ) 1 ); &#125; #endif /* portSTACK_GROWTH */ //保存任务的任务名 for( x = ( UBaseType_t ) 0; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ ) &#123; pxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ]; if( pcName[ x ] == 0x00 ) &#123; break; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; //任务名太长需要截断 pxNewTCB-&gt;pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\\0'; //修正不合法的优先级 if( uxPriority &gt;= ( UBaseType_t ) configMAX_PRIORITIES ) &#123; uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; pxNewTCB-&gt;uxPriority = uxPriority;//初始化任务控制块的优先级字段 pxNewTCB-&gt;xCoreID = xCoreID;//初始化任务所在的内核ID号 #if ( configUSE_MUTEXES == 1 ) &#123; pxNewTCB-&gt;uxBasePriority = uxPriority;//如果使用了互斥信号量，就需要指定基础优先级 pxNewTCB-&gt;uxMutexesHeld = 0; &#125; #endif /* configUSE_MUTEXES */ vListInitialiseItem( &amp;( pxNewTCB-&gt;xGenericListItem ) );//初始化通用列表项 vListInitialiseItem( &amp;( pxNewTCB-&gt;xEventListItem ) );//初始化事件列表项 listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xGenericListItem ), pxNewTCB );//设置列表项归属 listSET_LIST_ITEM_VALUE( &amp;( pxNewTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );//设置事件列表项的值使得优先级从小到大排列 listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xEventListItem ), pxNewTCB );//设置列表项归属 #if ( portCRITICAL_NESTING_IN_TCB == 1 ) &#123; pxNewTCB-&gt;uxCriticalNesting = ( UBaseType_t ) 0U; &#125; #endif /* portCRITICAL_NESTING_IN_TCB */ #if ( configUSE_APPLICATION_TASK_TAG == 1 ) &#123; pxNewTCB-&gt;pxTaskTag = NULL; &#125; #endif /* configUSE_APPLICATION_TASK_TAG */ #if ( configGENERATE_RUN_TIME_STATS == 1 ) &#123; pxNewTCB-&gt;ulRunTimeCounter = 0UL; &#125; #endif /* configGENERATE_RUN_TIME_STATS */ #if ( portUSING_MPU_WRAPPERS == 1 ) &#123; vPortStoreTaskMPUSettings( &amp;( pxNewTCB-&gt;xMPUSettings ), xRegions, pxNewTCB-&gt;pxStack, ulStackDepth ); &#125; #else &#123; /* Avoid compiler warning about unreferenced parameter. */ ( void ) xRegions; &#125; #endif #if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 ) &#123; for( x = 0; x &lt; ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ ) &#123; pxNewTCB-&gt;pvThreadLocalStoragePointers[ x ] = NULL; #if ( configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS == 1) pxNewTCB-&gt;pvThreadLocalStoragePointersDelCallback[ x ] = NULL; #endif &#125; &#125; #endif #if ( configUSE_TASK_NOTIFICATIONS == 1 ) &#123; pxNewTCB-&gt;ulNotifiedValue = 0; pxNewTCB-&gt;eNotifyState = eNotWaitingNotification; &#125; #endif #if ( configUSE_NEWLIB_REENTRANT == 1 ) &#123; /* Initialise this task's Newlib reent structure. */ esp_reent_init(&amp;pxNewTCB-&gt;xNewLib_reent); &#125; #endif #if( INCLUDE_xTaskAbortDelay == 1 ) &#123; pxNewTCB-&gt;ucDelayAborted = pdFALSE; &#125; #endif #if( portUSING_MPU_WRAPPERS == 1 ) &#123; pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged ); &#125; #else /* portUSING_MPU_WRAPPERS */ &#123; pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );//初始化任务堆栈 &#125; #endif /* portUSING_MPU_WRAPPERS */ if( ( void * ) pxCreatedTask != NULL ) &#123; //任务句柄其实就是任务控制块的地址 *pxCreatedTask = ( TaskHandle_t ) pxNewTCB; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125;&#125; pxPortInitialiseStack函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )&#123; StackType_t *sp, *tp; XtExcFrame *frame; #if XCHAL_CP_NUM &gt; 0 uint32_t *p; #endif uint32_t *threadptr; void *task_thread_local_start; extern int _thread_local_start, _thread_local_end, _rodata_start; // TODO: check that TLS area fits the stack uint32_t thread_local_sz = (uint8_t *)&amp;_thread_local_end - (uint8_t *)&amp;_thread_local_start; thread_local_sz = ALIGNUP(0x10, thread_local_sz); /* 初始化任务堆栈，使之从高地址开始往下依次是： ----LOW ADDRESSES ----------------------------------------HIGH ADDRESSES---------- task stack | interrupt stack frame | thread local vars | co-processor save area | ---------------------------------------------------------------------------------- | | SP pxTopOfStack */ sp = (StackType_t *) (((UBaseType_t)(pxTopOfStack + 1) - XT_CP_SIZE - thread_local_sz - XT_STK_FRMSZ) &amp; ~0xf);//16字节对齐 for (tp = sp; tp &lt;= pxTopOfStack; ++tp)//将sp到TopOfStack之间的内存清零 *tp = 0; frame = (XtExcFrame *) sp; /* 对一些必要的寄存赋值 */ frame-&gt;pc = (UBaseType_t) pxCode; //PC指针初始化为任务函数的入口地址 frame-&gt;a0 = 0; //组织GDB回溯 frame-&gt;a1 = (UBaseType_t) sp + XT_STK_FRMSZ; frame-&gt;exit = (UBaseType_t) _xt_user_exit; /* Set initial PS to int level 0, EXCM disabled ('rfe' will enable), user mode. */ /* Also set entry point argument parameter. */ #ifdef __XTENSA_CALL0_ABI__ frame-&gt;a2 = (UBaseType_t) pvParameters; frame-&gt;ps = PS_UM | PS_EXCM; #else /* + for windowed ABI also set WOE and CALLINC (pretend task was 'call4'd). */ frame-&gt;a6 = (UBaseType_t) pvParameters; frame-&gt;ps = PS_UM | PS_EXCM | PS_WOE | PS_CALLINC(1); #endif #ifdef XT_USE_SWPRI /* Set the initial virtual priority mask value to all 1's. */ frame-&gt;vpri = 0xFFFFFFFF; #endif /* Init threadptr reg and TLS vars */ task_thread_local_start = (void *)(((uint32_t)pxTopOfStack - XT_CP_SIZE - thread_local_sz) &amp; ~0xf); memcpy(task_thread_local_start, &amp;_thread_local_start, thread_local_sz); threadptr = (uint32_t *)(sp + XT_STK_EXTRA); /* shift threadptr by the offset of _thread_local_start from DROM start; need to take into account extra 16 bytes offset */ *threadptr = (uint32_t)task_thread_local_start - ((uint32_t)&amp;_thread_local_start - (uint32_t)&amp;_rodata_start) - 0x10; #if XCHAL_CP_NUM &gt; 0 /* Init the coprocessor save area (see xtensa_context.h) */ p = (uint32_t *)(((uint32_t) pxTopOfStack - XT_CP_SIZE) &amp; ~0xf); p[0] = 0; p[1] = 0; p[2] = (((uint32_t) p) + 12 + XCHAL_TOTAL_SA_ALIGN - 1) &amp; -XCHAL_TOTAL_SA_ALIGN; #endif return sp;&#125; prvAddNewTaskToReadyList函数 FreeRTOS使用不同的列表来表示任务的不同状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB, TaskFunction_t pxTaskCode, BaseType_t xCoreID )&#123; TCB_t *curTCB, *tcb0, *tcb1; configASSERT( xCoreID == tskNO_AFFINITY || xCoreID &lt; portNUM_PROCESSORS); //确保列表在被更新的过程中不会被中断打断 taskENTER_CRITICAL(&amp;xTaskQueueMutex); &#123; uxCurrentNumberOfTasks++;//全局变量，统计任务数量 //判断这个任务在哪个内核上运行 if ( xCoreID == tskNO_AFFINITY ) &#123; if ( portNUM_PROCESSORS == 1 ) &#123; xCoreID = 0; &#125; else &#123; tcb0 = pxCurrentTCB[0]; tcb1 = pxCurrentTCB[1]; if ( tcb0 == NULL ) &#123; xCoreID = 0; &#125; else if ( tcb1 == NULL ) &#123; xCoreID = 1; &#125; else if ( tcb0-&gt;uxPriority &lt; pxNewTCB-&gt;uxPriority &amp;&amp; tcb0-&gt;uxPriority &lt; tcb1-&gt;uxPriority ) &#123; xCoreID = 0; &#125; else if ( tcb1-&gt;uxPriority &lt; pxNewTCB-&gt;uxPriority ) &#123; xCoreID = 1; &#125; else//两个核上的运行的任务，其优先级都比新的任务要高 &#123; xCoreID = xPortGetCoreID(); &#125; &#125; &#125; //当前的核上没有任务正在运行 if( pxCurrentTCB[ xCoreID ] == NULL ) &#123; pxCurrentTCB[ xCoreID ] = pxNewTCB; if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 ) &#123;#if portFIRST_TASK_HOOK if ( xPortGetCoreID() == 0 ) &#123; vPortFirstTaskHook(pxTaskCode); &#125;#endif /* configFIRST_TASK_HOOK */ //正在创建的任务是第一个任务，那么需要先初始化相应的列表 prvInitialiseTaskLists(); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; else &#123; if( xSchedulerRunning == pdFALSE ) &#123; //新任务的优先级比正在运行的任务优先级高 if ( pxCurrentTCB[xCoreID] == NULL || pxCurrentTCB[xCoreID]-&gt;uxPriority &lt;= pxNewTCB-&gt;uxPriority ) &#123; pxCurrentTCB[xCoreID] = pxNewTCB; &#125; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; uxTaskNumber++;//uxTaskNumber加1，用作任务控制块编号 #if ( configUSE_TRACE_FACILITY == 1 ) &#123; pxNewTCB-&gt;uxTCBNumber = uxTaskNumber; &#125; #endif /* configUSE_TRACE_FACILITY */ traceTASK_CREATE( pxNewTCB ); prvAddTaskToReadyList( pxNewTCB ); portSETUP_TCB( pxNewTCB ); &#125; taskEXIT_CRITICAL(&amp;xTaskQueueMutex); if( xSchedulerRunning != pdFALSE ) &#123; taskENTER_CRITICAL(&amp;xTaskQueueMutex); curTCB = pxCurrentTCB[ xCoreID ]; //如果新任务的任务优先级最高，而且调度器已经开始正常运行了，那么就执行任务切换 if( curTCB == NULL || curTCB-&gt;uxPriority &lt; pxNewTCB-&gt;uxPriority ) &#123; if( xCoreID == xPortGetCoreID() ) &#123; taskYIELD_IF_USING_PREEMPTION(); &#125; else &#123; taskYIELD_OTHER_CORE(xCoreID, pxNewTCB-&gt;uxPriority); &#125; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; taskEXIT_CRITICAL(&amp;xTaskQueueMutex); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125;&#125; prvAddTaskToReadyList宏1234#define prvAddTaskToReadyList( pxTCB ) \\ traceMOVED_TASK_TO_READY_STATE( pxTCB ); \\ taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority ); \\ vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xGenericListItem ) )//将任务添加到就绪列表的末尾 vTaskDelete函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879void vTaskDelete( TaskHandle_t xTaskToDelete )&#123; TCB_t *pxTCB; int core = xPortGetCoreID(); UBaseType_t free_now; taskENTER_CRITICAL(&amp;xTaskQueueMutex); &#123; pxTCB = prvGetTCBFromHandle( xTaskToDelete );//根据任务句柄获取TCB指针 //将任务从就绪列表中删除 if( uxListRemove( &amp;( pxTCB-&gt;xGenericListItem ) ) == ( UBaseType_t ) 0 ) &#123; taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority ); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; //判断该任务是否在等待某个事件，如果是这样，则这个任务会被放到相应的列表中，这里需要将其移除 if( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != NULL ) &#123; ( void ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) ); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; //触发调试器刷新任务列表 uxTaskNumber++; //被删除的任务是正在运行的任务，或者在别的核，那么就交给空闲任务来释放内存 if( pxTCB == pxCurrentTCB[ core ] || (portNUM_PROCESSORS &gt; 1 &amp;&amp; pxTCB == pxCurrentTCB[ !core ]) || (portNUM_PROCESSORS &gt; 1 &amp;&amp; pxTCB-&gt;xCoreID == (!core)) ) &#123; vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xGenericListItem ) ); ++uxTasksDeleted; portPRE_TASK_DELETE_HOOK( pxTCB, &amp;xYieldPending[xPortGetCoreID()] );//调用任务删除钩子函数 free_now = pdFALSE; //不能立即释放内存 &#125; else//要删除的任务不是当前运行的，也不在别的核上 &#123; --uxCurrentNumberOfTasks; //重新计算一下还要多长时间执行下一个任务，也就是下一个任务的解锁时间，防止有的任务的解锁时间参考了刚刚被删除的那个任务 prvResetNextTaskUnblockTime(); free_now = pdTRUE; &#125; traceTASK_DELETE( pxTCB ); &#125; taskEXIT_CRITICAL(&amp;xTaskQueueMutex); if(free_now == pdTRUE)&#123; #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 ) &amp;&amp; ( configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS ) prvDeleteTLS( pxTCB ); //Run deletion callbacks before deleting TCB #endif prvDeleteTCB( pxTCB ); //Must only be called after del cb &#125; //如果删除的是正在运行的任务，那么删除完以后肯定需要强制进行一次任务切换 if( xSchedulerRunning != pdFALSE ) &#123; if( pxTCB == pxCurrentTCB[ core ] ) &#123; configASSERT( uxSchedulerSuspended[ core ] == 0 ); portPRE_TASK_DELETE_HOOK( pxTCB, &amp;xYieldPending[xPortGetCoreID()] ); portYIELD_WITHIN_API(); &#125; else if ( portNUM_PROCESSORS &gt; 1 &amp;&amp; pxTCB == pxCurrentTCB[ !core] ) &#123; //如果被删除的任务正在另外一个核上运行，强制另外一个核做任务切换 vPortYieldOtherCore( !core ); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125;&#125; vTaskSuspend函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576void vTaskSuspend( TaskHandle_t xTaskToSuspend )&#123; TCB_t *pxTCB; TCB_t *curTCB; taskENTER_CRITICAL(&amp;xTaskQueueMutex); &#123; pxTCB = prvGetTCBFromHandle( xTaskToSuspend ); traceTASK_SUSPEND( pxTCB ); //将任务从就绪列表中删除 if( uxListRemove( &amp;( pxTCB-&gt;xGenericListItem ) ) == ( UBaseType_t ) 0 ) &#123; taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority ); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; //将任务从事件列表中删除 if( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != NULL ) &#123; ( void ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) ); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; traceMOVED_TASK_TO_SUSPENDED_LIST(pxTCB); //将任务添加到挂起列表的最后 vListInsertEnd( &amp;xSuspendedTaskList, &amp;( pxTCB-&gt;xGenericListItem ) ); curTCB = pxCurrentTCB[ xPortGetCoreID() ]; &#125; taskEXIT_CRITICAL(&amp;xTaskQueueMutex); if( pxTCB == curTCB ) &#123; if( xSchedulerRunning != pdFALSE ) &#123; //确保当前核的任务调度器工作正常 configASSERT( uxSchedulerSuspended[ xPortGetCoreID() ] == 0 ); portYIELD_WITHIN_API(); &#125; else//任务调度器不在工作，只能手动查找下一个要运行的任务 &#123; //所有的任务都被挂起，事实上这种情况几乎不存在，除非在空闲任务中调用了阻塞的API if( listCURRENT_LIST_LENGTH( &amp;xSuspendedTaskList ) == uxCurrentNumberOfTasks ) &#123; taskENTER_CRITICAL(&amp;xTaskQueueMutex); pxCurrentTCB[ xPortGetCoreID() ] = NULL; taskEXIT_CRITICAL(&amp;xTaskQueueMutex); &#125; else &#123; //获取下一个要运行的任务 vTaskSwitchContext(); &#125; &#125; &#125; else &#123; if( xSchedulerRunning != pdFALSE ) &#123; //如果被挂起的任务当前不在运行，重新计算一下还要多长时间执行下一个任务，防止有的任务的解锁时间参考了刚刚被挂起的任务 taskENTER_CRITICAL(&amp;xTaskQueueMutex); &#123; prvResetNextTaskUnblockTime(); &#125; taskEXIT_CRITICAL(&amp;xTaskQueueMutex); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125;&#125; vTaskResume函数123456789101112131415161718192021222324252627282930313233343536373839404142434445void vTaskResume( TaskHandle_t xTaskToResume )&#123; TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume; configASSERT( xTaskToResume ); taskENTER_CRITICAL(&amp;xTaskQueueMutex); //xTaskToResume不能为NULL，也不应该存在恢复当前正在运行的任务这种情况 if( ( pxTCB != NULL ) &amp;&amp; ( pxTCB != pxCurrentTCB[ xPortGetCoreID() ] ) ) &#123; &#123; if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE ) &#123; traceTASK_RESUME( pxTCB ); //将要恢复的任务从挂起列表中删除 ( void ) uxListRemove( &amp;( pxTCB-&gt;xGenericListItem ) ); //将要恢复的任务添加到就绪任务列表中 prvAddTaskToReadyList( pxTCB ); //如果被恢复的任务优先级更高 if( tskCAN_RUN_HERE(pxTCB-&gt;xCoreID) &amp;&amp; pxTCB-&gt;uxPriority &gt;= pxCurrentTCB[ xPortGetCoreID() ]-&gt;uxPriority ) &#123; //这个yield不会让恢复的任务立即运行，但是会刷新就绪列表 taskYIELD_IF_USING_PREEMPTION(); &#125; else if( pxTCB-&gt;xCoreID != xPortGetCoreID() ) &#123; //被恢复的任务不属于当前的核 taskYIELD_OTHER_CORE( pxTCB-&gt;xCoreID, pxTCB-&gt;uxPriority ); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; taskEXIT_CRITICAL(&amp;xTaskQueueMutex);&#125; FreeRTOS任务切换 FreeRTOS任务切换的场合 执行一个会引起任务切换的API函数，比如taskYIELD 系统滴答定时器中断 任务切换一般是在PendSV（可挂起的系统调用）中断服务函数里面完成的 执行系统调用12#define taskYIELD() portYIELD()#define portYIELD() vPortYield() vPortYield函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//函数void vPortYield(void)使用汇编实现，主要功能是保存待暂停任务的最小现场环境，清除CPENABLE，最后调用_frxt_dispatch函数实现真正的上下文切换 .globl vPortYield .type vPortYield,@function .align 4vPortYield: #ifdef __XTENSA_CALL0_ABI__ addi sp, sp, -XT_SOL_FRMSZ #else entry sp, XT_SOL_FRMSZ #endif rsr a2, PS s32i a0, sp, XT_SOL_PC s32i a2, sp, XT_SOL_PS #ifdef __XTENSA_CALL0_ABI__ s32i a12, sp, XT_SOL_A12 /* save callee-saved registers */ s32i a13, sp, XT_SOL_A13 s32i a14, sp, XT_SOL_A14 s32i a15, sp, XT_SOL_A15 #else /* Spill register windows. Calling xthal_window_spill() causes extra */ /* spills and reloads, so we will set things up to call the _nw version */ /* instead to save cycles. */ movi a6, ~(PS_WOE_MASK|PS_INTLEVEL_MASK) /* spills a4-a7 if needed */ and a2, a2, a6 /* clear WOE, INTLEVEL */ addi a2, a2, XCHAL_EXCM_LEVEL /* set INTLEVEL */ wsr a2, PS rsync call0 xthal_window_spill_nw l32i a2, sp, XT_SOL_PS /* restore PS */ wsr a2, PS #endif rsil a2, XCHAL_EXCM_LEVEL /* disable low/med interrupts */ #if XCHAL_CP_NUM &gt; 0 /* Save coprocessor callee-saved state (if any). At this point CPENABLE */ /* should still reflect which CPs were in use (enabled). */ call0 _xt_coproc_savecs #endif movi a2, pxCurrentTCB getcoreid a3 addx4 a2, a3, a2 l32i a2, a2, 0 /* a2 = pxCurrentTCB */ movi a3, 0 s32i a3, sp, XT_SOL_EXIT /* 0 to flag as solicited frame */ s32i sp, a2, TOPOFSTACK_OFFS /* pxCurrentTCB-&gt;pxTopOfStack = SP */ #if XCHAL_CP_NUM &gt; 0 /* Clear CPENABLE, also in task's co-processor state save area. */ l32i a2, a2, CP_TOPOFSTACK_OFFS /* a2 = pxCurrentTCB-&gt;cp_state */ movi a3, 0 wsr a3, CPENABLE beqz a2, 1f s16i a3, a2, XT_CPENABLE /* clear saved cpenable */1: #endif /* Tail-call dispatcher. */ call0 _frxt_dispatch /* Never reaches here. */ _frxt_dispatch函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//该函数的功能是将上下文切换到最高优先级的就绪任务，恢复它的状态，最后将将控制权转交给它 .globl _frxt_dispatch .type _frxt_dispatch,@function .align 4_frxt_dispatch: #ifdef __XTENSA_CALL0_ABI__ call0 vTaskSwitchContext // Get next TCB to resume movi a2, pxCurrentTCB getcoreid a3 addx4 a2, a3, a2 #else call4 vTaskSwitchContext // Get next TCB to resume movi a2, pxCurrentTCB getcoreid a3 addx4 a2, a3, a2 #endif l32i a3, a2, 0 l32i sp, a3, TOPOFSTACK_OFFS /* SP = next_TCB-&gt;pxTopOfStack; */ s32i a3, a2, 0 /* Determine the type of stack frame. */ l32i a2, sp, XT_STK_EXIT /* exit dispatcher or solicited flag */ bnez a2, .L_frxt_dispatch_stk.L_frxt_dispatch_sol: /* Solicited stack frame. Restore minimal context and return from vPortYield(). */ l32i a3, sp, XT_SOL_PS #ifdef __XTENSA_CALL0_ABI__ l32i a12, sp, XT_SOL_A12 l32i a13, sp, XT_SOL_A13 l32i a14, sp, XT_SOL_A14 l32i a15, sp, XT_SOL_A15 #endif l32i a0, sp, XT_SOL_PC #if XCHAL_CP_NUM &gt; 0 /* Ensure wsr.CPENABLE is complete (should be, it was cleared on entry). */ rsync #endif /* As soons as PS is restored, interrupts can happen. No need to sync PS. */ wsr a3, PS #ifdef __XTENSA_CALL0_ABI__ addi sp, sp, XT_SOL_FRMSZ ret #else retw #endif.L_frxt_dispatch_stk: #if XCHAL_CP_NUM &gt; 0 /* Restore CPENABLE from task's co-processor save area. */ movi a3, pxCurrentTCB /* cp_state = */ getcoreid a2 addx4 a3, a2, a3 l32i a3, a3, 0 l32i a2, a3, CP_TOPOFSTACK_OFFS /* StackType_t *pxStack; */ l16ui a3, a2, XT_CPENABLE /* CPENABLE = cp_state-&gt;cpenable; */ wsr a3, CPENABLE #endif /* Interrupt stack frame. Restore full context and return to exit dispatcher. */ call0 _xt_context_restore /* In Call0 ABI, restore callee-saved regs (A12, A13 already restored). */ #ifdef __XTENSA_CALL0_ABI__ l32i a14, sp, XT_STK_A14 l32i a15, sp, XT_STK_A15 #endif #if XCHAL_CP_NUM &gt; 0 /* Ensure wsr.CPENABLE has completed. */ rsync #endif /* Must return via the exit dispatcher corresponding to the entrypoint from which this was called. Interruptee's A0, A1, PS, PC are restored and the interrupt stack frame is deallocated in the exit dispatcher. */ l32i a0, sp, XT_STK_EXIT ret vTaskSwitchContext函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165//理论上，该函数只有在滴答定时器中断和crosscore中断中被调用void vTaskSwitchContext( void )&#123; int irqstate=portENTER_CRITICAL_NESTED(); tskTCB * pxTCB; if( uxSchedulerSuspended[ xPortGetCoreID() ] != ( UBaseType_t ) pdFALSE ) &#123; /* The scheduler is currently suspended - do not allow a context switch. */ xYieldPending[ xPortGetCoreID() ] = pdTRUE; &#125; else &#123; xYieldPending[ xPortGetCoreID() ] = pdFALSE; xSwitchingContext[ xPortGetCoreID() ] = pdTRUE; traceTASK_SWITCHED_OUT(); #if ( configGENERATE_RUN_TIME_STATS == 1 ) &#123; #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime ); #else ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE(); #endif /* Add the amount of time the task has been running to the accumulated time so far. The time the task started running was stored in ulTaskSwitchedInTime. Note that there is no overflow protection here so count values are only valid until the timer overflows. The guard against negative values is to protect against suspect run time stat counter implementations - which are provided by the application, not the kernel. */ taskENTER_CRITICAL_ISR(&amp;xTaskQueueMutex); if( ulTotalRunTime &gt; ulTaskSwitchedInTime[ xPortGetCoreID() ] ) &#123; pxCurrentTCB[ xPortGetCoreID() ]-&gt;ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime[ xPortGetCoreID() ] ); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; taskEXIT_CRITICAL_ISR(&amp;xTaskQueueMutex); ulTaskSwitchedInTime[ xPortGetCoreID() ] = ulTotalRunTime; &#125; #endif /* configGENERATE_RUN_TIME_STATS */ /* Check for stack overflow, if configured. */ taskFIRST_CHECK_FOR_STACK_OVERFLOW(); taskSECOND_CHECK_FOR_STACK_OVERFLOW(); /* Select a new task to run */ /* We cannot do taskENTER_CRITICAL_ISR(&amp;xTaskQueueMutex); here because it saves the interrupt context to the task tcb, and we're swapping that out here. Instead, we're going to do the work here ourselves. Because interrupts are already disabled, we only need to acquire the mutex. */#ifdef CONFIG_FREERTOS_PORTMUX_DEBUG vPortCPUAcquireMutex( &amp;xTaskQueueMutex, __FUNCTION__, __LINE__ );#else vPortCPUAcquireMutex( &amp;xTaskQueueMutex );#endif unsigned portBASE_TYPE foundNonExecutingWaiter = pdFALSE, ableToSchedule = pdFALSE, resetListHead; portBASE_TYPE uxDynamicTopReady = uxTopReadyPriority; unsigned portBASE_TYPE holdTop=pdFALSE; /* * ToDo: This scheduler doesn't correctly implement the round-robin scheduling as done in the single-core * FreeRTOS stack when multiple tasks have the same priority and are all ready; it just keeps grabbing the * first one. ToDo: fix this. * (Is this still true? if any, there's the issue with one core skipping over the processes for the other * core, potentially not giving the skipped-over processes any time.) */ while ( ableToSchedule == pdFALSE &amp;&amp; uxDynamicTopReady &gt;= 0 ) &#123; resetListHead = pdFALSE; // Nothing to do for empty lists if (!listLIST_IS_EMPTY( &amp;( pxReadyTasksLists[ uxDynamicTopReady ] ) )) &#123; ableToSchedule = pdFALSE; tskTCB * pxRefTCB; /* Remember the current list item so that we can detect if all items have been inspected. Once this happens, we move on to a lower priority list (assuming nothing is suitable for scheduling). Note: This can return NULL if the list index is at the listItem */ pxRefTCB = pxReadyTasksLists[ uxDynamicTopReady ].pxIndex-&gt;pvOwner; if ((void*)pxReadyTasksLists[ uxDynamicTopReady ].pxIndex==(void*)&amp;pxReadyTasksLists[ uxDynamicTopReady ].xListEnd) &#123; //pxIndex points to the list end marker. Skip that and just get the next item. listGET_OWNER_OF_NEXT_ENTRY( pxRefTCB, &amp;( pxReadyTasksLists[ uxDynamicTopReady ] ) ); &#125; do &#123; listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &amp;( pxReadyTasksLists[ uxDynamicTopReady ] ) ); /* Find out if the next task in the list is already being executed by another core */ foundNonExecutingWaiter = pdTRUE; portBASE_TYPE i = 0; for ( i=0; i&lt;portNUM_PROCESSORS; i++ ) &#123; if (i == xPortGetCoreID()) &#123; continue; &#125; else if (pxCurrentTCB[i] == pxTCB) &#123; holdTop=pdTRUE; //keep this as the top prio, for the other CPU foundNonExecutingWaiter = pdFALSE; break; &#125; &#125; if (foundNonExecutingWaiter == pdTRUE) &#123; /* If the task is not being executed by another core and its affinity is compatible with the current one, prepare it to be swapped in */ if (pxTCB-&gt;xCoreID == tskNO_AFFINITY) &#123; pxCurrentTCB[xPortGetCoreID()] = pxTCB; ableToSchedule = pdTRUE; &#125; else if (pxTCB-&gt;xCoreID == xPortGetCoreID()) &#123; pxCurrentTCB[xPortGetCoreID()] = pxTCB; ableToSchedule = pdTRUE; &#125; else &#123; ableToSchedule = pdFALSE; holdTop=pdTRUE; //keep this as the top prio, for the other CPU &#125; &#125; else &#123; ableToSchedule = pdFALSE; &#125; if (ableToSchedule == pdFALSE) &#123; resetListHead = pdTRUE; &#125; else if ((ableToSchedule == pdTRUE) &amp;&amp; (resetListHead == pdTRUE)) &#123; tskTCB * pxResetTCB; do &#123; listGET_OWNER_OF_NEXT_ENTRY( pxResetTCB, &amp;( pxReadyTasksLists[ uxDynamicTopReady ] ) ); &#125; while(pxResetTCB != pxRefTCB); &#125; &#125; while ((ableToSchedule == pdFALSE) &amp;&amp; (pxTCB != pxRefTCB)); &#125; else &#123; if (!holdTop) --uxTopReadyPriority; &#125; --uxDynamicTopReady; &#125; traceTASK_SWITCHED_IN(); xSwitchingContext[ xPortGetCoreID() ] = pdFALSE; //Exit critical region manually as well: release the mux now, interrupts will be re-enabled when we //exit the function.#ifdef CONFIG_FREERTOS_PORTMUX_DEBUG vPortCPUReleaseMutex( &amp;xTaskQueueMutex, __FUNCTION__, __LINE__ );#else vPortCPUReleaseMutex( &amp;xTaskQueueMutex );#endif#if CONFIG_FREERTOS_WATCHPOINT_END_OF_STACK vPortSetStackWatchpoint(pxCurrentTCB[xPortGetCoreID()]-&gt;pxStack);#endif &#125; portEXIT_CRITICAL_NESTED(irqstate);&#125; 系统滴答定时器中断_frxt_timer_int123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//该函数是系统滴答定时器中断处理函数，每一次tick时钟到来都会调用一次xPortSysTickHandler .globl _frxt_timer_int .type _frxt_timer_int,@function .align 4_frxt_timer_int: ENTRY(16) #ifdef CONFIG_PM_TRACE movi a6, 1 /* = ESP_PM_TRACE_TICK */ getcoreid a7 call4 esp_pm_trace_enter #endif // CONFIG_PM_TRACE.L_xt_timer_int_catchup: /* Update the timer comparator for the next tick. */ #ifdef XT_CLOCK_FREQ movi a2, XT_TICK_DIVISOR /* a2 = comparator increment */ #else movi a3, _xt_tick_divisor l32i a2, a3, 0 /* a2 = comparator increment */ #endif rsr a3, XT_CCOMPARE /* a3 = old comparator value */ add a4, a3, a2 /* a4 = new comparator value */ wsr a4, XT_CCOMPARE /* update comp. and clear interrupt */ esync #ifdef __XTENSA_CALL0_ABI__ /* Preserve a2 and a3 across C calls. */ s32i a2, sp, 4 s32i a3, sp, 8 #endif /* Call the FreeRTOS tick handler (see port.c). */ #ifdef __XTENSA_CALL0_ABI__ call0 xPortSysTickHandler #else call4 xPortSysTickHandler #endif #ifdef __XTENSA_CALL0_ABI__ /* Restore a2 and a3. */ l32i a2, sp, 4 l32i a3, sp, 8 #endif /* Check if we need to process more ticks to catch up. */ esync /* ensure comparator update complete */ rsr a4, CCOUNT /* a4 = cycle count */ sub a4, a4, a3 /* diff = ccount - old comparator */ blt a2, a4, .L_xt_timer_int_catchup /* repeat while diff &gt; divisor */#ifdef CONFIG_PM_TRACE movi a6, 1 /* = ESP_PM_TRACE_TICK */ getcoreid a7 call4 esp_pm_trace_exit#endif // CONFIG_PM_TRACE RET(16) xPortSysTickHandler函数123456789101112131415BaseType_t xPortSysTickHandler( void )&#123; BaseType_t ret; portbenchmarkIntLatency(); traceISR_ENTER(SYSTICK_INTR_ID); ret = xTaskIncrementTick(); if( ret != pdFALSE ) &#123; portYIELD_FROM_ISR(); &#125; else &#123; traceISR_EXIT(); &#125; return ret;&#125; 1#define portYIELD_FROM_ISR() &#123;traceISR_EXIT_TO_SCHEDULER(); _frxt_setup_switch();&#125; _frxt_setup_switch函数12345678910111213141516//在内部设置一个flag，在退出中断的时候_frxt_int_exit会检查该flag，如果发现flag被设置了，就调用函数vPortYieldFromInt .global _frxt_setup_switch .type _frxt_setup_switch,@function .align 4_frxt_setup_switch: ENTRY(16) getcoreid a3 movi a2, port_switch_flag addx4 a2, a3, a2 movi a3, 1 s32i a3, a2, 0 RET(16) vPortYieldFromInt123456789101112131415161718192021222324252627 .globl vPortYieldFromInt .type vPortYieldFromInt,@function .align 4vPortYieldFromInt: ENTRY(16) #if XCHAL_CP_NUM &gt; 0 /* Save CPENABLE in task's co-processor save area, and clear CPENABLE. */ movi a3, pxCurrentTCB /* cp_state = */ getcoreid a2 addx4 a3, a2, a3 l32i a3, a3, 0 l32i a2, a3, CP_TOPOFSTACK_OFFS rsr a3, CPENABLE s16i a3, a2, XT_CPENABLE /* cp_state-&gt;cpenable = CPENABLE; */ movi a3, 0 wsr a3, CPENABLE /* disable all co-processors */ #endif #ifdef __XTENSA_CALL0_ABI__ /* Tail-call dispatcher. */ call0 _frxt_dispatch /* Never reaches here. */ #else RET(16) #endif :end:总结上下文切换的场合12345678910111213141516171819graph LR fd(_frxt_dispatch) --&gt; tsc(vTaskSwitchContext) ty(taskYIELD/portYIELD) --&gt; py(vPortYield) py --&gt; fd fie(XT_RTOS_INT_ENTER/_frxt_int_enter) --&gt; fti(_frxt_timer_int) fti --&gt; psth(xPortSysTickHandler) psth --&gt; pyfi(portYIELD_FROM_ISR) pyfi --&gt; fss(_frxt_setup_switch) fss --&gt; fiex(XT_RTOS_INT_EXIT/_frxt_int_exit) fiex --&gt; pyf(vPortYieldFromInt) pyf --&gt; fd tyoc(taskYIELD_OTHER_CORE) --&gt; vpyoc(vPortYieldOtherCore) vpyoc --&gt; ecisy(esp_crosscore_int_send_yield) ecisy --&gt; ecis(esp_crosscore_int_send) ecis --&gt; eci(esp_crosscore_isr) eci --&gt; ecihy(esp_crosscore_isr_handle_yield) ecihy --&gt; pyfi FreeRTOS时间片调度 时间片调度发生在滴答定时器的中断服务函数中，在中断服务函数中会调用xPortSysTickHandler()，而xPortSysTickHandler会引发任务调度，只是这个任务调度是有条件的，只有xTaskIncrementTick的返回值不为pdFALSE时，才会进行任务调度。如果当前任务所对应的优先级下有其他的任务存在，那么函数xTaskIncrementTick就会返回pdTRUE。 FreeRTOS时间管理vTaskDelay相对延时函数1234567891011121314151617181920212223242526272829303132333435363738394041void vTaskDelay( const TickType_t xTicksToDelay )&#123; TickType_t xTimeToWake; BaseType_t xAlreadyYielded = pdFALSE; //延时的时间如果不大于0，那就相当于直接进行任务切换 if( xTicksToDelay &gt; ( TickType_t ) 0U ) &#123; configASSERT( uxSchedulerSuspended[ xPortGetCoreID() ] == 0 ); taskENTER_CRITICAL(&amp;xTaskQueueMutex); &#123; traceTASK_DELAY(); //计算唤醒时间 xTimeToWake = xTickCount + xTicksToDelay; //从就绪列表上移除 if( uxListRemove( &amp;( pxCurrentTCB[ xPortGetCoreID() ]-&gt;xGenericListItem ) ) == ( UBaseType_t ) 0 ) &#123; portRESET_READY_PRIORITY( pxCurrentTCB[ xPortGetCoreID() ]-&gt;uxPriority, uxTopReadyPriority ); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; //添加到延时列表中 prvAddCurrentTaskToDelayedList( xPortGetCoreID(), xTimeToWake ); &#125; taskEXIT_CRITICAL(&amp;xTaskQueueMutex); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; if( xAlreadyYielded == pdFALSE ) &#123; portYIELD_WITHIN_API(); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125;&#125; prvAddCurrentTaskToDelayedList函数1234567891011121314151617181920212223242526static void prvAddCurrentTaskToDelayedList( const BaseType_t xCoreID, const TickType_t xTimeToWake )&#123; //按照唤醒时间从小到达的顺序，插入延时列表 listSET_LIST_ITEM_VALUE( &amp;( pxCurrentTCB[ xCoreID ]-&gt;xGenericListItem ), xTimeToWake ); if( xTimeToWake &lt; xTickCount ) &#123; traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST(); //唤醒时间已经溢出，将其插入延时溢出列表中 vListInsert( pxOverflowDelayedTaskList, &amp;( pxCurrentTCB[ xCoreID ]-&gt;xGenericListItem ) ); &#125; else &#123; traceMOVED_TASK_TO_DELAYED_LIST(); //时间还没有溢出，插入延时列表中 vListInsert( pxDelayedTaskList, &amp;( pxCurrentTCB[ xCoreID ]-&gt;xGenericListItem ) ); //xNextTaskUnblockTime是一个全局变量，保存着距离下一个要取消阻塞的任务最小时间点值 if( xTimeToWake &lt; xNextTaskUnblockTime ) &#123; xNextTaskUnblockTime = xTimeToWake; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125;&#125; vTaskDelayUntil绝对延时函数 使用该函数延时的任务也不一定能够周期性的运行，该函数只能保证按照一定的周期取消阻塞，进入就绪态 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )&#123; TickType_t xTimeToWake; BaseType_t xAlreadyYielded=pdFALSE, xShouldDelay = pdFALSE; configASSERT( pxPreviousWakeTime ); configASSERT( ( xTimeIncrement &gt; 0U ) ); configASSERT( uxSchedulerSuspended[ xPortGetCoreID() ] == 0 ); taskENTER_CRITICAL(&amp;xTaskQueueMutex); &#123; const TickType_t xConstTickCount = xTickCount; //计算任务被唤醒的时刻 xTimeToWake = *pxPreviousWakeTime + xTimeIncrement; //tick计数器溢出 if( xConstTickCount &lt; *pxPreviousWakeTime ) &#123; //tick计数器和唤醒时间都溢出，且tick计数器值比唤醒时间小 if( ( xTimeToWake &lt; *pxPreviousWakeTime ) &amp;&amp; ( xTimeToWake &gt; xConstTickCount ) ) &#123; xShouldDelay = pdTRUE; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; else &#123; //tick计数器没有溢出，唤醒时间溢出或者tick计数器值比唤醒时间小，这两种情况都说明还需要继续延时 if( ( xTimeToWake &lt; *pxPreviousWakeTime ) || ( xTimeToWake &gt; xConstTickCount ) ) &#123; xShouldDelay = pdTRUE; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; //为本函数的下一次执行做好准备 *pxPreviousWakeTime = xTimeToWake; if( xShouldDelay != pdFALSE ) &#123; traceTASK_DELAY_UNTIL(); //从就序列表中移除 if( uxListRemove( &amp;( pxCurrentTCB[ xPortGetCoreID() ]-&gt;xGenericListItem ) ) == ( UBaseType_t ) 0 ) &#123; portRESET_READY_PRIORITY( pxCurrentTCB[ xPortGetCoreID() ]-&gt;uxPriority, uxTopReadyPriority ); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; prvAddCurrentTaskToDelayedList( xPortGetCoreID(), xTimeToWake ); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; taskEXIT_CRITICAL(&amp;xTaskQueueMutex); if( xAlreadyYielded == pdFALSE ) &#123; portYIELD_WITHIN_API(); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125;&#125; portYIELD_WITHIN_API宏定义12//上下文切换工作需要等待直到中断被允许后才执行，这里使用cross-core中断来触发自己#define portYIELD_WITHIN_API() esp_crosscore_int_send_yield(xPortGetCoreID()) xTaskIncreamentTick函数的主要功能 xTickCount是FreeRTOS的系统节拍计数器，每个滴答定时器中断后xTickCount就会增加一，xTickCount的具体操作是在函数xTaskIncrementTick中进行的 系统节拍计数器的值加1 判断是否有任务的延时等待时间已到，如果就就将其恢复 处理时间片调度 综上给出是否需要执行上下文切换的判断结果并返回滴答定时器中断 FreeRTOS队列队列结构体Queue_t12345678910111213141516171819202122232425262728293031323334typedef struct QueueDefinition&#123; int8_t *pcHead; //指向队列存储区开始位置 int8_t *pcTail; //指向队列存储区最后一个字节 int8_t *pcWriteTo; //指向存储区中下一个空闲区域 union &#123; int8_t *pcReadFrom; //用作队列时指向最后一个出队的队列项首地址 UBaseType_t uxRecursiveCallCount;//用作递归互斥信号量时用来记录递归互斥信号量被调用的次数 &#125; u; List_t xTasksWaitingToSend; //那些因为队列满导致入队失败而进入阻塞态的任务就会挂到此列表上，按照优先级排列 List_t xTasksWaitingToReceive; //那些因为队列空导致出队失败而进入阻塞态的任务就会挂到此列表上，按照优先级排列 volatile UBaseType_t uxMessagesWaiting;//队列中当前的消息数量 UBaseType_t uxLength; //队列中允许的最大的消息数量 UBaseType_t uxItemSize; //每个消息允许的最大长度 #if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) uint8_t ucStaticallyAllocated; //如果队列的内存是静态分配的，则为pdTRUE #endif #if ( configUSE_QUEUE_SETS == 1 ) struct QueueDefinition *pxQueueSetContainer; #endif #if ( configUSE_TRACE_FACILITY == 1 ) UBaseType_t uxQueueNumber; uint8_t ucQueueType; #endif portMUX_TYPE mux; //因为SMP的原因，所以需要互斥锁&#125; xQUEUE;typedef xQUEUE Queue_t; 创建队列xQueueCreate12345678910111213141516171819202122232425262728#define xQueueCreate( uxQueueLength, uxItemSize ) xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) )//普通消息队列的类型是queueQUEUE_TYPE_BASEQueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )&#123; Queue_t *pxNewQueue; size_t xQueueSizeInBytes; uint8_t *pucQueueStorage; configASSERT( uxQueueLength &gt; ( UBaseType_t ) 0 ); if( uxItemSize == ( UBaseType_t ) 0 ) &#123; xQueueSizeInBytes = ( size_t ) 0;//如果队列大小为0，那么就不需要存储区 &#125; else &#123; xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); &#125; pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );//分配内存，这里申请的内存大小是队列结构体和队列中消息存储区的总大小 if( pxNewQueue != NULL ) &#123; pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t ); #if( configSUPPORT_STATIC_ALLOCATION == 1 ) &#123; pxNewQueue-&gt;ucStaticallyAllocated = pdFALSE; &#125; #endif /* configSUPPORT_STATIC_ALLOCATION */ prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );//初始化队列 &#125; return pxNewQueue;&#125; 初始化队列prvInitialiseNewQueue1234567891011121314151617181920212223242526272829static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )&#123; ( void ) ucQueueType; if( uxItemSize == ( UBaseType_t ) 0 ) &#123; //没有队列存储区，这里将pcHead指向队列开始地址 pxNewQueue-&gt;pcHead = ( int8_t * ) pxNewQueue; &#125; else &#123; //设置pcHaed指向队列存储区首地址 pxNewQueue-&gt;pcHead = ( int8_t * ) pucQueueStorage; &#125; //初始化队列结构体相关成员变量 pxNewQueue-&gt;uxLength = uxQueueLength; pxNewQueue-&gt;uxItemSize = uxItemSize; ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );//复位队列 #if ( configUSE_TRACE_FACILITY == 1 ) &#123; pxNewQueue-&gt;ucQueueType = ucQueueType; &#125; #endif /* configUSE_TRACE_FACILITY */ #if( configUSE_QUEUE_SETS == 1 ) &#123; pxNewQueue-&gt;pxQueueSetContainer = NULL; &#125; #endif /* configUSE_QUEUE_SETS */ traceQUEUE_CREATE( pxNewQueue );&#125; 队列复位函数xQueueGenericReset1234567891011121314151617181920212223242526272829303132333435363738394041424344BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )&#123; Queue_t * const pxQueue = ( Queue_t * ) xQueue; configASSERT( pxQueue ); if ( xNewQueue == pdTRUE ) &#123; vPortCPUInitializeMutex(&amp;pxQueue-&gt;mux);//初始化互斥锁 &#125; taskENTER_CRITICAL(&amp;pxQueue-&gt;mux); &#123; pxQueue-&gt;pcTail = pxQueue-&gt;pcHead + ( pxQueue-&gt;uxLength * pxQueue-&gt;uxItemSize );//pcTail指向队列存储区的末尾 pxQueue-&gt;uxMessagesWaiting = ( UBaseType_t ) 0U;//队列中当前的消息数量是0 pxQueue-&gt;pcWriteTo = pxQueue-&gt;pcHead;//指向队列存储区中下一个可写入的位置 pxQueue-&gt;u.pcReadFrom = pxQueue-&gt;pcHead + ( ( pxQueue-&gt;uxLength - ( UBaseType_t ) 1U ) * pxQueue-&gt;uxItemSize );//指向队列存储区中下一个可读取的位置 if( xNewQueue == pdFALSE ) &#123; //由于复位队列以后队列依旧是空的，对于那些从队列中读取而被阻塞的任务来说依旧保持阻塞状态。但是对于那些向队列中写入数据而阻塞的任务来说，这些任务需要接触阻塞状态 if( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE ) &#123; if( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdTRUE ) &#123; queueYIELD_IF_USING_PREEMPTION(); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; else &#123; //初始化队列中的列表xTasksWaitingToSend和xTasksWaitingToReceive vListInitialise( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ); vListInitialise( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ); &#125; &#125; taskEXIT_CRITICAL(&amp;pxQueue-&gt;mux); return pdPASS;&#125; 向队列发送消息 函数 描述 xQueueSend 发送消息到消息队列的尾部（后向入队） xQueueSendToBack 发送消息到消息队列的尾部（后向入队） xQueueSendToFront 发送消息到队列头（前向入队） xQueueOverwrite 发送消息到消息队列，带覆写功能；队列满了以后自动覆盖掉旧的消息；通常用于向那些长度为1的队列发送消息 xQueueSendFromISR 发送消息到消息队列的尾部（后向入队），用于中断服务函数 xQueueSendToBackFromISR 发送消息到消息队列的尾部（后向入队），用于中断服务函数 xQueueSendToFrontFromISR 发送消息到队列头（前向入队），用于中断服务函数 xQueueOverwriteFromISR 发送消息到消息队列，带覆写功能；队列满了以后自动覆盖掉旧的消息，用于中断服务函数 xQueueGenericSend函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )&#123; BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired; TimeOut_t xTimeOut; Queue_t * const pxQueue = ( Queue_t * ) xQueue; configASSERT( pxQueue ); configASSERT( !( ( pvItemToQueue == NULL ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) 0U ) ) ); configASSERT( !( ( xCopyPosition == queueOVERWRITE ) &amp;&amp; ( pxQueue-&gt;uxLength != 1 ) ) ); #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) &#123; configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != 0 ) ) ); &#125; #endif for( ;; ) &#123; taskENTER_CRITICAL(&amp;pxQueue-&gt;mux); &#123; if( ( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength ) || ( xCopyPosition == queueOVERWRITE ) )//当队列未满或者是覆写入队，则可以将消息入队 &#123; traceQUEUE_SEND( pxQueue ); xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );//将消息复制到队列中 #if ( configUSE_QUEUE_SETS == 1 ) &#123; if( pxQueue-&gt;pxQueueSetContainer != NULL ) &#123; if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE ) &#123; /* The queue is a member of a queue set, and posting to the queue set caused a higher priority task to unblock. A context switch is required. */ queueYIELD_IF_USING_PREEMPTION(); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; else &#123; if( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE ) &#123; if( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdTRUE ) &#123; queueYIELD_IF_USING_PREEMPTION(); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; else if( xYieldRequired != pdFALSE ) &#123; queueYIELD_IF_USING_PREEMPTION(); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; &#125; #else /* configUSE_QUEUE_SETS */ &#123; if( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )//检查是否有任务由于请求队列消息而阻塞，阻塞的任务会挂在队列的xTasksWaitingToReceive列表上 &#123; //将阻塞的任务从列表xTasksWaitingToReceive上移除，并且把这个任务添加到就序列表中。如果调度器上锁，则这些任务就会挂到列表xPendingReadyList上。如果取消阻塞的任务的优先级比当前正在运行的任务优先级高，则还要标记需要进行任务切换。当函数xTaskRemoveFromEventList返回值为pdTRUE时，需要进行任务切换 if( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdTRUE ) &#123; queueYIELD_IF_USING_PREEMPTION(); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; else if( xYieldRequired != pdFALSE ) &#123; queueYIELD_IF_USING_PREEMPTION(); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; #endif /* configUSE_QUEUE_SETS */ taskEXIT_CRITICAL(&amp;pxQueue-&gt;mux); return pdPASS; &#125; else//队列已满，入队有阻碍 &#123; if( xTicksToWait == ( TickType_t ) 0 )//没有设置阻塞时间或者等待时间已到 &#123; taskEXIT_CRITICAL(&amp;pxQueue-&gt;mux); traceQUEUE_SEND_FAILED( pxQueue ); return errQUEUE_FULL; &#125; else if( xEntryTimeSet == pdFALSE ) &#123; //设置超时时间结构体，记录当前系统始终节拍计数器的值xTickCount和溢出次数xNumOfOverflows vTaskSetTimeOutState( &amp;xTimeOut ); xEntryTimeSet = pdTRUE; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; &#125; taskEXIT_CRITICAL(&amp;pxQueue-&gt;mux); //代码执行到这里说明队列已满，而且设置了不为0的阻塞时间 taskENTER_CRITICAL(&amp;pxQueue-&gt;mux); if( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )//更新xTimeOut，并检查阻塞时间是否到了 &#123; if( prvIsQueueFull( pxQueue ) != pdFALSE )//队列依旧是满的 &#123; traceBLOCKING_ON_QUEUE_SEND( pxQueue ); vTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ), xTicksToWait );//将任务添加到队列的xTasksWaitingToSend列表和延时列表中，并且将任务从就绪列表中移除 taskEXIT_CRITICAL(&amp;pxQueue-&gt;mux); portYIELD_WITHIN_API(); &#125; else//阻塞时间还没有到，但是队列现在有空闲，那么就重新执行一次本循环 &#123; taskEXIT_CRITICAL(&amp;pxQueue-&gt;mux); &#125; &#125; else//需要阻塞的时间到了 &#123; taskEXIT_CRITICAL(&amp;pxQueue-&gt;mux); traceQUEUE_SEND_FAILED( pxQueue ); return errQUEUE_FULL; &#125; &#125;&#125; 从队列读取消息 函数 描述 xQueueReceive 从队列中读取消息，然后从队列中将其删除 xQueuePeek 从队列中读取消息，不会将其从队列中删除 xQueueReceiveFromISR 从队列中读取消息，然后从队列中将其删除，用于中断服务函数中 xQueuePeekFromISR 从队列中读取消息，不会将其从队列中删除，用于中断服务函数中 FreeRTOS信号量二值信号量和互斥信号量的差别 互斥信号量拥有优先级继承机制，而二值信号量没有优先级继承 二值信号量更适用于同步，而互斥信号量适用于简单的互斥访问 二值信号量 二值信号量其实就是只有一个队列项的队列，这个特殊的队列要么是满的，要么是空的，正好就是二值。任务和中断使用这个特殊队列的时候不用在乎队列中存在的是什么消息，只需要知道这个队列是满的还是空的即可，可以利用这个机制来完成任务和中断之间的同步。二值信号量使用的队列是没有存储区的，队列是否为空可以通过队列结构体的成员变量uxMessagesWaiting来判断。 函数 描述 xSemaphoreCreateBinary 动态创建二值信号量，新创建的二值信号量默认是空的 xSemaphoreCreateBinaryStatic 静态创建二值信号量 xSemaphoreGive 任务级信号量释放函数，可用于释放二值信号量、计数型信号量和互斥信号量 xSemaphoreGiveFromISR 中断级信号量释放函数，只能用于释放二值信号量和计数型信号量，不能释放互斥信号量(因为互斥信号量需要处理 优先级继承的问题，而中断不属于任务) xSemaphoreTake 任务级获取信号量函数，可用于获取二值信号量、计数型信号量和互斥信号量 xSemaphoreTakeFromISR 中断级获取信号量函数，只能用于获取二值信号量和计数型信号量，不能获取互斥信号量(因为互斥信号量需要处理 优先级继承的问题，而中断不属于任务) 1234#define xSemaphoreCreateBinary() xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE )#define xSemaphoreGive( xSemaphore ) xQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK )#define xSemaphoreTake( xSemaphore, xBlockTime ) xQueueGenericReceive( ( QueueHandle_t ) ( xSemaphore ), NULL, ( xBlockTime ), pdFALSE )#define xSemaphoreTakeFromISR( xSemaphore, pxHigherPriorityTaskWoken ) xQueueReceiveFromISR( ( QueueHandle_t ) ( xSemaphore ), NULL, ( pxHigherPriorityTaskWoken ) ) 计数型信号量 计数型信号量就是长度为大于1的队列，只是无需关心队列中存储了什么数据，计数型信号量主要应用场合是： 事件计数 每次事件发生的时候就在事件处理函数中释放信号量（增加信号量的计数值），其他任务会获取信号量来处理事件。在这种场合中，创建的计数型信号量初始计数值为0 资源管理 信号量值代表当前资源的可用数量，一个任务想要获得资源的使用权，首先必须获取信号量，成功以后信号量的值就会减1，当信号量值为0的时候就说明没有资源了。一个任务使用完资源以后一定要释放信号量，释放信号量以后信号量值会加1.在这种场合中，创建的计数型信号量初始值应该是资源的数量 函数 描述 xSemaphoreCreateCoumting 使用动态方法创建计数型信号量 xSemaphoreCreateCountingStatic 使用静态方法创建计数型信号量 xSemaphoreGetCount 获取计数型信号量的值 12345678910111213141516171819202122232425#define xSemaphoreCreateCounting( uxMaxCount, uxInitialCount ) xQueueCreateCountingSemaphore( ( uxMaxCount ), ( uxInitialCount ) )#define xSemaphoreCreateCountingStatic( uxMaxCount, uxInitialCount, pxSemaphoreBuffer ) xQueueCreateCountingSemaphoreStatic( ( uxMaxCount ), ( uxInitialCount ), ( pxSemaphoreBuffer ) )QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )&#123; QueueHandle_t xHandle; configASSERT( uxMaxCount != 0 ); configASSERT( uxInitialCount &lt;= uxMaxCount ); xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );//queueSEMAPHORE_QUEUE_ITEM_LENGTH=0 if( xHandle != NULL ) &#123; ( ( Queue_t * ) xHandle )-&gt;uxMessagesWaiting = uxInitialCount;//使用uxMessagesWaiting来计数 traceCREATE_COUNTING_SEMAPHORE(); &#125; else &#123; traceCREATE_COUNTING_SEMAPHORE_FAILED(); &#125; configASSERT( xHandle ); return xHandle;&#125; 优先级翻转 使用二值信号量的时候会遇到常见的问题——优先级翻转，优先级翻转在可剥夺内核中是非常常见的，在实时系统中不允许出现这种现场，这样会破坏任务的预期顺序。 常见场合描述如下： 当一个低优先级和一个高优先级任务同时使用同一个信号量，而系统中还有其他中等优先级任务时，如果低 优先级任务获得了信号量，那么高优先级的任务就会处于等待状态；但是，中等优先级的任务可以打断低优先级任务而先于高优先级任务运行（此时高优先级的任务在等待信号量，所以不能运行），这就出现了优先级翻转的现象。 互斥信号量 互斥信号量其实就是一个拥有优先级继承的二值信号量，在同步的应用中，二值信号量最适合。互斥信号量适合用于那些需要互斥访问的应用中。当一个互斥信号量正在被一个低优先级的任务使用，而此时有个高优先级的任务也尝试获取这个互斥信号量的话就会被阻塞。不过这个高优先级的任务会将低优先级任务的优先级提升到与自己相同的优先级，这个过程就是优先级继承。优先级继承尽可能地降低了高优先级任务处于阻塞态的时间，并且将已经出现的“优先级翻转“的影响降到最低。 函数 描述 xSemaphoreCreateMutex 使用动态方法创建互斥信号量 xSemaphoreCreateMutexStatic 使用静态方法创建互斥信号量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#define xSemaphoreCreateMutex() xQueueCreateMutex( queueQUEUE_TYPE_MUTEX )QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )&#123; Queue_t *pxNewQueue; const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0; pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType ); prvInitialiseMutex( pxNewQueue ); return pxNewQueue;&#125;static void prvInitialiseMutex( Queue_t *pxNewQueue )&#123; if( pxNewQueue != NULL ) &#123; pxNewQueue-&gt;pxMutexHolder = NULL; pxNewQueue-&gt;uxQueueType = queueQUEUE_IS_MUTEX; pxNewQueue-&gt;u.uxRecursiveCallCount = 0;//针对递归互斥信号量的计数器 vPortCPUInitializeMutex(&amp;pxNewQueue-&gt;mux);//初始化CPU内核的自旋锁 traceCREATE_MUTEX( pxNewQueue ); ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );//互斥信号量默认创建后就是有效的 &#125; else &#123; traceCREATE_MUTEX_FAILED(); &#125;&#125;void vPortCPUInitializeMutex(portMUX_TYPE *mux) &#123; mux-&gt;owner=portMUX_FREE_VAL; mux-&gt;count=0;&#125;/* 为了处理多核CPU带来的竞态，使用该结构体实现的“自旋锁” */typedef struct &#123; /* owner field values: * 0 - Uninitialized (invalid) * portMUX_FREE_VAL - Mux is free, can be locked by either CPU * CORE_ID_PRO / CORE_ID_APP - Mux is locked to the particular core * * Any value other than portMUX_FREE_VAL, CORE_ID_PRO, CORE_ID_APP indicates corruption */ uint32_t owner; /* count field: * If mux is unlocked, count should be zero. * If mux is locked, count is non-zero &amp; represents the number of recursive locks on the mux. */ uint32_t count;#ifdef CONFIG_FREERTOS_PORTMUX_DEBUG const char *lastLockedFn; int lastLockedLine;#endif&#125; portMUX_TYPE; 递归互斥信号量 已经获取了互斥信号量的任务就不能再次获取这个互斥信号量，但是递归互斥信号量不同，已经获取了递归互斥信号量的任务可以再次获取这个递归互斥信号量，而且次数不限。递归互斥信号量也有优先级继承的机制，所以任务使用完递归互斥信号量以后一定要记得释放。 函数 描述 xSemaphoreCreateRecursiveMutex 使用动态方法创建递归互斥信号量 xSemaphoreCreateRecursiveMutexStatic 使用静态方法创建递归互斥信号量 xSemaphoreGiveRecursive 释放递归互斥信号量 xSemaphoreTakeRecursive 获取递归互斥信号量 FreeRTOS软件定时器 软件定时器的回调函数是在定时器服务任务中执行的，所以一定不能在回调函数中调用任何会阻塞任务的API函数，比如定时器回调函数中千万不能调用vTaskDelay、vTaskDelayUntil，还有一些访问队列或者信号量的非零阻塞时间的API函数也不能调用。FreeRTOS提供了很多定时器相关的API函数，这些API函数大多使用FreeRTOS的队列发送命令给定时器服务任务，这个队列叫定时器命令队列，是供给FreeRTOS的软件定时器使用的，用户不能直接访问。 函数 描述 xTimerReset() 复位软件定时器 xTimerResetFromISR() 复位软件定时器，用在中断服务函数中 xTimerCreate() 使用动态方法创建软件定时器 xTimerCreateStatic() 使用静态方法创建软件定时器 xTimerStart() 开启软件定时器，用于任务中 xTimerStartFromISR() 开启软件定时器，用于中断中 xTimerStop() 停止软件定时器，用于任务中 xTimerStopFromISR() 停止软件定时器，用于中断中 FreeRTOS事件标志组 使用信号量同步时任务只能与单个的事件或任务进行同步，有时候某个任务可能需要与多个事件或任务进行同步，此时信号量就无能为力了。FreeRTOS为此提供了一个可选的解决办法——事件标志组。事件标志组的数据类型为EventGroupHandle_t，当configUSE_16_BIT_TICKS为1的时候，则事件标志组可以存储8个事件位；当configUSE_16_BIT_TICKS为0的时候，则事件标志组存储24个事件位。事件标志组中的所有事件位都存储在一个无符号的EventBits_t类型的变量中 函数 描述 xEventGroupCreate() 使用动态方法创建事件标志组 xEventGroupCreateStatic() 使用静态方法创建事件标志组 xEventGroupClearBits() 将指定的事件位清零，用在任务中 xEventGroupClearBitsFromISR() 将指定的事件位清零，用在中断服务函数中 xEventGroupSetBits() 将指定的事件位置1，用在任务中 xEventGroupSetBitsFromISR() 将指定的事件位置1，用在中断服务函数中 xEventGroupGetBits() 获取当前事件标志组的值（各个事件的值），用在任务中 xEventGroupGetBitsFromISR() 获取当前事件标志组的值，用在中断服务函数中 xEventGroupWaitBits() 等待指定的事件位 FreeRTOS任务通知 FreeRTOS的每个任务都有一个32位的通知值，任务控制块中的成员变量ulNotifiedValue就是这个通知值。任务通知是一个事件，假如某个任务通知的接收任务因为等待任务通知而阻塞，则向这个接收任务发送任务通知以后就会解除这个任务的阻塞状态。也可以更新接收任务的任务通知值，可以通过以下方法更新接收任务的通知值： 不覆盖接收任务的通知值（如果上次发送给接收任务的通知还没被处理） 覆盖接收任务的通知值 更新接收任务的通知值的一个或多个bit 增加接收任务的通知值 合理使用上面这些更改任务通知值的方法可以在一些场合中替代队列、二值信号量、计数型信号量和事件标志组，并且可以提高速度，减少RAM的使用量。 任务通知的局限： FreeRTOS的任务通知只能有一个接收任务，其实大多数的应用都是这种情况 接收任务可以因为接收任务通知而进入阻塞态，但是发送任务不会因为任务通知发送失败而阻塞 函数 描述 xTaskNotify 发送通知，带有通知值并且不保留接收任务原通知值，用在任务中 xTaskNotifyFromISR 发送通知，函数xTaskNotify的中断版本 xTaskNotifyGive 发送通知，不带通知值并且不保留接收任务的通知值，此函数会将接收任务的通知值加1，用于任务中 vTaskNotifyGiveFromISR 发送通知，函数xTaskNotifyGive的中断版本 xTaskNotifyAndQuery 发送通知，带有通知值并且保留接收任务的原通知值，用在任务中 xTaskNotifyAndQueryFromISR 发送通知，函数xTaskNotifyAndQuery的中断版本，用在中断服务函数中 ulTaskNotifyTake 获取任务通知，可以设置在退出此函数的时候将任务通知值清零或者减一。当任务通知用作二值信号量或者计数信号量的时候，使用此函数来获取信号量 xTaskNotifyWait 等待任务通知，比ulTaskNotifyTask更为强大，全功能版任务通知获取函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction )&#123; TCB_t * pxTCB; eNotifyValue eOriginalNotifyState; BaseType_t xReturn = pdPASS; configASSERT( xTaskToNotify ); pxTCB = ( TCB_t * ) xTaskToNotify; taskENTER_CRITICAL(&amp;xTaskQueueMutex); &#123; eOriginalNotifyState = pxTCB-&gt;eNotifyState;//保存当前任务通知状态 pxTCB-&gt;eNotifyState = eNotified;//更新任务通知状态为eNotified switch( eAction ) &#123; case eSetBits: pxTCB-&gt;ulNotifiedValue |= ulValue;//更新接收任务通知值的一个或多个bit break; case eIncrement: ( pxTCB-&gt;ulNotifiedValue )++;//将任务通知值加1 break; case eSetValueWithOverwrite: pxTCB-&gt;ulNotifiedValue = ulValue;//直接覆写原来的任务通知值 break; case eSetValueWithoutOverwrite: if( eOriginalNotifyState != eNotified )//原来的任务通知已经被处理 &#123; pxTCB-&gt;ulNotifiedValue = ulValue; &#125; else//原来的任务通知没有被处理 &#123; xReturn = pdFAIL; &#125; break; case eNoAction: break; &#125; //判断任务是否因为等待任务通知值而进入了阻塞态 if( eOriginalNotifyState == eWaitingNotification ) &#123; ( void ) uxListRemove( &amp;( pxTCB-&gt;xGenericListItem ) );//将任务从状态列表中移除 prvAddTaskToReadyList( pxTCB );//将任务重新添加到就绪列表 configASSERT( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) == NULL ); if( tskCAN_RUN_HERE(pxTCB-&gt;xCoreID) &amp;&amp; pxTCB-&gt;uxPriority &gt; pxCurrentTCB[ xPortGetCoreID() ]-&gt;uxPriority )//判断刚刚解除阻塞的任务优先级是否比当前正在运行的任务优先级高 &#123; portYIELD_WITHIN_API(); &#125; else if ( pxTCB-&gt;xCoreID != xPortGetCoreID() ) &#123; taskYIELD_OTHER_CORE(pxTCB-&gt;xCoreID, pxTCB-&gt;uxPriority); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; taskEXIT_CRITICAL(&amp;xTaskQueueMutex); return xReturn;&#125;uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )&#123; TickType_t xTimeToWake; uint32_t ulReturn; taskENTER_CRITICAL(&amp;xTaskQueueMutex); &#123; if( pxCurrentTCB[ xPortGetCoreID() ]-&gt;ulNotifiedValue == 0UL )//还没有接收到任务通知 &#123; pxCurrentTCB[ xPortGetCoreID() ]-&gt;eNotifyState = eWaitingNotification;//任务通知状态改为eWaitingNotification if( xTicksToWait &gt; ( TickType_t ) 0 ) &#123; //将任务添加到延时列表，并进行任务调度 if( uxListRemove( &amp;( pxCurrentTCB[ xPortGetCoreID() ]-&gt;xGenericListItem ) ) == ( UBaseType_t ) 0 ) &#123; portRESET_READY_PRIORITY( pxCurrentTCB[ xPortGetCoreID() ]-&gt;uxPriority, uxTopReadyPriority ); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; #if ( INCLUDE_vTaskSuspend == 1 ) &#123; if( xTicksToWait == portMAX_DELAY ) &#123; traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB); vListInsertEnd( &amp;xSuspendedTaskList, &amp;( pxCurrentTCB[ xPortGetCoreID() ]-&gt;xGenericListItem ) ); &#125; else &#123; xTimeToWake = xTickCount + xTicksToWait; prvAddCurrentTaskToDelayedList( xPortGetCoreID(), xTimeToWake ); &#125; &#125; #else /* INCLUDE_vTaskSuspend */ &#123; xTimeToWake = xTickCount + xTicksToWait; prvAddCurrentTaskToDelayedList( xTimeToWake ); &#125; #endif /* INCLUDE_vTaskSuspend */ portYIELD_WITHIN_API(); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; taskEXIT_CRITICAL(&amp;xTaskQueueMutex); taskENTER_CRITICAL(&amp;xTaskQueueMutex); &#123; ulReturn = pxCurrentTCB[ xPortGetCoreID() ]-&gt;ulNotifiedValue;//任务通知值不为0，则先获取任务通知值 if( ulReturn != 0UL ) &#123; if( xClearCountOnExit != pdFALSE ) &#123; pxCurrentTCB[ xPortGetCoreID() ]-&gt;ulNotifiedValue = 0UL; &#125; else &#123; ( pxCurrentTCB[ xPortGetCoreID() ]-&gt;ulNotifiedValue )--; &#125; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; pxCurrentTCB[ xPortGetCoreID() ]-&gt;eNotifyState = eNotWaitingNotification;//更新任务通知状态为eNotWaitingNotification &#125; taskEXIT_CRITICAL(&amp;xTaskQueueMutex); return ulReturn;&#125; FreeRTOS中的空闲任务 空闲任务不仅仅是为了满足任务调度器启动以后至少有一个任务运行而创建的，空闲任务中还会去做一些其他的事情，如下： 判断系统中是否有任务删除自己，如果有，则在空闲任务中释放被删除任务的任务堆栈和任务控制块的内存 运行用户设置的空闲任务钩子函数 判断是否开启低功耗tickless模式，如果开启，则还需要做相应的处理 用户可以创建与空闲任务优先级相同的应用任务，当宏configIDLE_SHOULD_YIELD为1时，空闲任务会让出时间片给相同优先级的应用任务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879static portTASK_FUNCTION( prvIdleTask, pvParameters )&#123; ( void ) pvParameters; for( ;; ) &#123; //检查是否有任务要删除自己，如果有，则释放这些任务的任务控制块TCP和任务堆栈的内存 prvCheckTasksWaitingTermination(); #if ( configUSE_PREEMPTION == 0 ) &#123; //如果没有使用抢占式内核，则强制执行一次任务切换，查看是否有其他任务有效；如果有使用抢占式内核，则不需要这一步，因为只要有任何任务就绪，之后都会自动抢夺CPU使用权 taskYIELD(); &#125; #endif /* configUSE_PREEMPTION */ #if ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configIDLE_SHOULD_YIELD == 1 ) ) &#123; //如果使用抢占式内核并且使能时间片调度，则当有任务和空闲任务共享一个优先级，并且此任务处于就绪态时，空闲任务就应该放弃本时间片，将本时间片剩余的时间让给这个就绪任务。 if( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) &gt; ( UBaseType_t ) 1 ) &#123; taskYIELD(); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; #endif /* ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configIDLE_SHOULD_YIELD == 1 ) ) */ #if ( configUSE_IDLE_HOOK == 1 ) &#123; extern void vApplicationIdleHook( void ); //执行用户定义的空闲任务钩子函数，注意钩子函数里面不能使用任何可以引起阻塞空闲任务的API函数 vApplicationIdleHook(); &#125; #endif /* configUSE_IDLE_HOOK */ &#123; /* Call the esp-idf hook system */ esp_vApplicationIdleHook(); &#125; //如果使能了Tickless模式，则执行相关的处理代码 #if ( configUSE_TICKLESS_IDLE != 0 ) &#123; TickType_t xExpectedIdleTime; BaseType_t xEnteredSleep = pdFALSE; //获取处理器进入低功耗模式的时长 xExpectedIdleTime = prvGetExpectedIdleTime(); if( xExpectedIdleTime &gt;= configEXPECTED_IDLE_TIME_BEFORE_SLEEP ) &#123; taskENTER_CRITICAL(&amp;xTaskQueueMutex); &#123; //重新采集一次时间值 configASSERT( xNextTaskUnblockTime &gt;= xTickCount ); xExpectedIdleTime = prvGetExpectedIdleTime(); if( xExpectedIdleTime &gt;= configEXPECTED_IDLE_TIME_BEFORE_SLEEP ) &#123; traceLOW_POWER_IDLE_BEGIN(); xEnteredSleep = portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );//FreeRTOS进入低功耗Tickless模式 traceLOW_POWER_IDLE_END(); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; taskEXIT_CRITICAL(&amp;xTaskQueueMutex); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; if ( !xEnteredSleep )//FreeRTOS没有真的进入Tickless模式 &#123; esp_vApplicationWaitiHook();//CPU进入低功耗模式 &#125; &#125; #else esp_vApplicationWaitiHook(); #endif /* configUSE_TICKLESS_IDLE */ &#125;&#125; FreeRTOS低功耗Tickless模式 当处理器进入空闲任务周期以后就会关闭系统节拍中断（滴答定时器中断），只有其他中断发生或者其他任务需要处理的时候，处理器才会被从低功耗模式中唤醒。为此将会面临两大问题： 关闭系统节拍中断会导致系统节拍计数器停止，系统时钟就会停止。 我们需要记录下系统节拍中断的关闭时间，当系统节拍中断再次开启运行的时候补上这段时间即可，这时候就需要使用定时器来记录这段该补上的时间 如何保证下一个要运行的任务能被准确地唤醒？ 处理器在进入低功耗模式之前获取还有多长时间运行下一个任务，开启定时器，定时周期设置为这个时间，定时时间到了则产生定时中断，处理器就从低功耗模式唤醒了 Tickless的具体实现 要想使用Tickless模式，则必须首先将FreeRTOSConfig.h中的宏configUSE_TICKLESS_IDLE设置为1 使能Tickless模式以后，当下面两种情况都出现的时候，FreeRTOS内核就会调用宏portSUPPRESS_TICKS_AND_SLEEP来处理低功耗相关的工作: 空闲任务是当前唯一可运行的任务，因为其他所有的任务都处于阻塞或者挂起态 系统处于低功耗模式的时间至少大于configEXPECTED_IDLE_TIME_BEFORE_SLEEP个时钟节拍 处理器工作在低功耗模式的时间虽说没有任何限制，一个时钟节拍也行、滴答定时器所能计时的最大值也行，但是时间太短意义也不大，所以必须对工作在低功耗模式的时间做个限制，不能太短了，宏config EXPECTED_IDLE_TIME_BEFORE_SLEEP就是用来实现这个功能的 1234567891011121314151617181920212223242526272829303132333435363738394041#define portSUPPRESS_TICKS_AND_SLEEP( idleTime ) vApplicationSleep( idleTime )bool IRAM_ATTR vApplicationSleep( TickType_t xExpectedIdleTime )&#123; bool result = false; portENTER_CRITICAL(&amp;s_switch_lock); if (s_mode == PM_MODE_LIGHT_SLEEP &amp;&amp; !s_is_switching) &#123; //计算可以睡眠的时长 int64_t next_esp_timer_alarm = esp_timer_get_next_alarm(); int64_t now = esp_timer_get_time(); int64_t time_until_next_alarm = next_esp_timer_alarm - now; int64_t wakeup_delay_us = portTICK_PERIOD_MS * 1000LL * xExpectedIdleTime; int64_t sleep_time_us = MIN(wakeup_delay_us, time_until_next_alarm); if (sleep_time_us &gt;= configEXPECTED_IDLE_TIME_BEFORE_SLEEP * portTICK_PERIOD_MS * 1000LL) &#123; esp_sleep_enable_timer_wakeup(sleep_time_us - LIGHT_SLEEP_EARLY_WAKEUP_US);#ifdef CONFIG_PM_TRACE /* to force tracing GPIOs to keep state */ esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_ON);#endif int core_id = xPortGetCoreID(); ESP_PM_TRACE_ENTER(SLEEP, core_id); int64_t sleep_start = esp_timer_get_time(); esp_light_sleep_start();//开始睡眠 int64_t slept_us = esp_timer_get_time() - sleep_start; ESP_PM_TRACE_EXIT(SLEEP, core_id); uint32_t slept_ticks = slept_us / (portTICK_PERIOD_MS * 1000LL); if (slept_ticks &gt; 0) &#123; //根据实际休眠的时间来调整系统滴答计数器的值 vTaskStepTick(slept_ticks); //触发tick中断 XTHAL_SET_CCOUNT(XTHAL_GET_CCOMPARE(XT_TIMER_INDEX) - 16); while (!(XTHAL_GET_INTERRUPT() &amp; BIT(XT_TIMER_INTNUM))) &#123; ; &#125; &#125; result = true; &#125; &#125; portEXIT_CRITICAL(&amp;s_switch_lock); return result;&#125;","tags":[{"name":"FreeRTOS","slug":"FreeRTOS","permalink":"https://suda-morris.github.io/tags/FreeRTOS/"}]},{"title":"Learn Altium Designer","date":"2017-07-01T15:03:00.000Z","path":"2017/07/01/altium-desinger/","text":"软件汉化 DXP-&gt;Preferences 在System-&gt;General中选择Use localized resources复选框 重启软件 恢复桌面布局当文件桌面发生混乱时，可通过View-&gt;Desktop Layout-&gt;Default命令来恢复默认的桌面布局 公制与英制$1mil = 1/1000inch = 0.0254mm$ 设置图纸格点图纸格点设置包括两个方面，一个是图纸的Snap捕捉格点，一个是可视格点，还有一个是电栅格（电气格点）。 snap捕捉格点：表示放置线时可以捕捉到放置端点位置的点。 可视格点：表示可见到的网格大小 电栅格：绘制原理图的导线时系统会以电栅格大小为半径，以光标所在位置为中心进行查找电气节点，如果在此范围内有电气节点则光标会自动移动到此电气节点上 视图的刷新绘制原理图时，在完成滚动画面、移动元件等操作后，又会出现画面显示残留的斑点、线段或图形变性等问题。虽然这些内容不会影响电路的正确性，但是为了美观，通过View-&gt;Refresh命令可以使显示恢复 选择一个连接上的所有导线选择Edit-&gt;Select-&gt;Connection命令，将鼠标指针移动到某个连接的导线上，单击，则该连接上的所有导线都被选中，并高亮地显示出来，元器件也被特殊标示出来 绘制椭圆曲线在绘图工具栏中选择绘制椭圆，按Tab键，输入相应的配置参数后在不移动鼠标的情况下连续单击5次 使用Ultra Librarian软件自动生成原理图库和封装库 下载ULib，解压缩后安装 打开软件，Load Data导入bxl文件(芯片厂商提供) 选择输出格式为Altium Designer，然后Export，导出的文件一般放在软件目录的Exported下，比如D:\\UltraLibrarian\\Library\\Exported 数据文件导入 进入导出后的文件夹，用altium软件打开PrjScr工程文件 在打开的软件中双击打开UL_Form.pas文件，并运行 紧接着弹出的对话框中，选择导出文件夹下的【日期.txt]格式的文件 完成后会在相同的目录下生成需要的库文件 使用Altium软件完成余下工作 测量距离快捷键：Ctrl+M Mechanical13和Mechanical15 Mechanical13用于代表元件封装本体外形 Mechanical15用于表示囊括元件外形（包括管脚）所需的最小矩形 从PCB文件生成封装库文件 Altium提供了一个从PCB文件生成封装库文件的功能，该功能自动创建一个封装库并将PCB文件中所有用到的元件封装导入该封装库 方法：在PCB编辑器中单击：Design-&gt;Make PCB Library 敷铜 印刷线路板上大面积的敷铜通常有两种，一种用作散热，一种用作屏蔽来减小干扰 大面积敷铜上一般要开窗口（网状），这是由于印刷线路板板材的基板与铜箔之间的粘合剂在浸焊或长时间受热（如波峰焊），会产生挥发性气体无法排出，热量不易散发，以致产生铜箔膨胀、脱落现象。 每个板卡都包含了大量敷铜多边形，在设计时一个方便的管理方法就是把他们堆放在一起，即所谓敷铜搁置，也称敷铜堆放。堆放敷铜多边形不会将他们删除，而是把它们放进PCB文件中保留其完整的定义，但在设计窗口中他们将不再出现。 敷铜管理器：Tool-&gt;Polygon Pours-&gt;Polygon Manager PCB的组成部分 元件：用于完成电路功能的各种器件 铜箔：铜箔在电路板上可以表现为导线、焊盘、过孔和敷铜等 丝印层：印刷电路板的顶层，采用绝缘材料制成。在丝印层上可以标注文字，注释电路板上的元件和整个电路板。丝印层还能起到保护顶层导线的功能 印制材料：采用绝缘材料制成，用于支撑整个电路板 PCB的板层 Altium Designer提供堆栈管理器对各层属性进行管理，在堆栈管理器中可以定义层的结构，看到堆栈层的立体效果。选择：Design-&gt;Layer Stack Manager PCB工作层面可以分成以下几种类型： 信号层：即为用于建立电气连接的铜箔层 内平面：是专门用于建立电源网络的铜箔，可以算作信号层的一种 机械层：是用于支持电路板的印制材料层 掩膜层：为了方便焊接而设立的 Top/Bottom Solder，阻焊层，是指印刷电路板要上绿油的部分。实际上这阻焊层使用的是负片输出，所以在阻焊层的形状映射到板子上以后，并不是上了绿油阻焊，反而是露出了铜皮。所以阻焊层的意思是在整片阻焊的绿油上开窗，目的是允许焊接，默认情况下，没有阻焊层的区域都要上绿油 Top/Bottom Paste，锡膏防护层，这一层只要露出所有需要焊接的焊盘 丝印层：即电路板的说明文字层 其余层 Drill Guide和Drill Drawing：用于描述钻孔图及钻孔位置 Keep-out Layer：禁止布线层 Multi-Layer：设置更多层面 电路板物理与电气边界 电路板的物理边界由机械层1来定义 电路板的电气边界由Keep-out层来定义 一般物理边界与电气边界间距50mil即可。比如电路板大小为5000milX4000mil，那么电气边界大小为4900milX3900mil PCB设计规则 一般每个特定的网络布线宽度规则需要添加一个规则名称，以便与其他网络区分 通常为了降低布线间的耦合面积，减小干扰，不同层的布线需要设置成不同的走向。如双层板，默认状态下顶层为垂直走向，底层为水平走向。 表贴式焊盘的引出导线一般都是引出一段长度后才开始拐弯，这样就不会出现和相邻焊盘太近的情况 阻焊层扩展 通常阻焊层除焊盘或过孔外，整面都铺满阻焊剂。阻焊层的作用就是防止不该被焊上的部分被焊锡连接，回流焊就是靠阻焊层实现的。板子整面经过高温的锡水，没有阻焊层的裸露电路板就被粘锡焊接了，而有阻焊层的部分则不会粘锡。阻焊层的另一个作用是起到提高布线的绝缘性，防氧化和美观 阻焊剂印制到电路板上时，焊盘或过孔被空出，空出的面积要比焊盘或过孔大一些，这就是阻焊层扩展 锡膏防护层扩展 表贴式组件在焊接前，先对焊盘涂一层锡膏，然后将组件粘在焊盘上，再用回流焊机焊接。通常在大规模生产时，标贴式焊盘的涂膏是通过一个钢模完成的。钢模上对应焊盘的位置按焊盘形状镂空，涂膏时将钢模覆盖在电路板上，将锡膏放在钢模上，用括板来回括，锡膏通过镂空的部位涂到焊盘上。PCB设计软件的锡膏层或锡膏防护层的数据就是用来制作钢模的，钢模上镂空的面积要比设计焊盘的面积小，这个差值便是锡膏防护层扩展，默认是0mil 在数字电路中，是否为高频电路取决于信号的上升沿和下降沿，而不是信号的频率 当系统工作在50MHz时，将产生传输线效应和信号完整性问题。当系统时钟达到120MHz时，除非使用高速电路设计知识，否则基于传统方法设计的PCB将无法工作。 通常约定如果线传播延时大于数字信号驱动端的上升时间，则认为此类信号是高速信号并产生传输线效应 PCB上每英寸/单位的延时时间为0.167ns，但是如果过孔多，器件引脚多，布线上设置的约束多，延时将增大 如果采用CMOS或TTL电路进行设计，工作频率小于10MHz时，布线长度应不大于7in。工作频率在50MHz以上时，布线长度应不大于1.5in。如果工作频率达到或超过75MHz时，布线长度应在1in。对于GaAs芯片最大的布线长度应为0.3in。 解决传输线效应的另一个方法是选择正确的布线路径和终端拓扑结构。走线的拓扑结构是指一根网线的布线顺序以及布线结构。当使用告诉逻辑器件的时候，除非走线分支长度保持很短，否则边沿快速变化的信号将被信号主干走线上的分支走线所扭曲。通常情形下，PCB走线采用两种基本拓扑结构，即菊花形布线和星形布线。 对于菊花形布线，布线从驱动端开始，一次到达各接收端。如果使用串联电阻来改变信号特性，串联电阻的位置应该紧靠驱动端。在控制走线的高次谐波干扰方面，菊花链走线效果最好。 星形拓扑结构可以有效避免时钟信号的不同步问题，但在密度很高的PCB上手工完成布线十分困难。采用自动布线器是完成星形布线的最好方法。每条分支上都需要终端电阻。终端电阻的阻值应和连线的特征阻抗相匹配。 等长网络布线规则也称为匹配网络长度规则，用于设置指定网络等长布线规则。该规则以规定范围中的最长布线为基准，使其他网络通过匹配调整操作，以增长布线的形式在设定的公差范围内与之等长。增长的布线按设定的迂回模式（折现模式）进行布线。 在高速PCB设计时，设计者总是希望过孔越小越好，这样板上就可以有更多的布线空间。此外，过孔越小，其自身的寄生电容也越小，更适合用于高速电路。但孔尺寸的减小同时带来了成本的增加。当孔的深度超过钻孔直径的6倍时，就无法保证孔壁能均匀镀铜。随着激光钻孔技术的发展，钻孔的尺寸越来越小，一般直径小于等于6mil的过孔称为微孔。 过孔在传输线上表现为阻抗不连续的断点，会造成信号的反射。一般过孔的等效阻抗比传输线低12%左右。但过孔因为阻抗不连续而造成的反射其实是微乎其微的，其反射系数仅为0.06，过孔产生的问题更多的集中在寄生电容和电感的影响。过孔的寄生电容会给电路造成的主要影响是延长了信号的上升时间，降低了电路的速度。 在实际设计中可以通过增大过孔和敷铜区的距离或者减小焊盘的直径来减小寄生电容 在高速数字电路的设计中，过孔的寄生电感带来的危害往往大于寄生电容的影响。它的寄生串联电感会削弱旁路电容的贡献，减弱整个电源系统的滤波效用。 如果要在PCB文件中有几个电源和地线，则需要建立布线类规则来增加电源和地线的宽度 添加泪滴及敷铜 添加泪滴是指在导线与焊盘/过孔的链接处添加一段过渡铜箔，过渡铜箔呈现泪滴状。泪滴的作用是增加焊盘/过孔的机械强度，避免应力集中在导线与焊盘/过孔的连接处，而使连接处断裂或焊盘/过孔脱落。单击Tools-&gt;Teardrops 网格状填充区又称敷铜，敷铜就是将电路板中空白的地方铺满铜箔，添加敷铜不仅仅是为了好看，最主要的目的是提高电路板的抗干扰能力，起到屏蔽外界干扰的效果，通常将敷铜接地，这样电路板中空白的地方就铺满了接地的铜箔。 修改PCB的形状大小 在PCB页面用Keep-Out Layer画出所需板子的大小形状，必须是封闭的形状 选中画出的这些封闭的框框 Design-&gt;Board Shape-&gt;Define from selected objects PCB Logo制作 DXP-&gt;Run Script 选择PCB Logo Creator下的工程文件 PCB Logo Creator脚本工程 选择RunConverterScript，点击OK 选择bmp图片开始转换 点击Load选择需要使用的bmp位图 选择好丝印层，点击Convert，等待转换结束 硬件构件化电路原理图绘制的规则 硬件构建分类 核心构件：只提供接口，没有需求接口，比如芯片的硬件最小系统 中间构件：既有需求接口，又有提供接口，比如232电平转换构件 终端构件：只有需求接口，比如LCD构件 通用规则 元器件命名格式 核心构件：其元器件直接编号命名，同种类型的元件命名时冠以相同的字母前缀，如R1，R2 中间构件和终端构件：元器件命名格式采用“构件名-标志字符？”，例如LCD构件中所有的电阻名称统一为“LCD-R” 为硬件构件添加详细的文字描述 将前两歩产生的内容封装在一个虚线框内，组成硬件构件的内部实体 为该硬件构件添加与其他构件交互的输入、输出接口标识。接口标识有两种 接口注释：位于虚线框内，是为构件接口所作的解释性文字，采用斜体 接口网标：位于虚线框外，具有电气特性 核心构件设计规则 核心构件的接口标识均为网标，若同意引脚具有不同功能，则接口网标依据第一功能选项命名 中间构件设计规则 描述需求接口采用接口注释，描述提供接口采用接口网标 直观起见，将构件的需求接口放置在构件实体的左侧，提供接口放置在右侧 接口网标的命名规则是：构件名称-引脚信号/功能名称 接口注释名称前的构件名称可有可无 终端构件设计规则 接口标识均为斜体标注的接口注释 布线总结 按小键盘的*键或大键盘的数字2键添加一个过孔 按L键可以切换布线层 按数字3可设定最小线宽、典型线宽、最大线宽的值进行切换 差分布线 差分网络是两条存在耦合的传输线，一天携带信号，另一条则携带它的互补信号。使用差分对布线前要对设定差分对网络进行设置。设置可以在原理图中设置，也可以在PCB中进行设置 原理图中添加差分对规则:在命名差分对网络时，必须保证网络名的前缀是一样的，后缀中用下划线带一个N和一个P字母即可。命名好之后，点击菜单Place-&gt;Directives-&gt;DifferentialPair命令，在差分对上放置两个差分图标 Altium中绘制自定义焊盘 在Top Overlay层绘制自定义焊盘的轮廓 绘制自定义焊盘的轮廓 选中轮廓，Tool-&gt;Convert-&gt;Create Region from Selected Primitives 创建Region 将创建的Region放置在Top Layer上 将创建的Region放置在Top Layer上 复制刚才得到的Region两次，分别放置在Top Paste和Top overlay层 Top Paste和Top overlay层 将Top Lay和Top paste，Top overlay层的图形重叠在一起，摆放到合适位置后，双击Top Layer的Region，打开Mask选项 打开Mask扩展选项 在自定义Region中间防止一个小焊盘，标上正确的Designator 放置焊盘 将新创建的封装库放到PCB文件中会出现警告信息，比如短路，需要在PCB界面中，使用design-&gt;netlist-&gt;configure physical nets来对这些无网络的元素进行处理 处理无网络的元素 6层板的层叠设置 Top层 GND2层 Signal3层 PWR4层 GND5层 Bottom层 常用快捷键 单层与多层显示切换：Shift+S 切换走线规则：Shift+R 选择走线线宽：Shift+W L打开层设置开关选项 S打开选择：S+L(线选)、S+I(框选) J跳转：J+C(跳转到器件)、J+N(跳转到网络) Q英寸和毫米切换 Delete删除已被选择的对象，E+D点选删除 切换层：小键盘上面的“+”、“-” A+T：向上对齐、A+L：向左对齐、A+R：向右对齐、A+B：向下对齐 测量：Ctrl+M（哪里要测点哪里）、R+P（测量边距） 改变走线模式：Shift+空格 选择过孔：Shift+W 等间距走线：T+T+M（不可更改间距），P+M（可更改间距） 走线时显示走线长度：Shift+g 选中物理连接：Ctrl+H Objects的显示与隐藏：Ctrl+D 单端蛇形线走线：T+R 清除错误标记：T+M Shift+空格键，在交互布线的过程中，切换布线形状 用户自定义快捷键 按住Ctrl点击需要自定义的命令图标，输入自定义的按键，如F2，F3等 多层板的添加与编辑 电源和地一般选择负片，信号层采用正片 常用的全局操作 更改丝印字体大小 过孔盖油 Chip器件的扇孔方式 Chip器件的扇孔方式 查看网络线的长度 Ctrl+鼠标中间 调整丝印位号到器件中心 全选过后A+P USB的阻抗匹配与电源完整性 通常设计差分线采用5mil的线宽以及5.5mil的线距即可满足差分阻抗90欧姆 USB的输出电流是500mA，需注意VBUS以及GND的线宽，线宽大于20mil即可满足载流要求 以太网的阻抗匹配 需要对RX±、TX±差分对进行阻抗匹配，通常阻抗控制在100欧姆，长度差控制在5mil以内 差分线的处理 变压器集成在网口的以太网PCB布局 suda-morris","tags":[{"name":"PCB","slug":"PCB","permalink":"https://suda-morris.github.io/tags/PCB/"},{"name":"Altium","slug":"Altium","permalink":"https://suda-morris.github.io/tags/Altium/"}]},{"title":"Interview By Code","date":"2017-07-01T12:02:00.000Z","path":"2017/07/01/interview-by-code/","text":"C语言面试 栈S中已存放若干大于0的整数元素，试编写将S中元素进行排序的算法，使得S中元素自栈顶至栈底由小到大排序。要求算法不借助任一辅助数据结构12345678910111213141516171819202122232425/*递归法*/void SortStack(Stack* S)&#123; int n,m; if(IsEmpty(S))&#123; return; &#125; m = Pop(S); if(IsEmpty(S))&#123; Push(S,m); return; &#125;else&#123; SortStack(S); n = Pop(S); if(n&lt;m)&#123; //n是最小的,m压栈后需要重新排序 Push(S,m); SortStack(S); Push(S,n); &#125;else&#123; //m是最小的，n第二小 Push(S,n); Push(S,m); &#125; &#125;&#125; 输入两个整数序列，第一个序列是栈的入栈序列，且递增有序。请判断第二个序列是否为合理的出栈序列123456789101112131415161718/*出栈序列A中的任一元素，若它的右边所有比它小的元素是从左向右递减的，则A就是一个可能的出栈序列*/int isValid(int A[],int n)&#123; int i,j,k; for(i=0;i&lt;n;i++)&#123; /*遍历数组中的每个数*/ k = A[i]; for(j=i+1;j&lt;n;j++)&#123; if(A[j] &lt; A[i])&#123; /*查看比A[i]小的数是否递减*/ if(A[j] &lt; k)&#123; k = A[j]; &#125;else&#123; return 0; &#125; &#125; &#125; &#125;&#125; 输入两个整数序列，第一个序列是栈的入栈序列，请判断第二个序列是否为该栈的出栈序列12345678910111213141516171819202122232425int matchOK(int A[], int n, int B[], int m)&#123; int i,j; Stack s = new Stack; j = 0; for(i=0;i&lt;n;i++)&#123; if(A[i] != B[j])&#123; s.push(A[i]); &#125;else&#123; j++; &#125; &#125; while(!s.isEmpty())&#123; if(s.getTop() != B[j])&#123; return 0; &#125;else&#123; j++; s.pop(); &#125; &#125; if(j != m)&#123; return 0; &#125;else&#123; return 1; &#125;&#125; 一个$m \\times n$的Young氏矩阵时一个$m \\times n$的矩阵，其中每一行的数据都从左到右排序，每一列的数据都从上到下排序。设有Young氏矩阵Y保存了$m \\times n$个整数，请实现函数，查找给定元素target是否保存在Y中，若查找成功，算法返回1，否则返回01234567891011121314151617int findElement(int n,int m, int A[][m],int target)&#123; //n行m列,起始位置取右上角 int i=0,j=m-1; //二分查找 while(i&gt;=0 &amp;&amp; i&lt;n &amp;&amp; j&gt;=0 &amp;&amp; j&lt;m)&#123; //往左走 if(A[i][j] &gt; target)&#123; j--; &#125;else if(A[i][j] &lt; target)&#123; //往下走 i++; &#125;else&#123; return 1; &#125; &#125; return 0;&#125; 往Young氏矩阵中插入新的元素，要求保证矩阵的行、列有序性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int insertElement(int n,int m, int A[][m],int target)&#123; /*先将插入元素target放在矩阵的右下角，选出上侧位置及左侧位置中的较大者K。若K&lt;target，则插入结束；若K&gt;target，则交换K与target，继续进行这个过程，直到找到合适的位置为止*/ int flag = 1; int i=n-1,j=m-1;//n行，m列，右上角 while(flag)&#123; //未到边界 if(i&gt;=0 &amp;&amp; j&gt;=0)&#123; //左侧大 if(A[i-1][j] &lt; A[i][j-1])&#123; if(target &lt; A[i][j-1])&#123; //往左走 A[i][j] = A[i][j-1]; j--; &#125;else&#123; flag = 0; &#125; &#125; //上侧大 else&#123; if(target &lt; A[i-1][j])&#123; //往上走 A[i][j] = A[i-1][j]; i--; &#125;else&#123; flag = 0; &#125; &#125; &#125; //触及左边界，只能往上走 else if(i&gt;=0)&#123; if(target &lt; A[i-1][j])&#123; A[i][j] = A[i-1][j]; i--; &#125;else&#123; flag = 0; &#125; &#125; //触及上边界，只能往左走 else&#123; if(target &lt; A[i][j-1])&#123; A[i][j] = A[i][j-1]; j--; &#125;else&#123; flag = 0; &#125; &#125; &#125; A[i][j] = target; return 1;&#125; 输入两棵二叉树A和B，判断B是否是A的子结构（子结构包括树形以及节点中的值均一致）123456789101112131415161718192021222324252627282930313233typedef struct TNode&#123; int element; struct TNode* left; struct TNode* right;&#125;*Btree;int HasSubtree(BTree root1,BTree root2)&#123; int result = 0; if(root1 &amp;&amp; root2)&#123; if(root1-&gt;element == root2-&gt;element)&#123; result = DoesTree1HaveTree2(root1,root2); &#125; if(result==0)&#123; result = HasSubtree(root-&gt;left,root2); &#125; if(result==0)&#123; result = HasSubtree(root-&gt;right,root2); &#125; &#125; return result;&#125;int DoesTree1HaveTree2(Btree root1,Btree root2)&#123; if(!root2)&#123; return 1; &#125; if(!root1)&#123; return 0; &#125; if(root1-&gt;element != root2-&gt;element)&#123; return 0; &#125; return DoesTree1HaveTree2(root1-&gt;left,root2-&gt;left) &amp;&amp; DoesTree1HaveTree2(root1-&gt;right,root2-&gt;right);&#125; 设计算法，计算二叉树T的最大子树和1234567891011121314151617int MaxSubTree(BiNode* T,int* s)&#123; //s保存当前结点为根的树的结点和 int a,b,m,n; a=b=0; if(!T)&#123; *s = 0; return 0; &#125; if(T-&gt;left==NULL &amp;&amp; T-&gt;right==NULL)&#123; *s = T-&gt;data; return T-&gt;data; &#125; m = MaxSubTree(T-&gt;left,&amp;a); n = MaxSubTree(T-&gt;right,&amp;b); *s = a+b+T-&gt;data; return Max3(*s,m,n);&#125; 已知由n(n≥2)各正整数构成的集合A={a$_k$|0≤k&lt;n}，将其划分为两个不相交的子集A$_1$和A$_2$，元素个数分别是n$_1$和n$_2$，A$_1$和A$_2$中元素之和分别为S$_1$和S$_2$。设计一个尽可能高效的划分算法，满足|n$_1$-n$_2$|最小且|S$_1$-S$_2$|最大(将$\\lfloor{n/2}\\rfloor$个元素放在A$_1$中，其余的元素放在A$_2$中，即可满足题目要求)1234567891011121314151617181920212223242526272829303132333435363738394041424344/*仿照快速排序的思想，基于枢轴将n个整数划分为两个子集，然后根据划分后的枢轴所处的位置i分别处理，无需对全部元素进行全排序*/int setPartition(int a[],int n)&#123; int pivotkey,low = 0,low0 = 0,high = n-1,high0 = n-1; int flag = 1,k = n/2,i; int s1=0,s2=0; while(flag)&#123; pivotkey = a[low]; while(low&lt;high)&#123; while(low&lt;high &amp;&amp; a[high]&gt;=pivotkey)&#123; high--; &#125; if(low!=high)&#123; a[low] = a[high]; &#125; while(low&lt;high &amp;&amp; a[low]&lt;=pivotkey)&#123; low++; &#125; if(low!=high)&#123; a[high] = a[low]; &#125; &#125;//end of while(low&lt;high) a[low] = pivotkey; if(low==k-1)&#123; flag = 0;//如果枢轴元素是第n/2个元素，划分成功 &#125;else&#123; if(low &lt; k-1)&#123; //枢轴及之前的所有元素属于A1 low0 =++low; high = high0; &#125;else&#123; //枢轴及之后的所有元素属于A2 high0 = --high; low = low0; &#125; &#125; &#125; for(i=0;i&lt;k;i++)&#123; s1 += a[i]; &#125; for(i=k;i&lt;n;i++)&#123; s2 += a[i]; &#125; return s2-s1;&#125; 用1,2,3,…9组成3个三位数abc,def和ghi，每个数字恰好使用一次，要求abc:def:ghi=1:2:3。1234567891011121314151617181920212223242526272829303132int main()&#123; int i,j; int i1,i2,i3; int array[10]; int flag = 1; //最小的三位数也就是123（要求每位数字不一样），三位数乘以3需要不超过1000 for(i=123;i&lt;333;i++)&#123; i1 = i; i2 = i*2; i3 = i*3; memset(array,0,sizeof(array)); array[i1/100]++; array[i1/10%10]++; array[i1%10]++; array[i2/100]++; array[i2/10%10]++; array[i2%10]++; array[i3/100]++; array[i3/10%10]++; array[i3%10]++; for(j=1;j&lt;=9;j++)&#123; if(array[j] != 1)&#123; flag = 0; &#125; &#125; if(flag)&#123; printf(\"%d %d %d\",i1,i2,i3); &#125; flag = 1; &#125; return 0;&#125; suda-morris","tags":[{"name":"C","slug":"C","permalink":"https://suda-morris.github.io/tags/C/"}]},{"title":"Machine Learning","date":"2016-09-05T04:36:12.000Z","path":"2016/09/05/machine-learning/","text":"机器学习（从例子中学习） 监督学习（有标注） 逻辑回归 决策树 无监督学习（无标注） K-means聚类算法 增强学习（半监督学习） 不是分类问题，也不是聚类的问题 研究的是决策问题（下棋、机器人寻路） 非完备信息 无训练样本 机器学习常见算法一览 机器学习常见算法 人脸识别大多都采用AdaBoost算法，本质上是决策树 垃圾邮件识别采用朴素贝叶斯算法 FP-Growth算法已经取代了Apriori算法 百度搜索结果的排序使用的是逻辑回归算法 增强学习（Reinforcement Learning），也称为强化学习 增强学习基本流程 由动物学习、参数扰动自适应控制等理论发展而来 算法分类 时序差分算法 Q学习 基本流程 Agent产生一个动作 环境接受该动作后状态改变 同时产生会报反馈给Agent 马尔可夫决策过程 –Markov Decision Processes,MDP增强学习的理论基础） 马尔科夫链（Markov Chain），也称为马氏链 状态转移图就是一个简单的马尔科夫链 数学定义： 马尔科夫链数学定义 状态转移的概率只依赖前一个状态 MDP模型 MDP模型 Q学习算法 Q学习算法是一种用来解决马尔可夫决策过程中最优化问题的方法，通过这种算法来更新Q矩阵（决策矩阵） Q函数： Q函数 模拟退火（马尔科夫蒙特卡罗（MCMC）思想） 以一定的概率接收目标函数值的下降 缓解了爬山算法容易陷入局部最优的缺陷 Q学习算法描述（训练） Q学习算法描述（训练） Q学习算法描述（使用） Q学习算法描述（使用） 数据分析和机器学习的区别 数据特点 交易数据vs行为数据 少量数据vs海量数据 采样分析vs全量分析 交易数据的一致性要求远远超过行为数据，典型的交易数据如银行转账，所以处理交易数据不能用NOSQL（NotOnlySQL）数据库 解决的业务问题不同，数据分析用来报告过去的事情，机器学习用来预测未来的事情 数据分析的目标用户是公司高层的决策者，机器学习的目标用户是个体 深度学习 是基于机器学习延伸出来的一个新的领域，由以人大脑结构为启发的神经网络算法为起源加之模型结构深度的增加发展，并伴随大数据和计算能力的提高而产生的一系列新的算法","tags":[{"name":"ML","slug":"ML","permalink":"https://suda-morris.github.io/tags/ML/"}]},{"title":"Docker Introduction","date":"2016-08-25T11:37:00.000Z","path":"2016/08/25/docker/","text":"Docker安装 内核要求：3.10以上 安装命令：curl -sSL https://get.docker.com/ | sh 启动docker：systemctl start docker 将docker加入到开机启动：systemctl enable docker Docker镜像分层技术 docker的镜像分层技术 docker镜像是运行环境和业务代码的整体打包 Aufs是Another Union File System的缩写，支持将多个目录挂载到同一个虚拟目录下 已构建的镜像会设置成只读模式，read-write写操作是在read-only上的一种增量操作，不影响read-only层 镜像仓库 Docker官方镜像中心（hub.docker.com） 从中心镜像仓库下载到宿主机本地上的镜像称为本地镜像 如果第一次下载镜像，会把镜像所有层都下载回来 利用镜像分层技术，如果主机上已经有layer存在，下载新增的layer，类似git代码提交机制 docker pull &lt;$images&gt; 删除镜像 docker rmi &lt;$images&gt;","tags":[{"name":"Docker","slug":"Docker","permalink":"https://suda-morris.github.io/tags/Docker/"}]},{"title":"Write English Essay","date":"2016-05-26T07:29:00.000Z","path":"2016/05/26/english-writting/","text":"英语论文写作要点 读者希望在句子的开始看到熟悉的信息，事实上科技论文通常会包含很多新术语，所以一个容易理解的句子应该从读者熟悉的信息开始而以新信息结束，并在他们之间平滑过渡。 不管什么时候，每当你开始写新句，你应该问问自己，这些词前面有没有被提过。一定要把提到过的放前面，没提过的放后面。 读者想在主语之后立刻看到行为动词，如果动词和主语之间相隔太远，阅读就会被寻找动词打断。短的主语紧跟着动词加上长的宾语效果会更好 读者期望每句只有一个重点，这个重点通常在句尾。把最好的，最重要的，和想要读者记住的东西放在句尾 每个段落都应该只讲一个故事，在这一段里表达多个观点会使读者很难知道该记住什么，这段想表达什么。一段的第一句要告诉读者这一段讲什么的，一段的最后一句应该是这段的结论或者告诉读者下一段是什么 对于表格来说，读者熟悉的信息应该出现在左边而新的信息出现在右边。做表格的另一个规则是把最好的留在最后，也就是最能使人感兴趣的结果应该放在最右边一列或在最后一行，因为这些地方是读者结束阅读并能留下印象的地方 对于图，我们至少应该对所有的标签使用大的黑体Helvetica字体，只画出重要的区域。精良不用彩色就能使曲线达到最大的区分 只提出一个中心命题，论文里的观点太多，不但不好写，问题也容易多，读者也不易记住你要说什么 在这个中心命题的基础上，用一个迷人（但绝不能夸张）的标题来吸引审稿人的兴趣。审稿人只审批感兴趣的论文 合理解释每一个参数，合理说明每一个步骤 问问自己是否提供了足够重复你工作的所有细节，审稿人越容易再现你的工作，他就越可能接受你的文章 必须有说服力，尽量做彻底而不是半成品的工作 引用所有重要的研究工作，特别是经典力作。 文章的结构 典型的科学论文包括标题，摘要，方法、实验步骤，结果，讨论，感谢和参考文献 结果是对科研事实的描述，而讨论是对结果的解释及说明它的意义，而不是重复结果的描述 建议从方法和结果部分开始写，因为你对方法和结果最熟悉，此外只有更好地理解方法和结果，才能确定中心命题 中心命题和标题都确定了以后，就该写引言了。第一件该做的事就是围绕中心命题来收集所有相关文献。搜索并研究所有最近和相关的文章，确认你有所有最新的论文。引用所有重要的文章，如果你不引用别人得到文献，别人也不会引用你的 引言的第一句最难写，因为它决定了你整个引言的走向。一个办法是把第一句和文章的标题连起来。在第一段以最基本和常见的术语来定义标题里用的一些术语。从这个术语，引入研究的领域和它的重要性。第二段应该对这个研究领域做一个鉴定性的论述。如果中心命题是关于解决一个问题的方法，这一段就应该指出这个当前研究中现存未解决的问题。描述解决这个问题的难度或挑战。第三段引入你提出的办法和它大致会带来什么效果。 讨论部分。可用于讨论的内容有：参数改变对结果的影响，与其他研究相比还有待解决的问题，将来或正在进行的工作 整片文章写完了，该写摘要了。典型的摘要包括课题领域的重要性（回到标题），要研究的问题，你方法的独特性，结果的意义和影响 构思与撰文 Introduction 在叙述前人成果之后，用However来引导不足，提出一种新方法或新方向 提出自己的观点：We aim to//This paper reports on//This paper provides results//This paper extends the method//This paper focus on//The purpose of this paper is to//Furthermore,Moreover,In addition,we will also discuss 圈定自己的研究范围：introduction的另一个作用就是告诉读者你文章的主要研究内容。在前言的结尾就必须明确提出本文研究的范围： 时间尺度 研究区域 最后的圆场：在前言的最后，还可以总结性的提出“这一研究对其他研究有什么帮助”，或者说further studies on…will be summarized in our next study (or elsewhere) Discussion 怎样提出观点 如果观点不是这篇文章最新提出的，通常要用We confirm that… 对于自己很自信的观点，可以用We believe that… 通常，由数据推断出一定的结论，用Results indicate,infer，suggest，imply that… 在极其特别时才可用We put forward(discover,observe)……for the first time来强调自己的创新 如果自己对所提出的观点不完全肯定，可用We tentatively put forward(interrprete this to…)Or The results may due to attributed to resulted from…… 连接词与逻辑 注意句子上下连贯，不能让句子独立。常见的连接词有：However，also，in addition，consequently，afterwards，moreover，Furthermore，further，althogh，unlike，in contrast，similarly，unfortunately，alternatively，parallel results，in order to，despite，for example，compared with，other results，thus，therefore 表示时间顺序：then，afterwards 表示两种对立的观点：AA put forward that…In contrast,BB believe或者Unlike AA,BB suggest 表示因果或者前后关系：Consequently，therefore，as a result 表明递进关系可用furthermore，further，moreover，in addition 注意段落布局的整体逻辑。我们经常要叙述一个问题的几个方面，这种情况下，一定要注意逻辑结构。第一段要明确告诉读者你要讨论几个部分 Therefore，there are three aspects of this problem have to be addressed. The first question involves…The second problem relates to…The third aspect deals with… 讨论部分包括什么内容 主要数据及其特征的总结 主要结论及与前人观点的对比 本文的不足。所谓不足，包络以下内容： 研究的问题有点片面，讨论时一定要说：If should be noted that this study has examined only…We concentrate on only…We have to point out that we do not…Some limitation of this study are 结论有些不足：The results do not imply…The results can not be used do determine（or be taken as evidence of）…Unfortunately,we can not determine this data…Our results are lack of…但是指出这些不足后，一定要马上再次加强本文的重要性以及可能采取的手段来解决这些不足，为别人或者自己的下一步研究打下伏笔，如：Not withstanding its limitation,this study does suggest…However,these problems could be solved if we consider……Despite its preliminary character,this study can clearly indicate 为了使文章清楚，第一次提出概念时，最好以括弧给出比较详细解释 绝对不能全面否定前人的成果，即使在你看来前人的结论完全不对。可以婉转地提出：Their studies may be more reasonable if they had…considered this situation或者Their results could be better convinced if they… 撰写外刊论文的体会 Introduction是外刊文章最难写的部分之一（另外就是Discussion）。要写好Introduction，最重要的是要保持鲜明的层次感和极强的逻辑性 阐述自己研究领域的基本内容。要尽量简洁明了，不啰嗦。 文献总结回顾。是Introduction的重头戏之一，要特别着重笔墨来描写。一方面要把该领域内过去和现在的状况全面概括出来，不能有丝毫的遗漏，特别是最新的进展和过去经典文献的引用。另一方面，文献引用和数据提供一定要准确，避免片面摘录部分结果而不反映文献的总体结果； 分析过去研究的局限性并阐明自己研究的创新点。 总结性描述论文的研究内容，可以分为一二三四等几个方面来描述，为Introduction做最后的收尾工作 Methods部分描述论文的实验过程，这一过程的写作相对较为简单，可按照实验对象、实验设备、实验材料、实验记录、实验分析方法等来阻止行文。用过去时态 Results的要求是翔实准确。结果提供一般是表和图。尽量使用最少的图提供最多的信息，最多不要超过8个。图片格式使用tif的比较多，不推荐使用bmp（jpg更不能用）。图和表格要放置在每一栏的顶部或者底部 Discussion可分为下面两个步骤来写（用现在时叙述已知或被证明的事实，用过去时描述本研究结果）： 选择要深入讨论的问题。Discussion的一个重要作用就是要突出自己研究的创新性，并体现出显著区别于他人的特点。 对选中的问题按照一定层次从多个角度进行讨论，说理要有根据、问题要讲清楚、讲透彻 Acknowleged&amp;Reference Ackonwledge主要分为两个，第一是表明研究的基金来源，中国一般都是Nature Science Foundation of China（NSFC，国家自然科学基金），写基金时一般要标注清楚基金号码第二是对参与人员（没有列在作者中的研究人员）和单位表示感谢，如果通过一审和最终接受发表，还要添上对editor的感谢，这是基本礼貌 Reference的重要在于格式。不同杂志对参考文献格式要求不一样 摘要是论文要点的浓缩，应在文章各主要部分完成后再写，这样有利于文章要点的提炼。通常&lt;250字 论文撰写时要自始至使用英语写，千万不要先写中文再翻译成英文，时态一般为过去时态。 英语学术论文写作的几个细节 时态：当提到本文、此图、此表等说明了、表达了什么时要用一般现在时，而不用一般过去时。 大小写：当提及具体第几章、节；图表；方程式时，首个字母通常要大写 research，study，investigate：research可做名词、动词，但是通常做名词使用，句中需要动词时常用study或者investigate来表达 increase和decrease均可做名词和动词 compose，consist：A is composed of B and C；A consists of B and C","tags":[{"name":"English","slug":"English","permalink":"https://suda-morris.github.io/tags/English/"}]},{"title":"SDN Introduction","date":"2016-05-22T12:02:34.000Z","path":"2016/05/22/sdn/","text":"SDN简介 SDN与传统网络的区别 软件定义网络（SDN）是一种网络网络虚拟化技术，利用OpenFlow协议把路由器的控制平面从数据平面中分离出来，以软件方式实现。这个架构可以让网络管理员在不更动硬件设备的前提下，以中央控制方式，用程序重新规划网络，为控制网络流量提供了新的方法，也提供了核心网络及应用创新的良好平台。 SDN的典型架构 SDN的典型架构共分三层 应用层包括各种不同的业务和应用 中间控制层主要负责处理数据平面资源的编排，维护网络拓扑、状态信息等 基础设施层负责基于流表的数据处理、转发和状态收集。 SDN本质上具有“控制和转发分离”、“设备资源虚拟化”和“通用硬件及软件可编程”三大特性。可以带来的好处有 设备硬件归一化，硬件只关注转发和存储能力，与业务特性解耦，可以采用相对廉价的商用架构来实现 网络的智能性全部由软件实现，网络设备的种类及功能由软件配置而定，对网络的操作控制和运行由服务器作为网络操作系统NOS来完成 对业务响应相对更快，可以定制各种网络参数，如路由、完全、策略、QoS、流量工程等，并实时配置到网络中，开通具体业务时间将缩短 OpenFlow OpenFlow是一种网络通讯协议，属于数据链路层，能够控制网络交换机或路由器的转送平面，借此改变网络数据包所走的网络路径 OpenFlow允许从远程控制网络交换机的数据转送表，通过新增、修改与移除数据包控制规则与行动，来改变数据包转送的路径。比起用访问控制列表（ACL）和路由协议，允许更复杂的流量管理。同时，OpenFlow允许不同应用商用一个简单，开源的协议去远程管理交换机 SDN的优势 喜欢同IT结构中的网络，根据业务需求部署上线以后，如果业务需求发生变动，重新修改响应网络设备上的配置是一件非常繁琐的事情。 在互联网、移动互联网瞬息万变的业务环境下，网络的高稳定与高性能还不足以满足业务需求，灵活性和敏捷性反而更为关键 SDN所做的事情是将网络设备上的控制权分离出来，由集中的控制器管理，无需依赖底层网络设备，屏蔽了来自底层网络设备的差异。而控制权是完全开放的，用户可以自定义任何想实现的网络路由和传输规则策略，从而更加灵活和智能 进行SDN改造后，无需对网络中每个节点的路由器反复进行配置，网络中的设备本身就是自动化连通的。只需要在使用时定义好简单的网络规则即可。 加入网络中有SIP、FTP、流媒体几种业务，网络的总带宽是一定的，那么如果某个时刻流媒体业务需要更多的带宽和流量，在传统网络中很难处理，在SDN改造后的网络中这很容易实现，SDN可以将流量整形、规整，临时让流媒体的管道更粗一些，让流媒体的带宽更大些，甚至关闭SIP和FTP的管道，待流媒体需求减少时在恢复原先的带宽占比 正是因为这种业务逻辑的开放性，使得网络作为“管道”的发展空间变为无限可能。如果未来云计算的业务应用模型可以简化为“云-管-端”，那么SDN就是“管”这一环的重要技术支撑","tags":[{"name":"SDN","slug":"SDN","permalink":"https://suda-morris.github.io/tags/SDN/"}]},{"title":"S3C6410 Introduction","date":"2016-05-15T13:04:55.000Z","path":"2016/05/15/s3c6410/","text":"总线 总线是计算机各部件之间传送数据、地址和控制信息的公共通道，按照相对于CPU的位置可以分为：片内总线和片外总线 总线带宽=（总线宽度/8）*总线频率 ARM系列的处理器按照AMBA（Advanced Microcontroller Bus Architecture）规范设计总线，包括AHB、ASB、APB Cache CPU在写Cache时，如果Cache与对应内存内容同步更新，则称为通写，如果只在写入Cache的内容移出时才更新对应内存内容，则称为回写 u-boot的编译配置 执行make smdk2410_config 将u-boot顶层目录下的mkconfig脚本生成配置文件include/config.mk，内容正是根据Makefile最开发板的配置生成的 ARCH=arm CPU=arm920t BOARD=smdk2410 VENDOR=samsung SOC=s3c24x0 Makefile的编译选项和规则在顶层目录的config.mk文件中定义。各体系结构通用的规则直接在该文件中定义。通过ARCH、CPU、BOARD、SOC等变量为不同硬件平台定义不同选项。不同体系结构的规则分别包含在各自的lib_xxx目录下的config.mk文件中 删减u-boot文件 删除board目录下非samsung的目录 cd board/ &amp;&amp; rm -rf ls | grep -v &quot;samsung&quot; 删除board/samsung目录下非smdk6400的目录 cd board/samsung/ &amp;&amp; rm -rf ls | grep -v &quot;smdk6400&quot; 删除cpu目录下非arm920t的目录 cd cpu/ &amp;&amp; rm -rf ls | grep -v &quot;arm1176&quot; 删除include目录中非arm架构和非generic的汇编头文件目录 cd include/ &amp;&amp; rm -rf ls | grep &quot;asm-&quot; | egrep -v &quot;arm|generic&quot; 删除include/asm-arm目录中非s3c64xx架构的头文件目录 cd include/asm-arm/ &amp;&amp; rm -rf ls | grep &quot;arch-&quot; | grep -v &quot;s3c64xx&quot; 删除include/configs目录下非smdk6400.h的目录和文件 cd include/configs/ &amp;&amp; rm -rf ls | grep -v &quot;smdk6400.h&quot; 删除u-boot顶层目录下非arm架构和非generic的库目录 rm -rf ls | grep &quot;lib_&quot; | egrep -v &quot;arm|generic&quot; 建立suda6410配置 选择u-boot中原有的smdk6400作为suda6410的移植依据。修改顶层Makefile，检索到smdk2410_config目标所在行，添加suda6410_config目标规则 修改Makefile 创建板级支持文件，将原来存放smdk6410板级相关初始化代码的文件夹复制并命名为suda6410对应功能的文件夹 创建板级支持文件 修改board/samsung/suda6410/下的Makefile 修改board/samsung/suda6410/下的Makefile 修改board/samsung/suda6410/下的config.mk，将原内容替换为如下代码。其中的TEXT_BASE指定最终u-boot镜像的链接基地址，LDSCRIPT则指定了连接器脚本的路径 board/samsung/suda6410/config.mk 创建板级配置文件 cd include/configs/ &amp;&amp; cp smdk6400.h suda6410.h u-boot的环境变量 bootdelay、baudrate、netmask、ethaddr、bootfile、bootargs、bootcmd、serverip、ipaddr、stdin、stdout、stderr 如果在启动的时候看到u-boot打印出“Warning-bad CRC，using default environment”则说明u-boot没有在存放环境变量的固态存储器中找到有效的环境变量，只好使用编译时定义的默认环境变量。只要运行saveenv就可以把默认环境变量写入固态存储器，下次启动就不会有这个警告了。 S3C6410处理器概述 S3C6410是一个32位的RISC微处理器，采用了32位内部总线架构，内部总线由AXI（先进的可扩展接口）、AHB和APB总线组成 包括许多硬件外设，如一个相机接口，TFT24位真彩色液晶显示控制器，系统管理器（电源管理等），4通道UART，32通道DMA，4通道定时器，通用的I/O端口，IIS总线接口，IIC总线接口，USB主设备，USB OTG，SD主设备 矢量浮点型（VFP）协处理器支持 ARM1176JZF-S核心时钟频率最高是667MHz 包含3个片上PLL：APLL，MPLL和EPLL APLL生成一个独立的ARM操作时钟 MPLL生成系统参考时钟 EPLL产生用作外设IP的时钟 系统控制器 6410的结构框图 系统控制器由时钟控制和电源管理控制两个部分组成 系统时钟控制 ARMCLK给CPU提供时钟 HCLK给AXI/AHB总线外设提供时钟 PCLK给APB总线外设提供时钟 S3C6410有3个PLL，一个仅用于ARMCLK，一个用于HCLK和PCLK，最后一个用于外设，特别是音频相关的时钟 S3C6410中电源管理有四个模块组成：通用时钟门控模式，空闲模式，停止模式和睡眠模式 通用时钟门控模式用来控制内部外设时钟的开关 空闲模式仅中断ARMCLK到CPU 停止模式禁用PLL，这种情况下，电力消耗仅仅因为漏电流 睡眠模式断开内部电源。为了使用睡眠模式，两个独立的电源是必需的。两个电源中的一个用于唤醒逻辑提供电力，另一个提供其他内部逻辑，包括CPU ARM1176处理器是通过64位AXI总线连接到几个内存控制器上的，这样做是为了满足带宽需求。 多媒体协处理器分为5个电源域，包括MFC（多格式编解码器），JPEG，Camera接口，TV译码器等等。当IP没有被一个应用程序所要求时，5个电源域可以进行独立的控制，以减少不必要的电力 6410的时钟树 S3C6410有3个PLL，分别是APLL，MPLL，和EPLL APLL用于产生RM时钟 MPLL用于产生系统主时钟，用于操作AXI、AHB和APB总线 EPLL用于特殊用途，主要用于外设，如UART，IIS，IIC等 当在AXI总线或者AHB总线上时，操作速度最大可达到133MHz，当在APB总线上时，最大的操作速度可以达到66MHz ARM核心寄存器 ARM11有13个32位的通用寄存器R0~R12，另外有3个32位的寄存器分别是SP、LR和PC GPIO特性 提供内部去抖滤波器 8通道复用ADC，最大500k采样/s和10位的分辨率 存储器映射 S3C6410支持32位物理地址域，并且这些地址域分成两部分，一部分用于存储，另一部分用于外设 通过SPINE总线访问主存，主存的地址范围是从0x0000_0000~0x6FFF_FFFF。主存部分分成四个区域：引导镜像区、内部存储区、静态存储区和动态存储区 引导镜像区的地址范围是从0x0000_0000~0x07FF_FFFF，但是没有实际的映射内存。引导镜像区反映一个镜像，这个镜像指向内存的一部分区域或者静态存储区。引导镜像的开始地址是0x0000_0000 内部存储区用于启动代码访问内部ROM和内部SRAM，也被称作steppingstone。每块内部存储器的起始地址是确定的，内部ROM的地址范围是0x0800_0000~0x0BFF_FFFF，但是实际存储仅32KB。该区域是只读的，并且当内部ROM启动被选择时，该区域能映射到引导镜像区。内部SRAM的地址范围是0x0C00_0000~0x0FFF_FFFF，但是实际存储仅4KB。当NAND闪存启动被选择时能映射到引导镜像区。 静态存储区的地址范围是0x1000_0000~0x3FFF_FFFF，通过该地址区域能访问SROM、SRAM、NOR Flash、同步NOR接口设备和Steppingstone。每一块区域代表一个芯片选择。例如地址范围从0x1000_0000~0x17FF_FFFF代表Xm0CSn[0]。每个芯片选择的开始地址是固定的。NAND Flash和CF/ATAPI不能通过静态存储区访问，因此任何Xm0CSn[5:2]映射到NFCON或CFCON，相关地址区域应当被访问。一个例外，如果Xm0CSn[2]用于NAND Flash，Steppingstone映射到存储区从0x2000_0000~0x27FF_FFFF 动态存储区域的地址范围是0x4000_0000~0x6FFF_FFFF。DMC0有权使用地址0x4000_0000~0x4FFF_FFFF，并且DMC1有权使用地址0x5000_0000~0x6FFF_FFFF。对于每一块芯片选择的起始地址是可以进行配置的 外设区域通过PERI总线被访问，它的地址范围是0x7000_0000~0x7FFF_FFFF。这个地址范围的所有的SFR能被访问。而且如果数据需要从NFCON或CFCON传输，这些数据需要通过PERI总线传输 bootloader的作用 boot的目的：跳到C语言中 关闭看门狗，中断，MMU，CACHE 配置系统工作时钟 配置SDRAM的控制器（行地址数、列地址数、多少块，周期性的充电） 让sp指针指向可读可写的设备区间中，满足递减栈的规则 用哪些模式，就要初始化哪些模式下的sp 每个模式的值不能覆盖其余模式 代码搬移 执行速度问题（Nor Flash比RAM的速度慢很多），把程序从nor-flash搬移到快速的内存 只把存储器的一部分代码执行出来，把存储在其他位置上的代码搬移到内存上，所以要对相应存储器的控制器进行初始化 bl main loader的目的 执行应用逻辑，点灯，uart，load linux kernel 链接脚本的构成要素 哪一个.o放到代码段的起始位置 所有的.o放到哪个基地址上 代码段、数据段等等是不连续的 .text代码段 .rodata只读数据段 .data初始化数据段 .bss未初始化数据段 6410的启动步骤上电后，6410会启动片内IROM中的程序(BL0，位于地址0x0800_0000~0x0BFF_FFFF，实际仅32KB)，这部分程序主要是初始化时钟，看门狗等外设，然后把SD卡或者NandFlash中的最开始4K字节的内容(BL1)加载到片内SRAM中(Stepping Stone区域，位于0x0C00_0000~0x0FFF_FFFF，实际仅用了4KB),这4K程序主要完成对SDRAM主存的配置，然后把bootloader全部的程序(BL1+BL2)加载到SDRAM中，并从Stepping Stone中跳转过去。BL2程序会把Nand Flash中的OS镜像加载到主存中，并跳转到OS的入口中运行。 异常向量的地址映射根据ARM的手册，一般异常发生以后会被映射到0x0000_0000或者0xFFFF_0000，这可以使用CP15协处理器的SCTLR寄存器去配置（bit13等于0代表异常向量表位于0x0000_0000）， ARM流水线技术 在ARM中，PC指针并不是指向当前正在运行的指令，而是指向当前运行的指令的地址+8（8个字节正好是两条指令，即三级流水线：取址，译码，执行） ARM的协处理器 CP15，涉及到CACHE，MMU，中断向量等的管理 CP14，涉及到仿真功能，设计仿真器的时候可能需要 CP12-13，保留为以后使用 CP11一般用于双精度浮点数的计算 CP10用于单精度浮点数的计算 CP8-9，保留为以后使用 CP0-7，ARM公司留个各生产厂家使用 冯诺依曼体系和哈佛体系 一般单片机如MSP430，Cortex-M3等会采用哈佛体系结构，内部集成了Flash和RAM，指令和数据总线分开，虽然总线很多，但是因为在芯片内部，无伤大雅 ARM7，ARM11，Cortex-A8等应用处理器会采用冯诺依曼体系结构，指令和数据总线共用。冯诺依曼体系能够省去相当多的数据总线和地址总线，由于代码和数据共享一块内存，经常会造成数据冲突，速度上产生瓶颈。为了缓解这种情况，引入了CACHE的机制。 ARM早期采用冯诺依曼结构，到了后来CPU主频越来越快，数据吞吐量很大，冯诺依曼已经无法满足。ARM更新了设计，芯片外部还是采用冯诺依曼体系，即一块RAM既存放代码又存放数据，但是芯片内部不采用单一的CACHE，而是采用哈佛体系结构，分成DCACHE和ICACHE两块。 在bootloader期间，还没有严格区分代码段与数据段，代码段有可能会被缓存到DCACHE中，导致修改后的代码无法被缓存到ICACHE中，造成CACHE与主存的不一致，因此在bootloader中需要清DCACHE和ICACHE Linux下查看二进制代码 hexdump -C file.bin | less，其中-C表示同时显示二进制和ASCII码 大端（Big Edian）与小端（Little Edian） Intel阵营支持小端，摩托罗拉支持大端，早期的ARM公司大小端都支持，通过寄存器配置来选择 摩托罗拉公司的衰落，导致小端格式直接成为市场主流，ARM也放弃了对大端格式的支持 但是在网络协议中，一直保持着大端的数据格式，数据传输也是先传高位再传低位 u-boot/kernel中的死循环高级用法见代码如下，其中b 1b表示跳转到之前一个标号“1”处，即back，b 1f表示跳转到后面一个标号“1”处，即forward1234561: b 1b1: b 1f1: b 1b VIM中跨文件的赋值粘贴 打开A文件，光标停在要开始赋值的文字那行，在命令模式下输入：”+单字母的变量名+要复制的行数+yy 打开B文件，光标停在要粘贴的文字的那行，在命令模式下输入：”+同上面的变量名+p DDR内存基本原理 DRAM工作原理 DRAM如何读写一个字节的数据 DDR内存条的构成 多个内存条并存 异步DRAM通信时序 异步DRAM与同步DRAM的时序对比 DDR SDRAM全称Double Data Rate Synchronize Dynamic Random Access Memory RAM中的R表示随机，意思是访问任意地址上的数据所花费的时间是一样的，区别于硬盘这类顺序访问存储器 SRAM中的S表示Static，静态内存。静态内存使用DQ触发器来保存一个位，一个位至少需要4~6g个晶体管 DRAM保存一个位只需要一个电容，由于电容值很小，会漏电，需要实时地去刷新一下（读出值，然后写回） SDRAM中的S表示同步，即CPU会提供一个时钟信号与之同步 Word Line也称行地址，Bit Line也称列地址，在DRAM中，每一个地址只保存1位。通过Array的形式堆叠在一起可以一次访问多个位。图中4个array组成了一个bank，8个bank拼在一起组成了一个memory device(即实际的DDR芯片) DDR SDRAM会在时钟的上升和下降沿都用来读写数据，数据传输速率提高了1倍 为什么需要DQS信号 普通的SDRAM可以在时钟上升沿把数据发送到数据总线，在时钟下降沿将数据稳定地锁存到SDRAM中，但是在DDR中，由于时钟的上升沿和下降呀都被使用，数据的稳定时刻DDR无法获知，因此引入了DQS信号来表征数据可以被锁存的稳定时刻 DDR中的DLL机制 DLL(Delay Lock Loop) CLk信号在DDR芯片内部也会产生延迟 DLL会进一步延迟外部时钟信号，使之加上内部走线延时正好满足一个周期，这样内部时钟上升沿与外部时钟上升沿可以保持一致 所以DDR芯片在上电reset之后需要一段时间来完成DLL的工作 DDR SDRAM模式寄存器MRS设定 DDR读时序图 典型的读时序过程 行激活 经过tRCD（Row to Column Delay）延时后可以输出列命令 经过tCAS（Column Access Strobe）延时后总线上开始输出数据 一个行操作总共花费的时间为tRAS（Row Access Strobe） 经过tRC（Row Precharge）时间的行预充电 整个过程称作一个cycle，时间为tRC（Row Cycle） DDR写时序图 典型的写时序过程 行激活 经过tRCD的延时后输出列命令 经过tCWD（Command wait delay）的延时后将数据放到总线上 经过tWR（Write Recovery）的延时后，DDR芯片将数据存储到了电容中 经过tRC（Row Precharge）时间的行预充电 典型刷新时序过程 典型的刷新时序过程 一次刷新完成两行，一次刷新花的时间tRFC（Refresh Cycle Time） tREFI表示平均周期刷新时间间隔 Precharge与Refresh的区别 precharge是对两根bitline预充电至VCC/2 refresh是每个一定的时间对电容进行充电（因为电容要漏电），间隔一般为64ms S3C6410的DDR控制器 DRAM控制器可以直接收一个DRAM控制器本身的指令，通过写指令到直接指令寄存器，DRAM控制器可以发送像“Precharge all”,”Autorefresh”,”NOP”,”MRS”(“EMRS”)这样的指令到SDRAM 在自动刷新计数器中，当刷新技术达到刷新周期的值时，控制器便会发出一个自动刷新指令对SDRAM进行周期性的刷新 DRAM控制器最多只能支持两个同一类型的芯片，每个芯片可分配最多256MB的地址空间。 MMU ARMv6的MMU由协处理器CP15控制，其功能是：地址映射（VA-&gt;PA），内存访问权限控制 虚拟地址到物理地址的转换过程：Micro TLB-&gt;Main TLB-&gt;Page Table Walk ARMv6的MMU进行地址映射时设计到两种页表，一级页表(first level page table)和二级页表(coarse page table) 关于映射方式有两种：段映射和页映射。段映射只用到一级页表，页映射用到一级页表和二级页表s 关于映射粒度：段映射的映射粒度有两种，1M section和16M supersection；页映射的映射粒度也有两种：4K small page和64K large page 硬件在做地址转换时，如何知道当前是什么映射方式以及映射粒度是多少呢？这些信息可以从页表的入口描述符中获得 一级页表总共包含4096个转换描述符，因为是通过虚拟地址的31：20位寻址的，12位能够表示的数最大是4096 通过虚拟地址的高12位偏移，找到页表中的对应描述符，判断描述符的最后两位，确定是什么转换，10的话表示段转换，01表示粗页(64K)转换,11表示细页(4K)转换。如果判断是段转换，将描述符的高12位取出，这个就是物理的基地址，再和虚拟地址的后20位拼接，就得到对应的物理地址。 制作uImage 工具：mkimage，位于uboot的tools文件夹下 命令使用： ##mkimage -n ‘my_kernel’ -A arm -O linux -T kernel -C none -a 0x50008000 -e 0x50008040 -d zImage uImage## 交叉编译器工具链使用 readelf 在操作系统基础之上的可执行文件至少包括两个部分，一个是真正的可执行代码的集合，另一个是头信息（Windows下是PE头，Linux下是ELF头），专门给操作系统看的,里面包括首先要运行的程序的入口地址（通过修改该入口地址可以制作木马） arm-linux-readelf -h u-boot size 读取可执行程序的大小，包括text，data，bss等等 size u-boot nm 查看可执行程序的符号列表（全局标签），T代表全局函数标签，t表示静态函数标签（被static修饰），D代表全局变量标签，d代表静态变量标签（被static修饰） nm u-boot strip 剔除符号列表，能够把可执行程序变小 string 查看可执行程序中的常量字符串 string u-boot objdump 反汇编 objdump -D u-boot objcopy 将ELF头信息剔除，只保留可执行程序中的text，data，bss等段 addr2line 为什么内核加载到内存0x50008000处，即偏移0x8000？ Linux内核在内核管理中需要建立MMU表，这个表需要在内存中预留一段空间来保存 u-boot启动linux内核的条件 需要在uboot中配置好bootargs环境变量 root=启动根文件系统在哪个设备，如ram，nfs或者flash init=内核启动后第一个可执行文件init进程从哪里来 console=内核启动时使用哪个设备作为控制台 文件系统的部署 ramdisk:内存磁盘类型的文件系统 root=/dev/ram initrd=0x21000000,8M init=/linuxrc console=ttySAC0,115200 测试过程中，需要先将ramdisk的内容（如initrd.img.gz）放在内存的0x21000000 如何将initrd.img.gz中的内容取出来？ gunzip initrd.img.gz sudo mount -t ext2 initrd.img ./swap/ 进入swap便能获得文件系统的具体内容 nfs root=/dev/nfs nfsroot=服务器IP地址:根文件系统目录的绝对路径 ip=开发板IP地址 init=/linuxrc console=ttySAC0,115200 Linux系统下查看启动参数 cat /proc/cmdline 根文件系统制作 bin dev etc lib proc usr var这些都是必需的，其他的都是可选的 创建终端会话设备console sudo mknod console c 5 1 查看busybox的链接依赖库 arm-linux-readelf -d busybox | grep NEEDED 一般需要的依赖是libc.so.6和libm.so.6 此外还需要链接库加载器ld-linux.so.3 busybox启动控制过程 init-&gt;inittab-&gt;/etc/init.d/rcS-&gt;/etc/init.d/S(0-9)(0-9)*-&gt;application 嵌入式常用的工具命令 设备驱动管理 fdisk fsck hwclock mkdosfs insmod rmmod lsmod mknod modprobe lsusb mdev mount unmount 文本编辑处理 mkdir mkfifo ln mv cp touch rm unlink awk cat cut find vi sed wc tar grep head tail less more xargs od stat 网络信息配置 udhcpc udhcpd route netstat ping ifconfig 系统信息管理 chmode clear date dd df echo free ipcrm ipcs ls ps pwd top uptime kill killall reboot sleep sysctl usleep fstab配置文件 fstab是文件系统启动后默认要挂载的文件系统 proc /proc proc defaults 0 0一行配置由6个字段组成 第一个字段表示设备名称 第二个字段表示挂载点 第三个字段表示文件系统类型 第四个字段表示挂载选项 第五个字段表示备份检查，0不检查 第六个字段表示文件系统完整性检查，0不检查 常用嵌入式文件系统 基于存储设备的文件系统 内存文件系统 tmpfs ramdisk Flash文件系统 cramfs squashfs jffs/jffs2 yaffs/yaffs2 ubifs 扩展SD卡文件系统 FAT32 ext2/ext3 网络文件系统 NFS Samba 基于逻辑的虚拟文件系统 进程文件系统 procfs 设备文件系统 devfs（老版本内核使用） sysfs Nand Flash硬件特性（以K9K8G08为例） 该芯片由两个K9F4G08芯片（chip）组成，每个chip包含了4个层（plane），每层1024块（block），每块64页（page），每页（2K+64）字节 由于Nand Flash的工艺不能保证其存储单元在其生命周期中保持性能的可靠，因此，在其生产及使用过程中会产生坏块。 坏块的特征是：编程/擦除这个块时，会产生编程或擦除错误，并反映到状态寄存器相应位上 Nand Flash出错时，一般不会造成整个快或者页不能读取或全部出错，而是整个页中只有一个或者几个位出错。一般使用一种比较专用的校验-ECC 典型的ECC算法如Hanming码，能纠正单比特错误和检测双比特错误，而且计算速度很快，但对1比特以上的错误无法纠正，对2比特以上的错误不能保证检测。利用ECC校验需要额外的空间来存放ECC校验码 Nand Flash中每一个页的主数据区后都有一个称为空闲区域或者冗余区域的存储空间，在Linux驱动中，习惯称为OOB（Out Of Band）区。OOB区用来存放主数据区数据的校验值（ECC校验码），当然，除了存放ECC校验码，该区域还被用作其他用途。比如：标记是否是坏块，存储ECC数据，存储一些和文件系统相关的数据，如yaffs文件系统会在oob中，存放很多和自己文件系统相关的信息。 Nand Flash以8个I/O端口多路复用的方式进行寻址。Nand Flash操作是通过向I/O端口发送相应的命令序列完成的。有的命令仅仅需要一个总线周期，如芯片复位命令、状态读写命令。其他的命令，如页的读写和块的擦除，则需要两个总线周期：一个周期用于装载，另一个周期用于执行。在页读写时，需要在相应请求命令发出后，再发出5个地址周期（2列地址和3行地址）进行寻址。在块擦除时，仅需要发出3个行地址周期。 列地址就是页内地址，由于K9K8G08页大小为2K+64字节，因此有效列地址总共12位，即A0~A11 行地址对应页的编号，用于确定具体那一页 Nand Flash的寻址单位是页，读写以页为单位，擦除以块为单位。 按照页大小不同，Nand Flash可以分为大页设备和小页设备，大页设备典型大小2048字节，小页设备典型页大小为512字节。对于大页设备，通过8位I/O通常需要5个地址周期寻址，小页设备则只需要4个周期。 MTD设备概述 MTD（Memory Technology Device）是介于原始闪存设备与上层应用之间的一个抽象层，为不同类型的闪存设备提供统一的操作接口，以供上层使用。MTD设备通常包括NAND、OneNAND、NOR、AG-AND、ECC’d NOR等 MTD设备具备一些独特的硬件特性，例如，MTD设备由擦除块构成，擦除快能够被写入，但是要想再次写入就必须重新擦除 MTD子系统不处理块设备，例如，MMC、eMMC、SD、CompactFlash等都不属于MTD，这些设备虽然多数内存存储单元都是用Nand Flash，但是他们并不是原始的闪存设备，而是通过集成在芯片内部的FTL（Flash Translation layer），使其具备块设备的特征，因此这些设备属于块设备系统，而不是MTD 闪存设备能够分成若干MTD分区，每一个MTD分区由一片连续的擦除块构成，因此MTD分区是建立在闪存的物理层上的。 Nand Flash控制器 在上电或系统复位之后，Nand Flash控制器自动加载4KB的启动代码。加载完成后，启动代码将在Stepping Stone中被执行。在自动导入期间，ECC是未被选中状态，因此，前8K的Nand Flash绝对不能有位错误 USB概述 Mini/Micro USB接口5根连接线中的4号引脚【ID】，用于区分是USB主控端（主机）还是USB设备端（从机）。当该引脚接地时表示是主控端，悬空时表示是设备端","tags":[{"name":"ARM","slug":"ARM","permalink":"https://suda-morris.github.io/tags/ARM/"}]},{"title":"Communication Principle","date":"2016-04-18T08:40:31.000Z","path":"2016/04/18/communication-principle/","text":"消息 语音信号的带宽大约4KHz，图像信号的带宽大约是6MHz，音乐信号的带宽大约20KHz 信道 两个基本问题： 信号衰减：导线的电阻与长度成正比；无线电波扩散本身减弱，且被阻挡物吸收 加性噪声：沿途的电阻、固态器件等(包括发送器和接收器中的处理电路)引入固有的随机噪声，最基本的是热噪声 其他问题： 外来干扰：其他电磁波、窜线的电信号 信号畸变：信道特性不理想。比如电话线中的寄生电容会使高频信号损失 白高斯噪声（White Gassian Noise）： 时域上，随机性服从高斯分布 频域上，噪声均匀分布在所有频率上 功率谱密度值N0/2（物理意义：每Hz内有多少噪声） 电磁波 电波传播主要由其频率值的大小决定。空中传播时主要有三种模式： 地波（Ground-Wave）模式：1~2MHz以下的电磁波主要按照这种模式传播，大致可以传输几十公里，主要用于调幅广播 天波（Sky-Wave）模式：3~30MHz的电波反射可以达到几百~1000Km远，主要用于长距离通信，大多数用于军事上 视线（Line-Of-Sight）模式：像广播那样作直线传播，高于30MHz，向上传播时会穿透电离层被反射回来；地面传播时，如遇到遮挡，信号会被阻断会显著衰减，用于电视广播。 频分技术的例子： 频分复用：有线通信中多个话音“错开频率”，共用一条电线传输 频分多址：多个无线用户使用各自的频率，同时接入通信系统 频分双工：每个用户采用不同频率接收和发送，两个方向同时传输 基带与频带传输 基带信号：频谱位于零频率附近的信号 基带传输：保持基带形式，直接传送消息信号 频带信号：频谱位于某高频附近 频带传输：把基带的消息信号转换为频带消息来传输 模拟通信系统 调制：将基带信号变换为适当的频带信号的过程，通常用正弦波携带消息 解调：调制的逆过程 数字通信系统 数字通信系统 格式化：规范化的数字符号序列，必要时，包括模数变化 基带调制：形成合适的电信号，基带信号通常是用脉冲生成 频带调制：转换为频带信号 发射机：将信号送入信道 同步：提供各种定时时钟，使各单元能够正确、有序地工作 信源编码：实现压缩编码，把原始数字消息里面的冗余压缩掉 加密：提供保密性 信道编码：故意加入特殊数据位（如奇偶校验位等），仪表接收端发现和纠正错误 复用：多种消息信号合并在一起 多址接入：多个用户进入与公用系统 频谱扩展：展宽信号频谱可增加抗干扰与保密性，也可以多址接入 数字技术vs模拟技术 天生的抗噪性 潜在的标准性 便利的实现性 幅度调制–用消息去控制正弦载波的幅度变化 常规调幅 常规调幅（Conv.AM） m(t)是调制信号 波形特点：消息凸显在载波包络上 移植载波双边带调幅（DSB-SC） 单边带调幅（SSB） 残留边带调幅（VSB）","tags":[{"name":"Communication","slug":"Communication","permalink":"https://suda-morris.github.io/tags/Communication/"}]},{"title":"IEEE1588 Introduction","date":"2016-04-13T15:20:07.000Z","path":"2016/04/13/ieee1588/","text":"概述 在分布式网络化的控制系统中，考虑到调度和控制的实时性，对时间同步的精度要求非常严格。 影响分布式测控系统实时性差的主要根源： 各个测控设备之间的时钟差异 测控数据在网络中的传输延迟 网络时间协议NTP虽然通过一定的硬件配合和算法优化，可以提供系统的时钟同步性，但是只能达到毫秒级的同步精度要求 实现1588协议只需要在原有的网络上添加事件同步报文，这些报文占用少量的网络资源，他们只是和控制数据包或其他信息包共享网络。该协议成本低，而且独立于操作系统之外，适应性强，安装简单，无需复杂的配置工作，理论上其同步精度可以达到纳秒级。 IEEE 1588标准定义了一种精确时间协议PTP，该协议为分布式测控应用而设计，基于报文流加时间戳的思想，采用软、硬结合的实现方式，旨在实现亚微秒级的同步精度。协议完全兼容以太网技术，协议报文均是基于UDP/IP多播报文发送，特别适合基于局域网的分布式应用。 时间同步的概念 时间同步包括频率同步和时间同步 频率同步 是指信号之间的频率保持某种严格的特定关系，比如有效瞬间表现为同一平均速率，以此维持通信网络中所有节点以相同的速率运行 数字通信中传递的信号是对原始信息进行编码后得到的PCM（脉冲编码调制）离散脉冲。假如通信网中某两个节点之间的时钟频率不同，或者由于数字比特流在传输中因噪声干扰而叠加了相位漂移和抖动，便会在接收节点的缓冲存储器中产生码元的丢失或重复，最终导致比特流出现滑码。 时间同步 时间同步的定义便是根据接收到的时间来调节通信网络中节点的时钟和时钟所显示的时刻。 时间同步和频率同步既有联系又有区别，它既调节时钟的频率同时也调节时钟的相位。由于相位和时间都是对频率的积分，所以又称时间同步为相位同步。 与频率同步不同的是，时间同步接受离散的时间信息，离散的调节节点时钟。 时间同步完成两个重要功能，即对时和守时。对时就是对表，通过不定期的对表操作，将本地节点的时刻与远端节点的标准时刻进行相位同步；守时就是频率同步，即在对表的间隙里，保证本地节点时刻与远端节点的标准时刻之间的偏差在一个允许的范围之内 现有的几种同步技术 GPS对时系统 GPS可以同时跟踪太空中的24颗GPS卫星，自动选择最佳星座进行定位、定时。 电路仿真技术 同步以太网技术 以太网在物理层与SDH一样采用串行码流方式进行传送，因此响应的接收端必须提供时钟恢复业务，否则仍然会出现滑码现象。所以，以太网本身具备了传递时钟信息的功能。 包时钟技术 包时钟ToP（Time over Packet），就是利用分组网络来传递时间信息。时间报文的格式可以多种多样，比如RTP、NTP、IEEE 1588，只要报文中懈怠了时间信息就可以了。 IEEE 1588标准又称作PTP协议，主要用于工业以太网，具有亚微秒级的时间精度，可以同时传递频率信息和相位信息 秒脉冲对时 实现方式简单，理想状态下同步精度±1us 精度受主时钟性能与线路长度的影响较大 电信号在双绞线中的传播速度约为5ns/m，可见秒脉冲对时只适用于近距离对时，秒脉冲不能传递当前的UTC时间值 IEEE 1588标准介绍 IEEE 1588标准的全称是《网络测量和控制系统的精确时钟同步协议》（Precision Clock Synchronization for Networked Measurement and Control Systems）,也被称作PTP协议，它在各种同步协议中的同步精度是最高的 IEEE 1588:2008也称为IEEE 1588第二版，其主要基于以下几个要求 实现亚微秒级的时间同步，用于均是和实际的测试与测量中 缩短时间报文使其等长，来满足通信网中的应用，登场保温传递时的延时变化较小 提供容错特性，来从网络重建和祖母时钟崩溃中快速恢复 能把协议映射到一些非以太网的网络中 与第一版相比，第二版的改进： 报文格式。为了缩短报文长度，同步报文被分隔成Announce（声明报文）和Sync（同步报文），分别实现最佳主时钟算法和时间同步。 端到端透明时钟。 第一版中所有报文都是通过多播传递的，第二版提供了一种机制使得从时钟可与主时钟协商后在一定时间间隔内使用单播传输，这种特性广泛应用于通信中。 IEEE 1588系统构成 典型的PTP系统模型 IEEE 1588协议是一种说明系统中的实时PTP时钟如何相互同步的分布式协议，普通时钟和边界时钟被组织在一个主从同步层次中。PTP协议中的报文分为两类，即事件（Event）报文和一般（General）报文。 Event Messages：同步报文，延时请求，P2P延时请求，P2P延时响应。属于定时消息，发送或者接收的时刻需要打时间戳 General Messages：管理报文，声明报文，信令报文，跟随报文，延时响应，点延时相应跟随。不属于定时消息，不需要打时间戳 PTP协议中，节点是一个包含实时时钟的设备，这个时钟可能会有多种用途，例如产生PTP报文的时间戳，或者触发由该节点管理的事件。 PTP协议包括两个方面：时钟同步功能和管理功能。所有的普通时钟在这两个方面的表现都相同，边界时钟的每一个端口相当于一个普通时钟。管理节点不需要实现时钟同步功能而只需要实现管理功能，除非它本身也是一个时钟节点。 IEEE 1588的所有时钟都是向224.0.1.129这个组播地址不停的发送网络报文的。 IEEE 1588工作机制 建立主从秩序。网络中的各个节点通过最佳主时钟算法，选举出祖母时钟、主时钟和从时钟。祖母时钟精度最高，主时钟次之，从时钟最低。 低等级的时钟向高等级的时钟进行同步。网络中的主从时钟通过握手机制进行同步报文的交换。 GPS 通过串口解析出来的GPS时间信息是UTC时间，UTC时间是以原子时秒长为基础，在时刻上尽量接近于世界时的一种时间计量系统。UTC时间起点是1970年1月1日0时整。在IEEE1588 v2协议中，时间值的存储是以48位秒值和32位纳秒值两种形式构成的。 DP83640 DP83640功能框图 全面支持IEEE 1588协议的物理层芯片，不但提供了完整的MII，还设计了12个GPIO引脚实现实时动作处理功能，其特点如下 支持IEEE 1588 v1和v2 支持以太网UDP/IP第四版，UDP/IP第六版和Layer2协议 支持高精度IEEE 1588时钟同步，时间戳最大分辨率可达8ns 提供12个可配置GPIO 频率可配置的同步时钟输出 DP83640对IEEE 1588协议中对实时性要求极高的部分提供了完整的硬件支持，分别是 IEEE 1588同步时钟的产生 时钟同步报文的硬件标记 事件触发和事件捕获的时间戳标记 DP83640的功能 IEEE 1588时钟输出。DP 83640可以向外部设备提供频率可调的同步时钟信号，其标称频率为250/nMHz，其中n为2~255之间的任意整数，即980.4kHz~125MHz之间的离散值 IEEE 1588事件触发。DP 83640可以在GPIO引脚上产生一个基于IEEE 1588时钟的触发信号，这个信号可以是一次性上升或下降沿，脉宽可调的单脉冲或者周期信号。DP 83640可以为每一个触发器指定相应的GPIO输出引脚以及触发时刻。当内部IEEE 1588时钟走时到达此值时，事件被触发。芯片最多可支持在任意GPIO引脚上发送八个触发信号。可支持在单引脚上发送多重触发信号，支持产生复杂的信号波形。此时，个触发信号通过逻辑或组合在一起产生一个联合信号。使用DP83640提供的触发功能，还可以让芯片输出一个秒脉冲信号 IEEE 1588时间戳标记。DP 83640可以为发生的外部事件标记时间戳。事件的监测可通过外部脉冲的上升沿或下降沿。事件时间戳标记单元可最多监测任意GPIO引脚上发生的八个外部事件。事件时间戳以单一序列的方式保存，此序列可最多保存八个时间戳信息。需要对事件时间戳做出35ns（频率125MHz的IEEE1588参考时钟的周期X3+11ns）的调整，来消除由于输入延迟和同步延迟带来的影响。 IEEE 1588同步报文检测。DP 83640的发送报文解析器和接收报文解析器可以自动检测节点发送和接收的符合IEEE 1588第一版和第二版所定义的同步报文，并将其时间戳信息提供给软件。 所有的配置引脚（strap pin）内部都有微弱的上拉电阻或者下拉电阻，如果要改变默认配置，那么需要在该引脚外面上拉或者下拉2.2K的电阻。 7号引脚默认情况下是作为power-down的输入引脚，低电平有效。这等效于将BMCR寄存器中的bit11置1.将MICR寄存器的INT_OE位置1将会使器件跳出Power Down状态。 DP83640集成了系统诊断功能，能够评估连接的质量，检测潜在的错误 DP83640接收外部25MHz频率信号，依靠内部相位产生模块（PGM）产生125MHz的时钟信号，因此其可控周期的时间间隔是8ns 报文 采用UDP协议时，事件报文和通用报文的UDP目的端口号分别为319和320；直接采用以太网方式封装时，PTP敖文的以太网类型为0x88F7 PTP报文由报文头、报文主体以及报文扩展字段（可选）等部分组成，其中报文头为34字节，对所有报文都是通用的。 Master每发送一个Sunc报文都会有1个单独的sequenceID，并按递增顺序排列；当Slave向Master发送Delay_Req请求后，Master会回复相应的Delay_Resp报文，这两个交互报文的sequenceID是相同的。 PTP over Ethernet PTP over IPv4 PPT报文格式","tags":[{"name":"IEEE1588","slug":"IEEE1588","permalink":"https://suda-morris.github.io/tags/IEEE1588/"}]},{"title":"Latex Basic","date":"2016-03-21T03:09:15.000Z","path":"2016/03/21/latex/","text":"LaTeX简介 LaTeX是一种基于TeX的文档排版系统。 LaTeX并不是单独的程序，现在的TEX系统都是复杂的软件包，里面包含各种排版的引擎、编译脚本、格式转换工具、管理界面、配置文件、支持工具、字体以及数以千计的宏包和文档。一个TeX发行版就是把所有这样的部件都集合在一起，打包发布的软件 TeX是由TeX用户组发布的一个发行版，跨平台 LaTeX的命令以反斜线\\开头，命令一般用英文单词命名，有的可以带参数。 严格来说，LaTeX并不是标记语言，而是主要基于字符串代换的宏语言 使用各种引擎编译LaTeX文档的简要流程 导言区常用命令： 声明文章的标题:\\title{An Embedded FTP Server Powered by PoE} 声明文章的作者:\\author{morris} 声明写作日期:\\date{\\today} 声明参考文献的格式:\\bibliographystyle{plain} 以\\begin{document}和\\end{document}声明了一个document环境，里面是论文的正文部分，也是直接输出的部分 \\maketitle命令实际输出论文标题 \\tableofcontents命令输出目录 \\section命令开始新的一节 使用空行分段，单个换行并不会使文字另起一段，而只是起到使源代码更易读的作用，空行只起分段作用，使用很多空行并不起任何增大间距的作用 短浅不用打空格，LaTeX会自动完成文字的缩进，即使手工在前面打了空格，LaTeX也会将其忽略 汉字后面的空格会被忽略，其他符号后面的空格则保留。单个的换行就相当于一个空格，因此源代码中大段文字可以安全地分成短行，空格只起分隔单词或符号的作用，使用很多空格并不起到任何增大字词间距的作用 在需要使用注脚的文字后面使用命令:\\footnote{注脚内容} 需要强调的内容使用命令:\\emph{内容} 命令都以反斜线\\开头，后接命令名，命令名或者是一串字母，或是单个符号。命令可以带一些参数，如果命令的参数不止一个字符(不包括空格)，就必须用花括号括起来。可选参数如果出现，则使用方括号括起来。 LaTeX命令的格式 引用的内容是在正文中使用quote环境得到,quote环境即以\\begin{quote} 和\\end{quote} 为起止位置的部分。它将环境中的内容单独分行，增加缩进和上下间距排印，以突出引用的部分。 文章的摘要也是在\\maketitle之后用abstract环境生成的 LaTeX环境的一般格式 最简单的输入公式的办法是把公式用一对美元符号$$括起来，如使用$a+b$就得到漂亮的a+b，这种夹在行文中的公式称为正文公式或行内公式。对比较长或比较重要的公式，一般则单独居中写在一行；为了方便引用，经常还给公式编号。这种公式被称为显示公式或列表公式，使用equation环境就可以方便的输入这种公式。 键盘上没有的符号，就需要使用一个命令来输入。例如表示角的符号就可以用\\angle输入。命令的名字通常也就是符号的名字，圆周率的符号用\\pi来表示 符号^用来引入一个上标，而_则引入一个下标，它们用起来差不多等同于一个带一个参数的命令，因此多个字符的上下标需要使用花括号分组，如$2^{10}=1024$ 怎么输入90°，LaTeX默认的数学字体中，并没有一个专门用于表示角度的符号，自然也没有这么命令，角度的符号°是通过上标输入的：$^\\circ$ 插图功能不是由LaTeX的内核直接提供的，而是由graphicx宏包提供的。要使用graphicx宏包的插图功能，需要在源文件的导言区使用\\usepackage命令引入宏包 引入graphicx宏包后就可以使用\\includegraphics命令插图了，比如：\\includegraphics[scale=0.4]{DC-DC.jpg}。插入的图形就是一个有内容的矩形盒子，在正文中和一个很大的字符没有多少区别。支持的图形格式包括PDF、PNG、JPG、EPS 等。 除了一些很小的标志图形，我们很少把插图直接夹在文字之中，而是使用单独的环境列出。而且很大的图形如果固定位置，会给分页造成困难。因此，通常把图形放在一个可以变动的相对位置的环境中，称为浮动体。在浮动体中还可以给图形加入说明性的标题。例如： 1234567\\begin&#123;figure&#125;[ht]\\centering\\includegraphics[scale=0.6]&#123;xiantu.pdf&#125;\\caption&#123;宋赵爽在《周髀算经》注中作的弦图（仿制），该图给出了勾股定理的一个极具对称美的证明。&#125;\\label&#123;fig:xiantu&#125;\\end&#123;figure&#125; 在上面的代码中，figure环境有可选参数[ht]，表示浮动体可以出现在环境周围的文本所在处(here)和一页的顶部(top)，figure环境内部相当于普通的段落（默认没有缩进）；使用声明\\centering表示后面的内容居中；使用caption命令给插图加上自动编号和标题 制作表格需要确定的是表格的行、列对齐模式和表格线，这是由tabular环境完成的： 123456789101112\\begin&#123;table&#125;[H]\\begin&#123;tabular&#125;&#123;|rrr|&#125;\\hline直角边$a$ &amp; 直角边$b$ &amp; 斜边$c$ \\\\\\hline3 &amp; 4 &amp; 5 \\\\5 &amp; 12 &amp; 13 \\\\\\hline\\end&#123;tabular&#125;%\\qquad($a^2 + b^2 = c^2$)\\end&#123;table&#125; tabular环境中有一个参数，里面声明了表格中列的模式，在前面的表格中，|rrr|表示表格有3列，都是右对齐，在第一列和第三列后面各有一条垂直的表格线。在tabular环境内部，行与行之间用命令\\隔开，每行内部的表项则用符号&amp;隔开。表格中的横线则是用命令\\hline产生的。表格与插图一样，都是一个比较大的盒子，一般也放在浮动环境中，即table环境 使用\\bibliographystyle{plain}声明了参考文献的格式，用\\bibliography{math}命令打印参考文献列表。实际上这只是BibTeX处理文献的一个空架子，还需要定义“参考文献数据库”。BibTeX使用的参考文献数据库其实就是个后缀为.bib的文件。BibTeX数据库经常不需要我们自己录入，而可以从相关学科的网站直接下载或是从其他类型的文献数据库转换得到。定义好参考数据库后在正文中使用\\cite命令选择需要LaTeX列出的文献。 引用不仅限于参考文献，图表、公式的编号，只要事先设定了标签，同样可以通过辅助文件为中介引用。基本的交叉引用命令是\\ref，它以标签为参数，得到被引用的编号。数学宏包amsmath就定义了\\eqref命令，专门用于公式的引用，并能产生括号 设计页面尺寸可以使用geometry宏包：\\geometry{a6paper,centering,scale=0.8}，表示页面使用A6纸大小，版心居中，长宽占页面的0.8 改变图标标题格式可以使用caption宏包：\\usepackage[format=hang,font=small,textfont=it]{caption}表示设置图表所有标题使用悬挂对齐方式，整体用小字号，而标题文本使用斜体（对汉字来说就是楷体） 增加目录的项目则可以用tocbibnd宏包：\\usepackage[nottoc]{tocbibind}，宏包默认会在目录中加入目录项本身、参考文献、索引等项目，这里使用nottoc选项取消了在目录中显示目录本身 自定义环境命令,\\newenvironment有3个参数，第一个参数是环境的名字，后两个参数分别是在环境开始和末尾处的代码 123\\newenvironment&#123;myquote&#125;&#123;\\begin&#123;quote&#125;\\kaishu\\zihao&#123;-5&#125;&#125;&#123;\\end&#123;quote&#125;&#125; 自定义新的命令：\\newcommand\\degree{^\\circ} LaTeX是一种结构化的排版语言，在填写便准格式的模板时可以忽略编号、格式等许多具体细节。在文档排版中应主动追求内容与格式的分离，在document环境之内避免直接使用诸如字体字号、对齐缩进的格式控制命令，而代之以有具体意义的环境和命令，让文档变得清晰 文字与符号 LaTeX中的特殊字母 LaTeX中的特殊字母及命令 LaTeX提供了babel宏包，可以方便同时访问多种语言的字母表，babel宏包可带有一个或多个语言的可选参数，支持不同的语言，如:\\usepackage[greek,english]{babel},将使用英语和希腊语，其中最后一个参数的英语是默认语言，此时希腊语就可以用ASCII字符代替：\\textgreek{abcd} LaTeX在盘拌种会将单词中的一些字母连写为一个符号，即连字，连字的有无和多少一般是由使用的字体决定的，比如fi和fl连在了一起，有时候为了美观考虑取消连字，可以使用空的分组，比如：f{}ind 在每个标点之后应该加上空格，以保证正确的距离和换行 LaTeX中遇到单引号和双引号连续出现的情形，则在双引号和单引号之间用\\隔开 除了在数学模式中表示减号，符号-在LaTeX正文中也有多种用途：单独使用时它是连字符，两个连用时en dash，用来表示数字范围；三个连用是em dash，即破折号 圣罗浩使用\\ldots或者\\dots命令产生，相比直接输入三个句号，它所略微拉开的间距要合理的多 标准键盘上不能直接录入的标点符号 标准键盘不能直接录入的标点符号 文本中的空格起分隔单词的作用，任意多个空格与一个空格的功能相同；只有字符后面的空格使有效的，每行最前面的空格会被忽略。单个换行也被看做是一个空格 有一种不可打断的空格，在TeX中被称为带子，用~表示，TeX禁止在这种空格之间分行，因为可以用来表示一些不宜分开的情况 带子的使用 西文的逗号、句号、分号等标点后面应该加空格，这不仅能保证正确的间距，也能保证正确的换行。这是因为，标点后如果没有空格，就不能换行。 空行，即用连续两个换行表示分段，段与段之间会自动得到合适的缩进，任意多个空行与一个空行的效果相同 除了分段，也可以让LaTeX直接另起一行，并不分段。\\命令直接另起一行，上一行保持原来的样子，\\命令可以带一个可选的长度参数，表示换行后增加的额外垂直间距，例如\\[2cm]。\\linebreak则指定一行的断点，上一行仍按完整一行散开对齐 特殊符号 正文中常用的特殊符号 LaTeX的基本工具宏包textcomp就定义了大量用于文本的符号，例如欧元符号\\texteuro，千分符\\textperthousand等。tipa宏包提供了国际音标字体的访问 预定义命令的字体族有3种：罗马字体族、无衬底字体族和打字机字体族，其命令为： 预定义命令的字体族 预定义命令的字体形状有4种：直立形状、意大利形状、倾斜形状、小型大写形状，其命令为： 预定义命令的字体形状 预定义命令的字体系列有中等和加宽加粗两类 预定义命令的字体系列 对于中文字体，一般只是用不同字体族进行区分。xeCJK和CJK宏包机制下，中文字体的选择命令和西文字体是分离，选择中文字体族使用\\CJKfamily 中文的字体族，根据不同的系统和使用方式有不同，在ctex宏包及文档下有一些预定义 ctex宏包提供的简化中文字体命令 字体命令： \\emph表示强调，用于把直立体改为意大利体，把意大利体改为直立体 \\underline可以给文字或公式加下划线 基本的LaTeX提供了10个简单的生命是命令调整文字的大小 声明式命令调整文字大小 中文字号可以使用ctex宏包或者ctexart等文档类提供的\\zihao命令设置 中文字号 LaTeX中的行距是与字号直接相关的，在设置字号的时候，同时也就设置了基本行距为文字大小的1.2倍","tags":[{"name":"Latex","slug":"Latex","permalink":"https://suda-morris.github.io/tags/Latex/"}]},{"title":"Android Introduction","date":"2016-01-20T10:01:40.000Z","path":"2016/01/20/android/","text":"Android系统架构图 Android系统架构 应用程序框架 Activity Manager：管理各个应用程序生命周期以及通常的导航回退功能 Window Manager：管理所有的窗口程序 Content Provider：使得不同应用程序之间存取或者分享数据 View System：构建应用程序的基本组件 NotificationManager：使得应用程序可以在状态栏中显示自定义的提示信息 Package Manager：Android系统内的程序管理 TelephonyManager：管理所有的移动设备功能 Resource Manager：提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等 LocationManager：提供位置服务 XMPP Service：提供GoogleTalk服务 系统运行库分成两个部分，分别是系统库和Android运行时。 系统库是应用程序框架的支撑，是连接应用程序框架层与Linux内核层的重要纽带。 Surface Manager：执行多个应用程序的时候，负责管理显示与存取操作间的互动，另外也负责2D绘图与3D绘图进行显示合成 Media Framework：多媒体库，基于PacketVideo OpenCore；支持多种常用的音频、视频格式录制和回放，编码格式包络MPEG4、MP3、H.264、AAC、ARM SQLite：小型的关系型数据库引擎 OpenGL|ES：根据OpenGLES1.0API标准实现的3D绘图函数库 FreeType：提供点阵字与向量字的描绘与显示 WebKit：一套网页浏览器的软件引擎 SGL：底层的2D图形渲染引擎 SSL:在Android上通信过程中实现握手 Libc：从BSD继承来的标准C系统函数库，专门为基于embedded linux的设备定制 Android运行时，程序在Android运行时中执行，其运行分为核心库和Dalvik虚拟机两部分 核心库：核心库提供了Java语言API中的大多数功能，同时也包含了Android的一些核心API，如android.os、android.net、android.media等等 Dalvik虚拟机：Android程序不同于J2ME程序，每个Android应用程序都有一个专有的进程，并且不是多个程序运行在一个虚拟机中，而是每个Android程序都有一个Dalvik虚拟机的实例，并在该实例中执行。Dalvik虚拟机是一种基于寄存爱的Java虚拟机，而不是传统的基于栈的虚拟机，并进行了内存资源使用的优化，以及支持多个虚拟机的特点。需要注意，不同于J2ME，Android程序在虚拟机中执行的并非编译后的字节码，而是通过转换工具dx将java字节码转换成dex格式的中间码 Adnroid UI基础 Android UI由View和ViewGroup组成，ViewGroup是不可见的，用于组织和排版View和ViewGroup。View显示用户内容，以及相应用户的操作。Android UI可以在code中生产，不过更加方便的方式是在Android的XML文件中定义UI 可以通过2种方式定义界面结构，一种是在XML中定义视图结构，另一种是在运行时动态创建视图结构， 通过XML定义视图结构，可以有效做到代码与界面的分离，并且提高界面的可读性。XML的文件西部包含一个root，可以是View或者ViewGroup。在节点下面增加子界面的方式来构造界面结构 在编译阶段，所有的XML layout文件都会编译到一个统一的View资源里面，在需要使用layout资源的时候，需要将资源加载到程序中，一般做法是在Activity.onCreate()中做加载的资源操作 每一个View或者ViewGroup都有一个ID属性，该属性由class View定义。其定义语法为：android:id=”@+id/my_button”。 @的意思是指示XML parser解析并且展开后面的内容，将其作为一个ID的资源 +的意思是指示这是一个新的ID，需要将其加到资源定义文件R.java中去。有一些系统自定的ID，如果引用这些系统自定的ID，则不需要加+号，但是要加上包的命名空间，其定义非语法为：android：id=“@android：id/empty” 在XML文件中，通常使用layout_something来定义View在ViewGroup中的位置。ViewGroup类会实现一个嵌套类来扩展ViewGroup.LayoutParms。这个内嵌的子类会定义类型来指定字View的位置和大小。每个view group一般都会包含width和height参数，因此每个在其内部的view都需要定义这两个属性。一般不会将其指定为某一个宽度或者高度，一般写为相对的，这样可以保证适用于多种屏幕大小的设备。其中，wrap_content会根据内容的大小来调节大小。fill_parent，最大化达到父几点所允许的，在API level8后名字改为match_parent View作为一个几何图形，具有4个属性对应于它所属的容器，分别是left，top，width和height，每个属性的单位是pixel。参考API文档，可以很多函数获取位置以及View的大小信息。getLeft()，getTop(),getRight(),getBottom()。获取的值一本都是相对应与父节点的位置和大小信息。Padding是内容与View空间直接的间隔。View并未提供Margin属性，该属性一般由ViewGroup设置 如果需要在界面上显示的内容是动态获取的话，可以使用Adapter和继承AdapterView的View来动态显示。Adapter是数据源和AdapterView之间的桥梁，由它从数据源获取数据，然后转换为一组实体，填充到View 可以简单的使用继承自AdapterView的View来绑定Adapter，来获取外部数据源的数据。Android也提供了一些继承自Adapter的子类用于处理不同的数据形式来建立View，下面是三种比较常见的Adapter： ArrayAdapter，当数据源是一个数组的时候，可以使用这个Adapter，默认，ArrayAdapter在调用toString()后会为每个Item创建一个TextView SimpleCursorAdapter，如果数据源是来自于游标的时候，使用这个Adapter。使用这个Adapter的时候，需要指定Cursor的哪个行，哪个列插入Layout的View 可以通过实现AdapterView.OnItemClickListener接口来让AdapterView响应点击事件 Android开发中高效的数据结构 SimpleArrayMap与ArrayMap 实质上ArrayMap继承自SimpleArrayMap，主要是为了实现像HashMap一样的api方法，让习惯使用HashMap的开发者感觉不到差异，本质上是SimpleArrayMap+Map的再封装。一般来说使用这两个类来代替HashMap，因为它们比HashMap更加高效，也对内存进行了优化 SparseArray与SparseArrayCompat和LongSparseArray 这3个类中，前2个基本上是同一类，只不过第二个类有removeAt方法，第三个是Long类型的。这3个类也是用来代替HashMap，只不过它们的键的类型是整形Integer或者Long类型，在实际开发中，如月份缩写的映射，或者进行文件缓存映射，viewHolder都特别适用 AtomicFile AtomicFile首先不是用来代替File的，而是作为File的辅助类存在，AtomicFile的作用是实现事务性原子操作，即文件读写必须完整，适合多线程中的文件读写操作 Intent Intent是不同组件中提供运行时绑定的对象。Intent代表一个应用“想去做什么事情”，你可以用它做各种各样的任务，不过大部分的时候他们被用来启动另一个Activity。 在Activity之间传递数据包Bundle 123456789//发送端Bundle b = new Bundle();b.putString(\"name\",\"morris\");b.putInt(\"age\",20);intent.putExtras(b);//接收端Bundle data = intent.getExtras();String name = data.getString(\"name\");int age = data.getInt(\"age\"); 在Activity之间传递值对象 1234567891011121314151617181920212223242526272829303132/*方法1，使用Java的序列化，效率比较低*///前提要求User类实现Serializable接口//发送端intent.putExtra(\"user\",new User(\"name\",20));//接收端User user = (User)intent.getSerializableExtra(\"user\");/*方法2，使用Android的Parcelable，效率比较高*///前提要求User类实现了Parcelable接口,并且重写了writeToParcel方法来手动实现序列化//在User类中实现方法@Overridepublic void writeToParcel(Parcel dest,int flags)&#123; dest.writeString(getName()); dest.writeInt(getAge());&#125;//在User类中实现常量对象CREATORpublic static final Creator&lt;User&gt; CREATOR = new CREATOR&lt;User&gt;()&#123; @Override public User createFromParcel(Parcel source)&#123; return new User(source.readString(),source.readInt()); &#125; @Override public User[] newArray(int size)&#123; return new User[size]; &#125;&#125;//发送端intent.putExtra(\"user\",new User(\"name\",20));//接收端User user = intent.getParcelableExtra(\"user\"); 获取Activity的返回参数 1234567891011//发送端startActivityForResult(intent,requestCode);@Overrideprotected void onActivityResult(int requestCode, int resultCode,Intent data)&#123; super.onActivityResult(requestCode,resultCode,data); //ToDo&#125;//接收端setResult(resultCode,intent);finish(); 隐式Intent 在AndroidManifest文件中，为activity添加标签，并为其指名category和action 12&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; //表示该intent-filter的行为方式是activity&lt;action android:name=&quot;字符串A&quot;/&gt; 然后在创建Intent实例的时候把“字符串A”传入构造函数 一般来说，字符串A约定的格式为：包名.intent.action.类名 通过这种方式能够访问其他应用中的activity，但是如果在activity的标签中指名android:exported=&quot;false&quot;的话，别的应用便无法访问该activity Activity的启动模式 在AndroidManifest文件中，为activity添加参数：android:lanuchMode=”standard”。在standard启动模式中，所有实例放入同一个任务栈，因此支持后退键导航 在AndroidManifest文件中，为activity添加参数：android:lanuchMode=”singleTop”。singleTop模式和standard模式都会将intent发送给新的实例，不过，singleTop要求如果创建intent的时候栈顶已经有了要创建的Activity的实例，则将intent发送给该实例，而不创建新的实例。singleTop模式，可用来解决栈顶多个重复相同的Activity的问题。如果是A activity跳转到B activity，在跳转到A activity，行为就和standard模式一样了，会在B activity跳转到A activity的时候创建A activity的新实例，因为当时的栈顶不是A activity实例。 在AndroidManifest文件中，为activity添加参数：android:lanuchMode=”singleTask”。当intent到来，需要穿件singleTask模式Activity的时候，系统会检查任务栈里面是否已经有该Activity的实例，如果有直接将intent发送给它。 在AndroidManifest文件中，为activity添加参数：android:lanuchMode=”singleInstance”。一个任务栈只包括一个activity。比如有A，B，C三个Activity，其中B为sigleInstance模式，他们之间的跳转关系是A-&gt;B-&gt;C，现在在C中按下返回键，由于B位于独立的task中，它不属于C的上下文activity，所以此时直接返回到A中。 Get a string resource from you app’s Resources String hello = getResources().getString(R.string.hello_world); Toast使用方法 Toast.makeText(activity对象，“显示内容”，Toast.LENGTH_SHORT).show(); 适配不同的屏幕 安卓设备的屏幕的分类指标：大小(size)和分辨率(density) 有四种size：small，normal，large，xlarge 有四种density：low（ldpi），medium（mdpi），high（hdpi），extra high（xhdpi） 每份图片需要四种分辨率的备份，比如，如果你为xhdpi设备生成一张200X200的照片，同样，你需要为hdpi设备生成150X150的照片，为mdpi设备生成100X100的照片，为ldpi设备生成75X75的照片 xhdpi：2.0 hdpi：1.5 mdpi：1.0（baseline） ldpi：0.75 一般来说，ldpi的素材是可以不需要的，因为如果你提供了hdpi的素材，系统会自动将它缩小一半来适应ldpi的设备 Activity的生命周期 Activity生命周期 onPause主要完成的工作（为了快速切换到下一个Activity，这个函数里面的操作内容应该尽量简单些） 停止动画或者其他正在消耗CPU的动作 提交未保存的变化，比如草稿邮件 释放系统资源，包括broadcast receiver，传感器句柄等 onStop函数用来执行占用CPU大的shut-down操作，比如往数据库中写入数据 Context 它是用来访问全局信息（比如，应用程序的资源）的接口，一些常用的资源都会实现Context，这样就可以方便访问资源 System.out.println(R.string.hello_world)等同于System.out.println(getContext().getResources().getText(R.string.hello_world)); Application 安装一个app应用后可以在桌面上显示多个应用图标(即同一个应用程序有多个主Activity)，那是因为在Manifest文件中设置了多个activity的category为android.intent.category.LAUNCHER，action为android.intent.category.LAUNCHER。但是这几个应用同属于一个Application，表现为在Manifest文件中，这些activity在同一个application标签下。 在Manifest文件中，为application标签设置属性name,其值为一个继承自Application的某个自定义类，这样在任意一个activity中可以通过getApplicationContext来获取该自定义Application类的实例。从某种意义上来说，该自定义Appliacation类中的资源可以更加方便的为全局共享，里面可以存放一些全局的逻辑资源（区别于UI的资源） Application的生命周期相关的方法 onCreate，创建Application的时候调用，先于activity的onCreate onTerminate，结束后调用 onLowMemory，低内存时候调用 onTrimMemory，操作系统内存整理的时候调用 onConfigurationChanged，配置改变的时候调用 Service 启动服务：startService，service内部会执行onStartCommand 停止服务：stopService 绑定服务：bindService 解绑服务：unbindService 当activity与service绑定后，如果activity退出，响应的service也会停止。即service的生命周期伴随着activity的存在于消亡。若是是使用startService来启动service的话，service的生命将会独立于activity，只有通过调用stopService才能将其停止。当startService与bindService都调用了的话，若想退出服务，unbindService与stopService都必须执行 同一个service只会创建1次 普通辅线程不允许修改UI线程中的资源！AIDL(Android Interface Definition Language)","tags":[{"name":"Android","slug":"Android","permalink":"https://suda-morris.github.io/tags/Android/"}]},{"title":"Android Studio Install","date":"2016-01-19T02:06:41.000Z","path":"2016/01/19/android-studio/","text":"最新安装的Android Studio打开软件特别慢，总是卡在“Fetching Android SDK component information”，如何解决？ 进入Android Studio的安装目录下的bin目录，找到idea.properties文件，用文本编辑器打开 在idea.properties文件末尾天剑一行：disable.android.first.run=true,然后保存文件 关闭Android Studio后重新启动 给Android Studio安装Genymotion插件 File-&gt;Settings 找到plugins设置项，点击Browser，输入：genymotion关键字，安装相应插件 重启android studio后，点击Genymotion插件的图标，设置Genymotion在本地的路径，完成后就告成 设置自动导入依赖包 File-&gt;Settings-&gt;Editor 找到Auto Import选项，使能：show import popup，Optimize imports on the fly，Add unambiguous imports on the fly 常用功能 Gradle同步，在项目运行或者更改Gradle配置的时候都要点击下这个按钮，会下载相应的依赖 AVD Manager，模拟器管理 SDK Manager，管理SDK版本 DDMS即Dalvik Debug Monitor Service，Dalvik调试监控服务 Gradle Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，而取而代之的是一种基于Groovy的内部领域特定（DSL）语言 Android Studio中新建项目成功后会自动下载Gradle，Windows下回安装到：C:\\Documents and Settings\\&lt;用户名&gt;.gradle\\wrapper\\dists 目录 命令行Gradle编译过程 切换到项目根目录，执行./gradlew -v来查看项目所用的Gradle版本，如果是第一次执行，将会去下载Gradle 接着执行./gradlew clean，清除项目根目录/app目录下的build文件夹 最后执行./gradlew build,检查依赖，直接编译生成相应的apk文件。接着在项目根目录/app/build/outputs/apk目录下会看到类似于app-debug-unaligned.apk，app-release-unsigned.apk等，unaligned代表没有进行zip优化的，unsigned代表没有签名的。 gradlew build命令吧debug、release环境的包都打出来，如果正式发布只需要打Release的包，就需要这样使用： ./gradlew assembleDebug编译并打Debug包 ./gradlew assembleRelease编译并打Release包 除此以外，assemble除了能和BuildType结合外还能和ProductFlavor结合，实质上，assemble是和Build Variants一起结合使用的，而Build Variants=Build Type + Product Flavor，例如如果想打包豌豆荚渠道的release版本，执行如下命令：./gradle assembleWandoujiaRelease,如果只打豌豆荚渠道的版本，则：./gradle assembleWandoujia 与Gradle相关的几个文件 项目根目录/app/build.gradle,这个文件是app文件下下这个Module的gradle配置文件，在里面会指明要编译成安卓的应用程序（com.android.application）还是库（com.android.library）；指明编译SDK的版本，build tools的版本（根据实际开发者已经下载好的版本来修改），指明应用的包名，支持的最小的SDK版本，目标SDK版本，要编译在lib目录下的哪些jar包。 项目根目录/build.gradle，这个文件是整个项目的基础配置文件，内容主要包括两个方面，一个是声明仓库的源，一般是jcenter，jcenter可以理解成是一个新的中央远程仓库，兼容maven中心仓库，而且性能更优。另一个是声明了android gradle plugin的版本 项目根目录/settings.gradle，这个文件是全局的项目配置文件，里面主要声明一些需要加入gradle的module，例如：include &#39;:app&#39;, &#39;:extras:ShimmerAndroid&#39;,文件中的app，extra：ShimmerAndroid都是module，如果还有其他module都需要按照如上格式加进去 完整的gradle脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798apply plugin: 'com.android.application'def releaseTime() &#123; return new Date().format(\"yyyy-MM-dd\", TimeZone.getTimeZone(\"UTC\"))&#125;android &#123; compileSdkVersion 21 buildToolsVersion '21.1.2' defaultConfig &#123; applicationId \"com.boohee.*\" minSdkVersion 14 targetSdkVersion 21 versionCode 1 versionName \"1.0\" // dex突破65535的限制 multiDexEnabled true // 默认是umeng的渠道 manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"umeng\"] &#125; lintOptions &#123; abortOnError false &#125; signingConfigs &#123; debug &#123; // No debug config &#125; release &#123; storeFile file(\"../yourapp.keystore\") storePassword \"your password\" keyAlias \"your alias\" keyPassword \"your password\" &#125; &#125; buildTypes &#123; debug &#123; // 显示Log buildConfigField \"boolean\", \"LOG_DEBUG\", \"true\" versionNameSuffix \"-debug\" minifyEnabled false zipAlignEnabled false shrinkResources false signingConfig signingConfigs.debug &#125; release &#123; // 不显示Log buildConfigField \"boolean\", \"LOG_DEBUG\", \"false\" minifyEnabled true zipAlignEnabled true // 移除无用的resource文件 shrinkResources true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.release applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) &#123; // 输出apk名称为boohee_v1.0_2015-01-15_wandoujia.apk def fileName = \"boohee_v$&#123;defaultConfig.versionName&#125;_$&#123;releaseTime()&#125;_$&#123;variant.productFlavors[0].name&#125;.apk\" output.outputFile = new File(outputFile.parent, fileName) &#125; &#125; &#125; &#125; &#125; // 友盟多渠道打包 productFlavors &#123; wandoujia &#123;&#125; _360 &#123;&#125; baidu &#123;&#125; xiaomi &#123;&#125; tencent &#123;&#125; taobao &#123;&#125; ... &#125; productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:support-v4:21.0.3' compile 'com.jakewharton:butterknife:6.0.0' ...&#125;","tags":[{"name":"Android","slug":"Android","permalink":"https://suda-morris.github.io/tags/Android/"}]},{"title":"JSON","date":"2015-12-07T10:06:10.000Z","path":"2015/12/07/json/","text":"cJSON使用123456789typedef struct cJSON &#123; struct cJSON *next,*prev; struct cJSON *child; int type; char *valuestring; int valueint; double valuedouble; char *string;&#125; cJSON; cJSON结构体为一个双向链表，并可通过child指针访问下一层 type变量决定数据类型，数据项可以是字符串可以是整形，也可以是浮点型。如果是整形的话可以从valueint取出，如果是浮点型的话可以从valuedouble取出，以此类推 主要函数说明 解析 cJSON_Parse函数负责解析JSON数据包，并按照cJSON结构体的结构序列化整个数据包。使用该函数会通过malloc函数在内存中开辟一个空间，使用完成需要手动释放 cJSON_GetObjectItem函数可以从cJSON结构体中查找某个子节点名称，如果查找成功，可把该子节点序列化到cJSON结构体中 如果需要使用cJSON结构体中的内容，可通过cJSON结构体中的valueint和valuestring取出有价值的内容 通过cJSON_Delete释放内存空间 组装 cJSON_CreateObject函数可创建一个根数据项，之后便可向该根数据项中添加string或int等内容 cJSON_AddNumberToObject向节点中添加子节点 cJSON_Print函数可以打印跟数据项 使用例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950cJSON* pRoot = cJSON_CreateObject();cJSON* pArray = cJSON_CreateArray();cJSON_AddItemToObject(pRoot, \"students_info\", pArray);char* szOut = cJSON_Print(pRoot); cJSON* pItem = cJSON_CreateObject();cJSON_AddStringToObject(pItem, \"name\", \"chenzhongjing\");cJSON_AddStringToObject(pItem, \"sex\", \"male\");cJSON_AddNumberToObject(pItem, \"age\", 28);cJSON_AddItemToArray(pArray, pItem); pItem = cJSON_CreateObject();cJSON_AddStringToObject(pItem, \"name\", \"fengxuan\");cJSON_AddStringToObject(pItem, \"sex\", \"male\");cJSON_AddNumberToObject(pItem, \"age\", 24);cJSON_AddItemToArray(pArray, pItem); pItem = cJSON_CreateObject();cJSON_AddStringToObject(pItem, \"name\", \"tuhui\");cJSON_AddStringToObject(pItem, \"sex\", \"male\");cJSON_AddNumberToObject(pItem, \"age\", 22);cJSON_AddItemToArray(pArray, pItem); char* szJSON = cJSON_Print(pRoot);cJSON_Delete(pRoot);//free(szJSON); pRoot = cJSON_Parse(szJSON);pArray = cJSON_GetObjectItem(pRoot, \"students_info\");if (NULL == pArray)&#123; return -1;&#125;int iCount = cJSON_GetArraySize(pArray);for (int i = 0; i &lt; iCount; ++i)&#123; cJSON* pItem = cJSON_GetArrayItem(pArray, i); if (NULL == pItem) &#123; continue; &#125; string strName = cJSON_GetObjectItem(pItem, \"name\")-&gt;valuestring; string strSex = cJSON_GetObjectItem(pItem, \"sex\")-&gt;valuestring; int iAge = cJSON_GetObjectItem(pItem, \"age\")-&gt;valueint;&#125; cJSON_Delete(pRoot);free(szJSON);","tags":[{"name":"json","slug":"json","permalink":"https://suda-morris.github.io/tags/json/"}]},{"title":"Network Security","date":"2015-12-06T10:06:10.000Z","path":"2015/12/06/network-security/","text":"信息安全的基本属性 机密性（Confidentiality）——别人“看不到”或者“看不懂” 认证（Authentication）——证明“你就是你” 完整性（Integrity）——信息没有被“动过” 不可否认性（Non-repudiation）——不能抵赖 密码算法分类 加密算法：用于机密性解决方案 杂凑函数：用于完整性解决方案 数字签名：用于认证和不可否认性 保密通信系统模型 FWXQtx.png SSL/TLS加密 SSL协议报文 SSL运行在TCP/IP层之上、应用层之下，为应用程序提供加密数据通道，它采用了RC4、MD5以及RSA等加密算法，使用40位的密钥。 HTTPS实际上就是HTTP over SSL，它使用默认端口443，而不是像HTTP那样使用端口80。 HTTPS协议使用SSL在发送方把原始数据进行加密，然后在接收方进行解密，加密和解密需要发送方和接收方通过交换公知的密钥来实现，因此，所传送的数据不容易被网络何可截获和解密 SSL通信过程 工作流程 建立安全能力。SSL捂手的第一阶段启动逻辑连接，建立这个连接的安全能力。首先客户机向服务器发出client hello消息并等待服务器响应，随后服务器向客户机返回server hello消息，对client hello消息中的信息进行确认。 Client hello消息包括： 客户端可以支持的SSL最高版本号 一个客户端生成的随机数，稍后用于生成“对话密钥” 一个确定会话的会话ID 一个客户端可以支持的密码套件列表，每个套件都以SSL开头，紧跟着的是密钥交换算法，用with这个词把密钥交换算法、机密算法、散列算法分开。例如：SSL_DHE_RSA_WITH_DES_CBC_SHA, 表示把DHE_RSA(带有RSA数字签名的暂时Diffie-HellMan)定义为密钥交换算法；把DES_CBC定义为加密算法；把SHA定义为散列算法。 一个客户端可以支持的压缩算法列表 Server Hello消息包括 一个SSL版本号。去客户端支持的最高版本号和服务端支持的最高笨笨好中的较低者 一个服务器生成的随机数，稍后用于生成“对话密钥” 会话ID 从客户端的密码条件列表中选择的一个密码套件 从客户端的压缩方法的列表中选择的压缩方法 这个阶段之后，客户端服务端知道了下列内容： SSL版本 密钥交换、信息验证和加密算法 压缩方法 有关密钥生成的两个随机数 服务器鉴别与密钥交换。服务器启动SSL握手第二阶段，是本阶段所有消息的唯一发送方，客户机是所有消息的唯一接收方。该阶段分为4步 证书：服务器将数字证书和到根CA整个链发给客户端，使客户端能用服务器证书中的服务器公钥认证服务器 服务器密钥交换：这里视密钥交换算法而定 证书请求：服务端可能会要求客户自身进行验证 服务器握手完成 客户机鉴别与密钥交换。客户机启动SSL握手第三阶段，是本阶段所有消息的唯一发送方，服务器是所有消息的唯一接收方。该阶段分为3歩： 证书：为了对服务器证明自身，客户要发送一个整数信息，这是可选的 客户机密钥交换：这里客户端将预备主密钥发送给服务端，注意这里会使用服务端的公钥进行加密 证书验证：对预备密钥和随机数进行签名 完成，客户机启动SSL握手的第四阶段，是服务器结束。该阶段分成4歩 SSL协议可分为两层： SSL记录协议：它建立在可靠的传输协议之上，为高层协议提供数据封装、压缩、加密等基本功能的支持 SSL握手协议：它建立在SSL记录协议之上，用于在实际数据传输开始前，通讯双方进行身份认证、协商加密算法、交换密钥等 ESP8266作为SSL server时，提供加密证书的制作脚本，生成SSL加密所需的头文件cert.h和private_key.h。CA认证功能默认关闭，用户可调用接口espconn_secure_ca_enable使能CA认证 证书制作：tool文件夹下，修改makefile.sh文件里面的IP地址为实际SSL 服务器的IP地址；然后./makefile.sh 开发者必须调用espconn_secure_set_default_certificate和espconn_secure_set_default_private_key传入证书和密钥 证书制作脚本makefile.sh生成默认SSL server证书由Espressif System颁发，并非由CA颁发。如果用户需要CA认证，请将运行脚本Makefile.sh生成的TLS.ca_x509.cer导入SSL client，并使用脚本make_cacert.py将CA文件生成eap_ca_cert.bin烧写到Flash对应的地址 ESP8266作为SSL client时，可支持双向认证。CA认证功能默认关闭，用户可调用接口espconn_secure_ca_enable使能CA认证 ESP8266作为SSL client时支持证书认证功能，但此功能默认关闭，开发者可以调用接口espconn_secure_cert_req_enable使能证书认证，证书制作： 修改脚本makefile.sh，制作开发者自行签发的CA证书，例如，证书实例中的TLS.ca_x509.cer 使用签发的CA制作供SSL client使用的证书，例如，证书示例中的TLS.x509_1024.cer 去除制作SSL client使用的证书时所用的密钥，例如证书示例中的TLS.key_1024 将证书合成脚本make_cacert.py与CA文件放在同一目录下 运行脚本“make_cacert.py”将合成同一目录下的CA文件生成sap_ca_cert.bin，esp_ca_cert.bin的烧录位置由接口espconn_secure_ca_enable设置，用户可以自行定义 重命名证书名称（例如TLS.x509_1024.cer）；重命名密钥名称，改为private_key.key_1024。 将重命名后的文件，与脚本make_cert.py拷贝到同一目下下 运行脚本make_cert.py生成esp_cert_private_key.bin，esp_cert_private_key.bin的烧录位置由接口espconn_secure_cert_enable设置，用户可自行定义 软件接口 SSL系列软件接口与普通TCP软件接口，在SDK底层是两套不同的处理流程，因此不能混用两种软件接口。SSL连接时，仅支持使用： espconn_secure_XXX系列接口 espconn_regist_XXX系列注册回调的接口 espconn_port获得一个空闲的端口 在SSL中会使用密钥交换算法交换密钥；使用密钥对数据进行加密；使用散列算法对数据的完整性进行验证，使用数字证书证明自己的身份 SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器所要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。 如何保证公钥不被篡改？ 将公钥放在数字证书中。只要证书时可信的，公钥就是可信的 公钥加密计算量太大，如何减少耗用的时间？ 每一次对话（session），客户端和服务器都生成一个“对话密钥”，用它来加密信息。由于“对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密“对话密钥”本身，这样就减少了加密运算的消耗时间 SSL/TLS协议的基本过程是这样的： 客户端向服务端索要并验证公钥 双方协商生成“对话密钥” 双方采用“对话密钥”进行加密通信 为什么要用三个随机数来生成“会话密钥”？ 不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。","tags":[{"name":"SSL/TLS","slug":"SSL-TLS","permalink":"https://suda-morris.github.io/tags/SSL-TLS/"}]},{"title":"Verilog Basic","date":"2015-11-22T11:53:49.000Z","path":"2015/11/22/verilog/","text":"verilog与数字电路基础 数字电路的五基元电路：反相器、与门、或门、三态门、D触发器 常用三种描述方式： 数据流描述(assign)-&gt;组合逻辑电路 行为级描述(always)-&gt;时序逻辑电路 门级电路(and/or/not/buf)-&gt;基本门电路的调用 常用关键字：always,assign,begin,case(xz),default,defparam,else,end,for,function,if,input,input,integer,module,negedge,output,parameter,posedge,primitive,reg,table,task,wire 自定义模块(一般由FPGA厂商制作):primitive…endprimitive;table…endtable; 我的FPGA FPGA芯片：EP4CE6F22C8N，逻辑资源6272LEs，乘法器15，RAM资源270Kbits SDRAM芯片：K4S561632J，256Mbit 串行FLASH：EPCS4，4Mbit 有源晶振：48MHz SPI Flash：Winbond 25Q128 FPGA入门知识 FPGA的仿真分为：行为仿真、门级仿真和布局布线后仿真，或者叫做前仿真、后仿真（包含门级仿真和布局布线后仿真）。 一个标称450MHz的FPGA仅仅值内部的寄存器或者乘法器、RAM等单个资源的时钟频率能够达到。实际上使用这些器件搭建一个运行在200-300MHz之间的设计已经非常理想。因为级联门延时、线延时都是非常大的除了优化算法结构外，为了达到更高的速率插入同步寄存器，增加流水级数必不可少，这样才能用资源换来速度的提升。对同功能的设计，速度和资源永远成反比 建立就是CLK到来前DATA稳定时间，保持就是时钟到来后数据的保持时间 现在的很多PCB工具和FPGA开发软件都有附带的接口，可以相互转换。将PCB设计软件中的管脚转换成FPGA的约束文件（TCL或者CSV格式），或者在FPGA调整之后再次导入PCB 真的时钟是不能赋值给线网或者寄存器的。由于FPGA里时钟属于单独的时钟树，CLK是无法直接赋值给一个寄存器变量的，因为他们只能从时钟树分配到寄存器的CLK端。因为时钟树总是和寄存器的clk端相连，他们和触发器的D端实际是不连接的，需要通过特殊处理。 在基本组成元素中非时序组合逻辑在FPGA内部使用查找表资源实现（LUT）。而时序则由寄存器实现。 三段式有限状态机： 现态 次态 逻辑输出 状态机编码： 顺序编码 格雷编码 一位热码 约翰逊编码 将POF文件转换成固化到FPGA Flash的文件 使用JTAG烧写Flash文件（非AS模式） 选择File-&gt;Convert Programming Files 选择Programming file type为：JTAG Indirect Configuration(.jic),选择相应的串行配置Flash型号，点击Flash Loader，添加Flash器件，然后导入之前生成的pof文件 使用TCL文件来分配器件与管脚 一个tcl文件的例子 Verilog的模块 模块是Verilog语言的基本单元，其基本语法如下： 1234567891011module &lt;模块名&gt;（&lt;端口列表&gt;） 端口说明（input，output，inout） 参数定义 数据类型定义：指定模块内用到的数据对象为寄存器型、存储器型还是连续型 连续赋值语句（assign） 过程块（initial和always） -行为描述语句 底层模块实例 任务和函数 延时说明块：对模块各个输入和输出端口之间的路径延时进行说明endmodule 模块的描述方式 模块的描述方式又称建模方式。verilog既是一门行为化又是一门结构化的HDL语言，根据设计的需要，每个模块的内部可以分为四种抽象级别来进行描述。模块在外部环境中的表现都是同等的，而与其内部具体描述的抽象级别无关。因此模块的内部具体描述相对于外部环境来说是隐藏的，该表一个模块内部描述的抽象级别，可以不用对其外部环境做任何的改动。 模块的4类抽象级别的描述 行为级建模：这是Verilog最高抽象级别的描述方式。一个模块可以按照要求的设计算法来实现，而不用关心具体硬件实现的细节。行为描述通过行为语句来实现，行为功能可使用下述过程语句结构描述 initial语句，此语句只执行一次 always语句，此语句循环执行 数据流描述方式（数据流级建模） 数据流描述方式也称RTL（寄存器传输级）描述方式。在这种描述方式下，设计者需要知道数据是如何在寄存器之间传输的以及将被如何处理。数据流描述防护四类似于布尔方程，它能够比较直观地表达底层逻辑行为。在Verilog中数据流描述方式主要用来描述组合逻辑，具体由连续赋值语句“assign”来实现。 门级描述方式 在这种描述方式下，模块是按照逻辑门和他们之间的互连线来实现的，在这种抽象级别下的设计与按照门级逻辑图来描述一个设计类似。门级描述就是指调用Verilog内建的基本门级元件来对硬件电路进行结构设计。这些基本的门级元件是一类特殊的模块，共有14种，分成4类，他们分别由Verilog语言自身提供。 开关级描述方式 开关级描述方式也称晶体管级描述方式，是Verilog最低级别的描述方式。在这种描述方式下，模块是按照开关级元件和存储节点以及它们之间的互连来实现的。具体来说是指调用Verilog内建的基本开关级原价来对硬件电路进行结构设计。与门级元件类似，这些基本的开关级元件也是一类特殊的模块，共有12种，由Verilog语言自身提供 模块调用1&lt;模块名&gt; &lt;参数值列表&gt; &lt;实例名&gt; (&lt;端口连接表&gt;)； 语法基础 注释：/*多行注释*/和//单行注释 数值可取下面的4类值： 0：逻辑0或者假状态 1：逻辑1或者真状态 x(X)：未知状态 z(Z)：高阻状态 整数型常量 简单的十进制格式。由0~9的数字串组成的十进制数，可以在数值前面加上符号“+”或“-”来表示数的正负 指定位宽的基数格式，由三部分组成：&lt;’base_format&gt; size指定数的二进制位宽，是一个非零的无符号十进制常量，size若省略默认32位 ‘base_format:单引号’是指定位宽格式表示法的固有字符，不能省略。base_format指定数的基数格式，用一个字母表示，对大小写不敏感。在base_format之前，单引号之后可以加上字母s(S)表示该数为有符号数。合法的技术格式字符串字母有d(D)-十进制；h(H)-十六进制；o(O)-八进制；b(B)-二进制。number是一个无符号的数，由相应基数格式的数字串组成。十六进制数字a~f对大小写也是不敏感的。可以在size之前加上“+”或“-”表示数的正或负，但是不能再base_format和number之间加“+”或“-”，因为这违背了Verilog的语法规则 下划线符号“_”除了不能放在数值的首位外，可以放在整数型和实数型内任何地方。它们对数值没有任何影响，在编译时会被忽略，只是为了将长的数值分段，提高可读性 数值常量中的？表示高阻状态 实数型常量 实数型常量可以通过对小数的四舍五入，转换为最靠近的整数型常量，而不是直接将小数舍弃，从而得到整数。当一个实数常量被赋给一个整数变量时，一种隐式的转换就发生了。例如实数-1.5转换为整数-2，实数35.2转换为整数得到35 实数既可以使用小数也可以使用科学计数法的方式来表达 字符串：用双引号“”括起来的字符序列，必须包含在一行内，不能分成多行书写 字符串变量是寄存器类型的变量，该字符串变量的位数要大于等于字符串的最大长度 存储一个12字符的字符串“Hello world！”需要一个8*12=96位的寄存器变量。 reg [8*12:1] stringvar; stringvar = &quot;Hello world&quot;; 如果声明的字符串变量位数大于字符串实际长度，则在赋值操作后，字符串变量的左端（即高位）补0.如果声明的字符串变量位数小于字符串实际长度，那么字符串的左端被截取，这些高位字符就丢失了 标识符分为简单标识符、转义标识符、生成标识符、关键字 简单标识符是由字母、数字、美元符号、下划线构成的任意序列。简单标识符的第一个符号不能是数字或者美元符号$ 关键字都用小写字母定义 标识符的第一个字符不能够是“$”，因为在Verilog中，“$”专门用来代表系统命令 Verilog中9个关键字：always,endmodule,reg,and,assign,begin,for,case,or,function,output,parameter,wait,if,else,input,while,end 系统任务和函数 为了便于设计者对仿真过程进行控制，以及对仿真结果进行分析，Verilog提供了大量的系统功能调用，大致分为： 任务型的功能调用，称为系统任务 函数型的功能调用，称为系统函数 Verilog的系统任务和系统函数是以字符$开头的标识符，他们的主要区别是 系统任务可以没有返回值或者有多个返回值，而系统函数只有一个返回值 系统任务可以带有延迟，而系统函数不允许延迟，在0时刻执行 用户可以根据需要基于Verilog仿真系统提供的PLI编程接口，编制特殊的系统任务和系统函数，根据系统任务和系统函数实现的功能不同，可将其分成以下几类： 标准输出任务 $display:将特定信息输出到标准输出设备时，具有自动换行的功能 $write：不带有行结束符 $displayb和writeb（输出二进制） $displayo和writeo（输出八进制） $displayh和writeh（输出十六进制） 格式说明符： %h或%H：以十六进制数的形式输出 %d或%D：以十进制数的形式输出 %o或%O：以八进制的形式输出 %b或%B：以二进制的形式输出 %c或%C：以ASCII码字符的形式输出 %s或%S：以字符串的形式输出 %v或%V：输出线型数据的驱动强度 %m或%M：输出模块的名称 文件管理任务 &lt;file_handle&gt;=$fopen(“&lt;file_name&gt;”);如果文件名&lt;file_name&gt;正确，则返回一个32位的句柄描述符&lt;file_handle&gt;，且其中只有一位为高电平 Verilog中用来将信息输出到文件的系统任务有$fdisplay,$fwrite,$fmonitor:&lt;task_name&gt;(&lt;file_handles&gt;,&lt;format_specifiers&gt;);其中&lt;task_name&gt;是上述三种系统任务中的一种。&lt;file_handles&gt;是文件句柄描述符，与打开文件所不同的是，可以对句柄进行多位设置。&lt;format_specifiers&gt;用来指定输出格式 $fclose(&lt;file_handle&gt;);关闭文件 Verilog中有两个系统任务$readmemb和$readmemh,它们能够把一个数据文件中的数据内容读入到一个指定的存储器中。这两个系统任务的区别在于，前者要求以二进制数据格式存放数据文件，而后者要求以十六进制数据格式存放数据文件。他们具有相同的语法格式：&lt;task_name&gt;(&lt;file_name&gt;,&lt;register_array&gt;,,);其中&lt;task_name&gt;用来指定系统任务，可取上述任务中的一个。&lt;file_name&gt;是读出数据的文件名。&lt;register_array&gt;为要读入数据的存储器。和分别为存储器的起始地址和结束地址。 系统任务$readmem中，被读取的数据文件内容只能够包含空白符、注释行、二进制或十六进制的数字，同样也可以存在不定态X、高阻态Z和下划线_。 数据文件中地址的表示格式为：“@”后面加上十六进制数字。同一个数据文件中可以出现多个地址。当系统任务遇到一个地址时，立刻将该地址后面的数据存放到存储器中相应的地址单元中 仿真控制任务 Verilog中有三种仿真监控任务：$monitor,$monitoron,$monitoroff $monitor(&lt;format_specifiers&gt;,signal,signal,…);该任务可用来连续监控指定的信号参数，如果发现其中的任一信号发生变化，则系统按照调用$monitor时规定的格式，在时间歩结束时显示整个信号表。 $finish和$stop这两个系统任务可以用来结束仿真。$finish用来终止仿真器的运行，结束仿真过程返回到操作系统。$stop暂时挂起仿真器，进入Verilog界面，可以通过输入相应命令使仿真继续进行 时间函数 $timeformat(,,,&lt;min_field_width&gt;)其中用于指定时间单位，取值范围是0~-15。指定所要显示时间信息的精度，是诸如“ms”，“ns”之类的字符，&lt;min_field_width&gt;说明时间信息的最小字符数 $timeformat(-9,2,&quot;ns&quot;,10) 时间显示函数 $time，返回64位整数，指定当前的仿真时间 $stime，返回32位的仿真时间 $realtime，以实数形式范湖当前的仿真时间 其他 随机函数 $random%,其中用来指定所产生的随机数的范围，即-+1到-1 转换函数 有时需要将整数转换成实数，或将实数转换成整数，或者用向量形式来表示实数等。Verilog提供了许多转换函数可以方便实现上述功能。 $rtio：通过截断小数部分，将实数转换成整数 $itor:将整数转换成实数 $realtobits:将实数转换成64位的实数向量表示 $bitstoreal:将位模式转换为实数 相等（==）与全等（===）运算符 相等运算中，如果任何一个操作数中存在不定态或者高阻态，将得到一个不定态的结果；而在全等运算中，则是将不定态和高阻态看作是逻辑状态的一种，同样参与比较，当这两个操作数的相应位都是X或者Z时，认为全等关系成立，否则运算结果为0。所以，全等是比较是否完全匹配，只有0和1两个状态，相等则会出现不定态。 缩位运算符&amp;，~&amp;，|，~|，^,~^ 缩位运算符是对单个操作数进行与或非等操作，与逻辑运算符的区别是最终结果和操作的位数无关，一定是1位的逻辑值。如果a为[3:0]，&amp;a等效于a[0]&amp;a[1]&amp;a[2]&amp;a[3],~|a等效于~(a[0]|a[1]|a[2]|a[3]) Verilog中的数据类型是指在硬件数字电路中数据进行存储和传输的方式。按照物理数据类型分类，Verilog中变量分为线型和寄存器型两种，两者在驱动方式、保持方式和对应的硬件实现都不同。这两种变量在定义时要设置位宽，缺省值为1位。变量的每一位可以是0，1，x或者z，其中x代表一个未被预置初始状态的变量，或者是由于两个或更多个驱动装置试图将之设定为不同的值而引起的冲突型变量。z代表高阻状态或悬空状态。 参数(parameters) 参数是常量的一种，经常用来定义延时、线宽、寄存器位数等物理量，可以增加代码的可读性和可维护性 参数的定义格式：parameter 参数名1=表达式1，参数名2=表达式2，参数名3=表达式3，…… 对含有参数的模块通常称为参数化模块 线型变量（Nets） 线型变量表示硬件电路中元器件之间的物理连接。它的值由驱动元件的值决定，并具有实时更新性 线型变量不具备电荷保持作用（trireg型除外），因此没有存储数据的能力，其逻辑值由驱动源提供和保持。各种线型变量在没有驱动源的情况下呈现高阻态（trireg保持不定态） wire,tri表示标准连线 wor，trior，多重驱动时，具有线或特性的连线 wand，triand，多重驱动时，具有线与特性的连线 tri1，tri0，上拉电阻，下拉电阻 supply1，supply0，电源线，地线 trireg，具有点和保持特性的连线 线型变量主要通过assign语句赋值。对于综合而言，wire型变量的取值可以是0，1，X与Z 寄存器型变量（Register），寄存器型变量对应的硬件电路并不一定是寄存器 寄存器型变量表示一个抽象的数据存储单元，它并不是指寄存器，而是所有具有存储能力的硬件电路的通称，如触发器、锁存器等。此外，寄存器型变量还包括测试文件中的激励信号。虽然这些激励信号并不是电路元件，仅是虚拟驱动源，但由于保持数值的特性，任然属于寄存器变量。 寄存器类型只能在always语句和initial语句中被赋值，并且它的值从一个赋值到另一个赋值被保存下来。寄存器型变量的缺省值是不定态X 寄存器型变量与线型变量的显著区别是寄存器型数据在接受下一次赋值之前，始终保持原值不变，而线型变量需要有持续的驱动 reg，表示常用的寄存器型变量 integer，表示32位带符号整数型变量 real，便是64位带符号整数型变量 time，无符号时间变量 存储器（Memories） 设计中，经常有存储指令或者存储数据等操作 存储器定义格式：reg[wordsize-1:0] memory_name[memorysize-1:0] 存储器可以看成是寄存器组成的数组 编译向导 类似于C语言中的编译预处理的功能，在编译时首先对这些编译向导进行预处理，然后保持其结果，将其与源代码一起进行编译 编译向导的标志是在某些标识符前面添加反引号“`” `define &lt;宏名&gt; &lt;宏定义的文本内容&gt;。用于文本定义，和C语言#define类似，即在编译时通知编译器，用宏定义中的文本直接替换代码中出现的宏名。宏定义语句可以用于模块的任意位置，通常写在模块的外面，建议使用大写字母表示宏名，便于与变量名相区别。在调用宏定义的时候，也需要撇号作为开头 `timescale &lt;时间单位&gt;/&lt;时间精度&gt;。时间单位和时间精度都是由整数和计时单位组成的。合法的整数有1，10，100；合法的计时单位为s,ms,us,ns,ps和fs。在仿真时间尺度中，时间单位用来定义模块内部仿真时间和延迟时间的基准单位；时间精度用来声明该模块仿真时间的精确程度。时间精度和时间单位的差别最好不要太大，因为在仿真过程中，仿真时间是以时间精度累计的，两者差异越大，仿真花费的时间就越长。另外，时间精度值至少要和时间单位一样精确，时间精度值不能大于时间单位值。如果一个设计中存在多个timescale，则采用最小的时间单位。如果不指定timescale，则系统默认执行时间单位为1ns，时间精度为1ns的timescale `include “文件名”。文件名中可以指定包含文件的路径，既可以是相对路径，也可以是完整的路径名。每条文件包含语句只能够用于一个文件的包含，但是，包含文件允许嵌套，即包含的文件中允许再去包含另外的一个文件 Verilog HDL中，所有的描述都是通过下面四种结构中的一种实现的，在一个模块内部可以由任意多个initial语句和always语句，两者都是从仿真的起始时刻开始执行的，但是initial语句后面的块语句只执行一次，而always语句则循环地重复执行后面的块语句，直到仿真结束。task任务和function函数可以在模块内部从一处或多处被调用 initial语句 12345678initial begin 语句1; 语句2; 语句3; ... 语句n; end always语句,多个敏感信号表达式之间用or或者逗号隔开 1234always @ （敏感信号表达式）begin......end task任务 任务可以在源代码的不同位置执行共同的代码段，这些代码段已经用任务定义编写成任务，因此能够从源代码的不同位置调用任务。 任务的定义与引用都在一份模块内部完成，任务内部可以包含时序控制，即时延控制，并且任务也能够调用任何任务（包括本身）和函数 定义任务与调用任务必须在同一个模块内，任务调用语句应该在always块或者task-endtask块中 定义任务时，没有端口名称表，但要进行端口与数据类型的声明 调用任务时，与调用模块一样，要列出端口名称表，但是顺序要与定义中的排序完全一致 任务中可以调用其他的任务或者函数，且调用的个数不受限制 定义格式：1234567task &lt;任务名&gt;； &lt;端口及数据类型定义语句&gt; &lt;语句1&gt; &lt;语句2&gt; ... &lt;语句n&gt;endtask function函数 函数与task一样，也可以在模块中的不同位置执行同一段代码，不同之处是函数只能返回一个值，它不能包含任何时间控制语句。函数可以调用其他函数，但是不能调用任务。此外，函数必须至少带有一个输入端口，在函数中允许没有输出或输入输出说明 函数的定义蕴含声明了一个与函数同名的，函数的内部寄存器，并作为函数的返回值传出函数 定义格式：12345678910function &lt;位宽说明&gt; 函数名； &lt;输入端口和类型说明&gt; &lt;局部变量说明&gt; begin &lt;语句1&gt; &lt;语句2&gt; ... &lt;语句n&gt; endendfunction 赋值语句Assignments，是Verilog中对线型和寄存器型变量赋值的主要方式，根据赋值对象的不同分为连续赋值语句（针对线型变量）和过程赋值语句（针对寄存器型变量） 线型变量一旦被连续赋值语句赋值后，赋值语句右端表达式中的信号有任何变化，都将实时反映到左端的线型变量中； 过程赋值语句只有在语句被执行到时，赋值过程才能够进行一次，而且赋值过程的具体执行时间还受到各种因素的影响 连续赋值语句不能出现在任何一个过程块中；过程赋值语句只能够出现在过程块中 连续赋值语句以关键词assign为先导。过程赋值语句不需要任何先导的关键词，但是语句的赋值分为阻塞性和非阻塞型 连续赋值语句 assign #[delay] &lt;线型变量&gt;=&lt;表达式&gt; 过程赋值语句 &lt;寄存器型变量&gt; = &lt;表达式&gt;，阻塞型过程赋值 &lt;寄存器型变量&gt; &lt;= &lt;表达式&gt;，非阻塞型过程赋值 阻塞型赋值语句的执行受到前后顺序的而影响，只有在第一条语句执行完之后才可以执行第二条语句，而在非阻塞型赋值语句中，则是某一规定时刻同时完成，不受先后顺序的影响。从某种角度来说，非阻塞型赋值语句的执行顺序与并行块的执行十分相像。 总结：阻塞赋值按顺序执行，非阻塞赋值，块结束后并行执行 块语句 串行块（begin-end） 串行块中的每条语句都是依据块中的排列次序顺序执行 串行块中每条语句的延时都是相对于前一条语句执行结束的相对时间 串行块的起始执行时间是块中第一条语句开始执行的时间，结束时间是最后一条语句执行结束的时间 并行快（fork-join） 并行块中的每条语句都是同时并行执行的，与排列次序无关 并行块中每条语句的延时都是相对于整个并行块开始执行的绝对时间 并行块的起始时间是流程控制转入并行块的时间，结束时间是并行块中按执行时间排序，最后执行的那条语句结束的时间 case语句 case语句要求敏感表达式的值与给定的值1、值2……或值n中的一个全等时，执行后面相应的块语句，如果均不相等，执行default语句 casez语句认为，如果给定的值中有一位或几位是高阻态z，则认为该位为“真”，敏感表达式与其比较时不予判断，只需比较其他几位 casex语句扩充为，如果给定的值中有一位或某几位是高阻态或者不定态，同样认为其为“真”，不予判断 Verilog中存在4中类型的循环语句，可以控制语句的执行次数。这四种语句分别是for语句，repeat语句，while语句和forever语句 for(循环变量赋初值；循环结束条件；循环变量增值) 块语句； repeat(循环次数表达式) 块语句； while(循环执行条件表达式) 块语句； forever 块语句；多用在initial块中，生成周期性输入波形，通常为不可综合语句 任务与函数的区别 函数需要在一个仿真时间单位内完成，而任务定义中可以包含任意类型的定时控制部分及weit语句等 函数不能调用任务，而任务可以调用任何任务和函数 函数只允许有输入变量且至少有一个，不能够有输出端口输入输出端口；任务可以没有任何端口，也可以包括各种类型的端口 函数通过函数名返回一个值；任务则不需要 减小NIOS程序的代码量 采用alt_main()作为程序入口 打开编译器优化选项，-O3 使用小封装的驱动库与C语言库 HAL为处理器的外设提供了两种驱动库：一种是执行速度快，但是代码量大的版本；另一种是小封装的版本。默认情况下，HAL系统使用的是代码量大的版本。可以选择Reduced device drivers选项来选择小封装版本，从而减小代码量 完整的ANSI C标准库通常不适用于嵌入式系统，HAL提供了一系列经过剪裁的新的ANSI C标准库，占用非常小的代码量。可以选择Small C library选项来选择新的ANSI C标准库 去掉不使用的驱动库 当用户的程序没有使用到NIOS系统中某些设备时，应该在系统中将这些设备完全移出 流水灯1234567891011121314151617181920212223242526272829303132333435363738394041module led_module(input EN,input CLK,output [3:0] leds);reg clk_hz;initial clk_hz= 1&apos;b0;//初始化只对仿真有效，综合器会自动无视reg[31:0]count;initial count = 32&apos;b0;reg[3:0] led_reg;initial led_reg = 4&apos;b1111;parameter SEC_TIME = 32&apos;d48_000_000;always@(posedge CLK)if(count == SEC_TIME&gt;&gt;1) begin count &lt;= 32&apos;b0; clk_hz = !clk_hz; endelse count &lt;= count+1&apos;b1; always@(posedge clk_hz)begin if(led_reg == 4&apos;b1111) led_reg &lt;= 4&apos;b1110; else if(led_reg == 4&apos;b1110) led_reg &lt;= 4&apos;b1101; else if(led_reg == 4&apos;b1101) led_reg &lt;= 4&apos;b1011; else if(led_reg == 4&apos;b1011) led_reg &lt;= 4&apos;b0111; else if(led_reg == 4&apos;b0111) led_reg &lt;= 4&apos;b1110; else led_reg &lt;= 4&apos;b1111;endassign leds = EN ? led_reg : 4&apos;bzzzz;endmodule 蜂鸣器12345678910111213141516171819202122232425module beep_module(input EN,input CLK,output BP);reg clk_hz;initial clk_hz= 1&apos;b0;//初始化只对仿真有效，综合器会自动无视reg[31:0]count;initial count = 32&apos;b0;parameter SEC_TIME = 32&apos;d48_000_000;always@(posedge CLK)if(count == SEC_TIME&gt;&gt;1) begin count &lt;= 32&apos;b0; clk_hz = !clk_hz; endelse count &lt;= count+1&apos;b1; assign BP = EN ? clk_hz : 1&apos;bz;endmodule 8位共阳数码管12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//8位共阳数码管module HEX8(Clk,Rst_n,En,disp_data,sel,seg); input Clk;//输入50M外部时钟 input Rst_n; input En;//使能引脚，低功耗考虑 input [31:0]disp_data;//数码管总共有8位，每位显示0~F(4位表示) output [7:0]sel;//数码管位选(选择当前要显示的数码管) output reg [7:0]seg;//数码管段选(当前要显示的内容) reg [14:0]divider_cnt; localparam DELAY_ONE_MS = 25_000;//500us/20ns=25000 reg clk_1k; reg [7:0]sel_r; reg [3:0]data_tmp; //分频计数器计数模块 always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) divider_cnt &lt;= 15&apos;d0; else if(En == 1&apos;b0) divider_cnt &lt;= 15&apos;d0; else if(divider_cnt == DELAY_ONE_MS -1) divider_cnt &lt;= 1&apos;d0; else divider_cnt &lt;= divider_cnt + 1&apos;b1; //1KHz扫描时钟生成模块 always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) clk_1k &lt;= 1&apos;b0; else if(divider_cnt == DELAY_ONE_MS -1) clk_1k &lt;= ~clk_1k; else clk_1k &lt;= clk_1k; //8位循环移位寄存器 always@(posedge clk_1k or negedge Rst_n) if(Rst_n == 1&apos;b0) sel_r &lt;= 8&apos;b0000_0001; else if(sel_r == 8&apos;b1000_0000) sel_r &lt;= 8&apos;b0000_0001; else sel_r &lt;= sel_r &lt;&lt; 1; //8选1多路选择器 always@(*) case(sel_r) 8&apos;b0000_0001:data_tmp = disp_data[3:0]; 8&apos;b0000_0010:data_tmp = disp_data[7:4]; 8&apos;b0000_0100:data_tmp = disp_data[11:8]; 8&apos;b0000_1000:data_tmp = disp_data[15:12]; 8&apos;b0001_0000:data_tmp = disp_data[19:16]; 8&apos;b0010_0000:data_tmp = disp_data[23:20]; 8&apos;b0100_0000:data_tmp = disp_data[27:24]; 8&apos;b1000_0000:data_tmp = disp_data[31:28]; default:data_tmp = 4&apos;b0000; endcase always@(*) case(data_tmp) 4&apos;h0:seg = 8&apos;hc0; 4&apos;h1:seg = 8&apos;hf9; 4&apos;h2:seg = 8&apos;ha4; 4&apos;h3:seg = 8&apos;hb0; 4&apos;h4:seg = 8&apos;h99; 4&apos;h5:seg = 8&apos;h92; 4&apos;h6:seg = 8&apos;h82; 4&apos;h7:seg = 8&apos;hf8; 4&apos;h8:seg = 8&apos;h80; 4&apos;h9:seg = 8&apos;h90; 4&apos;ha:seg = 8&apos;h88; 4&apos;hb:seg = 8&apos;h83; 4&apos;hc:seg = 8&apos;hc6; 4&apos;hd:seg = 8&apos;ha1; 4&apos;he:seg = 8&apos;h86; 4&apos;hf:seg = 8&apos;h8e; endcase assign sel = ((En==1&apos;b1) ? sel_r:8&apos;b0000_0000);endmodule 按键消抖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145module key_filter(Clk,Rst_n,key_in,key_flag,key_status); input Clk; input Rst_n; input key_in; output reg key_flag;//按键按下或者弹起便产生一个脉冲 output reg key_status;//按键当前的状态，0表示按下 reg [3:0]state;//状态机变量 localparam IDEL = 4&apos;b0001,//空闲 FILTER0 = 4&apos;b0010,//按下消抖 DOWN = 4&apos;b0100,//按下且稳定 FILTER1 = 4&apos;b1000;//松开消抖 reg [19:0]cnt;//用于20ms延迟的计数器 reg en_cnt;//计数器使能信号 reg cnt_full;//计数器满标志信号 reg key_in_s0,key_in_s1;//同步按键输入(按键输入为异步信号)用的两级寄存器 reg key_tmp0,key_tmp1;//边沿检测用的两级寄存器 wire pedge,nedge; //50_000_000-&gt;20ns,20ms/20ns=1_000_000 parameter twenty_ms = 1_000_000;//消抖时间一般为20ms //对异步信号进行同步处理 always@ (posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0)begin key_in_s0 &lt;= 1&apos;b0; key_in_s1 &lt;= 1&apos;b0; end else begin key_in_s0 &lt;= key_in; key_in_s1 &lt;= key_in_s0; end //按键边沿检测 always@ (posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0)begin key_tmp0 &lt;= 1&apos;b0; key_tmp1 &lt;= 1&apos;b0; end else begin key_tmp0 &lt;= key_in_s1;//key_in_s1为同步后的按键输入信号 key_tmp1 &lt;= key_tmp0; end //边沿检测组合逻辑电路 assign nedge = (key_tmp0 == 1&apos;b0 &amp;&amp; key_tmp1 == 1&apos;b1); assign pedge = (key_tmp0 == 1&apos;b1 &amp;&amp; key_tmp1 == 1&apos;b0); //一段式状态机主程序 always@ (posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0)begin en_cnt &lt;= 1&apos;b0; state &lt;= IDEL; key_flag &lt;= 1&apos;b0; key_status &lt;= 1&apos;b1; end else begin case(state) IDEL: begin key_flag &lt;= 1&apos;b0; if(nedge)begin state &lt;= FILTER0; en_cnt &lt;= 1&apos;b1; end else state &lt;= IDEL; end FILTER0: if(cnt_full)begin en_cnt &lt;= 1&apos;b0; state &lt;= DOWN; key_flag &lt;= 1&apos;b1; key_status &lt;= 1&apos;b0; end else if(pedge)begin en_cnt &lt;= 1&apos;b0; state &lt;= IDEL; end else state &lt;= FILTER0; DOWN: begin key_flag &lt;= 1&apos;b0; if(pedge)begin state &lt;= FILTER1; en_cnt &lt;= 1&apos;b1; end else state &lt;= DOWN; end FILTER1: if(cnt_full)begin state &lt;= IDEL; key_flag &lt;= 1&apos;b1; key_status &lt;= 1&apos;b1; end else if(nedge)begin en_cnt &lt;= 1&apos;b0; state &lt;= DOWN; end else state &lt;= FILTER1; default: begin state &lt;= IDEL; en_cnt &lt;= 1&apos;b0; key_flag &lt;= 1&apos;b0; key_status &lt;= 1&apos;b1; end endcase end //计数器 always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) cnt &lt;= 20&apos;d0; else if(en_cnt) cnt &lt;= cnt +1&apos;b1; else cnt &lt;= 20&apos;d0; //判断是否计数满20ms always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) cnt_full &lt;= 1&apos;b0; else if(cnt == twenty_ms-1) cnt_full &lt;= 1&apos;b1; else cnt_full &lt;= 1&apos;b0; endmodule 串口通信 起始位：低电平，停止位：高电平 串口发送模块包含两个主要组件： 发送波特率生成模块 数据发送模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135//串口发送模块module uart_byte_tx( Clk, Rst_n, data_byte, send_en, baud_set, Rs232_Tx, Tx_Done, uart_state); input Clk; input Rst_n; input [7:0]data_byte; input send_en; input [2:0]baud_set; output reg Rs232_Tx; output reg Tx_Done; output reg uart_state; reg bps_clk;//波特率时钟 reg [15:0]bps_DR;//分频计数最大值 reg [15:0]div_cnt;//分频计数器 reg [3:0]bps_cnt;//波特率计数时钟 reg [7:0]r_data_byte; localparam START_BIT = 1&apos;b0, STOP_BIT = 1&apos;b1; //外部数据寄存，保持数据稳定 always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) r_data_byte = 8&apos;d0; else if(send_en) r_data_byte &lt;= data_byte; else r_data_byte &lt;= r_data_byte; //uart_state always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) uart_state &lt;= 1&apos;b0; else if(send_en) uart_state &lt;= 1&apos;b1; else if(bps_cnt == 4&apos;d11) uart_state &lt;= 1&apos;b0; else uart_state &lt;= uart_state; //波特率分频系数查找表 always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) bps_DR &lt;= 16&apos;d5207; else begin case(baud_set) 3&apos;d0:bps_DR &lt;= 16&apos;d5207;//9600Hz 3&apos;d1:bps_DR &lt;= 16&apos;d2603;//19200Hz 3&apos;d2:bps_DR &lt;= 16&apos;d1301;//38400Hz 3&apos;d3:bps_DR &lt;= 16&apos;d867;//57600Hz 3&apos;d4:bps_DR &lt;= 16&apos;d433;//115200Hz default:bps_DR &lt;= 16&apos;d433;//115200Hz endcase end //波特率计数器 always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) div_cnt &lt;= 16&apos;d0; else if(uart_state)begin if(div_cnt == bps_DR) div_cnt &lt;= 16&apos;d0; else div_cnt &lt;= div_cnt + 1&apos;b1; end else div_cnt &lt;= 16&apos;d0; //产生波特率时钟 always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) bps_clk &lt;= 1&apos;b0; else if(div_cnt == 16&apos;d1) bps_clk &lt;= 1&apos;b1; else bps_clk &lt;= 1&apos;b0; //bps counter always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) bps_cnt &lt;= 4&apos;d0; else if(bps_cnt == 4&apos;d11) bps_cnt &lt;= 4&apos;d0; else if(bps_clk) bps_cnt &lt;= bps_cnt + 1&apos;b1; else bps_cnt &lt;= bps_cnt; //Tx_Done always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) Tx_Done &lt;= 1&apos;b0; else if(bps_cnt == 4&apos;d11) Tx_Done &lt;= 1&apos;b1; else Tx_Done &lt;= 1&apos;b0; //串口发送逻辑 always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) Rs232_Tx &lt;= 1&apos;b1; else begin case(bps_cnt) 4&apos;d0:Rs232_Tx &lt;= 1&apos;b1; 4&apos;d1:Rs232_Tx &lt;= START_BIT; 4&apos;d2:Rs232_Tx &lt;= r_data_byte[0]; 4&apos;d3:Rs232_Tx &lt;= r_data_byte[1]; 4&apos;d4:Rs232_Tx &lt;= r_data_byte[2]; 4&apos;d5:Rs232_Tx &lt;= r_data_byte[3]; 4&apos;d6:Rs232_Tx &lt;= r_data_byte[4]; 4&apos;d7:Rs232_Tx &lt;= r_data_byte[5]; 4&apos;d8:Rs232_Tx &lt;= r_data_byte[6]; 4&apos;d9:Rs232_Tx &lt;= r_data_byte[7]; 4&apos;d10:Rs232_Tx &lt;= STOP_BIT; default:Rs232_Tx &lt;= 1&apos;b1; endcase endendmodule 串口接收模块 对于接收数据中的每一位进行采样，一般情况下每一位数据的中间点是最稳定的，因此在一般应用中，采集中间时刻的数据即可，但是在工业应用中，往往有非常强的电磁干扰，只采样一次就作为该数据的电平判定，是不保险的，有可能恰好采集到被干扰的信号而导致结果出错，因此需要使用多次采样求概率的方式进行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194//串口接收模块,采用过采样的方案，将有效时间分成5-6-5三段，检查中间6端的数据，有效降低工业环境的干扰module uart_byte_rx( Clk, Rst_n, baud_set, Rs232_Rx, data_byte, Rx_Done); input Clk; input Rst_n; input [2:0]baud_set; input Rs232_Rx;//Rx输入引脚 output reg[7:0]data_byte;//接收到的数据 output reg Rx_Done;//接收完毕信号 reg s0_Rs232_Rx,s1_Rs232_Rx;//同步寄存器，消除亚稳态 reg tmp0_Rs232_Rx,tmp1_Rs232_Rx;//数据寄存器,用于边沿检测 wire nedge;//下降沿标志 reg [15:0]bps_DR;//分频计数最大值 reg [15:0]div_cnt;//分频计数器 reg uart_state; reg bps_clk;//波特率时钟 reg [7:0]bps_cnt;//波特率计数时钟 reg [2:0]r_data_byte [7:0]; reg [2:0]START_BIT,STOP_BIT; //同步寄存器，消除亚稳态,s1_Rs232_Rx为最终稳定的输入数据 always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0)begin s0_Rs232_Rx &lt;= 1&apos;b0; s1_Rs232_Rx &lt;= 1&apos;b0; end else begin s0_Rs232_Rx &lt;= Rs232_Rx; s1_Rs232_Rx &lt;= s0_Rs232_Rx; end //数据寄存器 always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0)begin tmp0_Rs232_Rx &lt;= 1&apos;b0; tmp1_Rs232_Rx &lt;= 1&apos;b0; end else begin tmp0_Rs232_Rx &lt;= s1_Rs232_Rx; tmp1_Rs232_Rx &lt;= tmp0_Rs232_Rx; end assign nedge = (tmp0_Rs232_Rx==1&apos;b0 &amp;&amp; tmp1_Rs232_Rx==1&apos;b1); //波特率分频系数查找表 always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) bps_DR &lt;= 16&apos;d324; else begin case(baud_set) 3&apos;d0:bps_DR &lt;= 16&apos;d324;//9600Hz,50000000/9600/16=325 3&apos;d1:bps_DR &lt;= 16&apos;d162;//19200Hz 3&apos;d2:bps_DR &lt;= 16&apos;d80;//38400Hz 3&apos;d3:bps_DR &lt;= 16&apos;d53;//57600Hz 3&apos;d4:bps_DR &lt;= 16&apos;d26;//115200Hz default:bps_DR &lt;= 16&apos;d26;//115200Hz endcase end //波特率计数器 always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) div_cnt &lt;= 16&apos;d0; else if(uart_state)begin//检测到有效信号才开始计数，随之产生波特率 if(div_cnt == bps_DR) div_cnt &lt;= 16&apos;d0; else div_cnt &lt;= div_cnt + 1&apos;b1; end else div_cnt &lt;= 16&apos;d0; //产生波特率时钟 always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) bps_clk &lt;= 1&apos;b0; else if(div_cnt == 16&apos;d1) bps_clk &lt;= 1&apos;b1; else bps_clk &lt;= 1&apos;b0; //bps counter,159=16*10-1 always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) bps_cnt &lt;= 8&apos;d0; else if(bps_cnt == 8&apos;d159 | (bps_cnt == 8&apos;d12 &amp;&amp; (START_BIT &gt; 2))) bps_cnt &lt;= 8&apos;d0; else if(bps_clk) bps_cnt &lt;= bps_cnt + 1&apos;b1; else bps_cnt &lt;= bps_cnt; //Rx_Done always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) Rx_Done &lt;= 1&apos;b0; else if(bps_cnt == 8&apos;d159) Rx_Done &lt;= 1&apos;b1; else Rx_Done &lt;= 1&apos;b0; //data_byte always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) data_byte &lt;= 8&apos;d0; else if(bps_cnt == 8&apos;d159)begin data_byte[0] &lt;= r_data_byte[0][2];//100开始表示收到1的概率大，数据判定为1 data_byte[1] &lt;= r_data_byte[1][2]; data_byte[2] &lt;= r_data_byte[2][2]; data_byte[3] &lt;= r_data_byte[3][2]; data_byte[4] &lt;= r_data_byte[4][2]; data_byte[5] &lt;= r_data_byte[5][2]; data_byte[6] &lt;= r_data_byte[6][2]; data_byte[7] &lt;= r_data_byte[7][2]; end //串口接收逻辑 always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) begin START_BIT &lt;= 3&apos;d0; r_data_byte[0]&lt;= 3&apos;d0; r_data_byte[1]&lt;= 3&apos;d0; r_data_byte[2]&lt;= 3&apos;d0; r_data_byte[3]&lt;= 3&apos;d0; r_data_byte[4]&lt;= 3&apos;d0; r_data_byte[5]&lt;= 3&apos;d0; r_data_byte[6]&lt;= 3&apos;d0; r_data_byte[7]&lt;= 3&apos;d0; STOP_BIT &lt;= 3&apos;d0; end else if(bps_clk)begin case(bps_cnt) 0:begin START_BIT &lt;= 3&apos;d0; r_data_byte[0]&lt;= 3&apos;d0; r_data_byte[1]&lt;= 3&apos;d0; r_data_byte[2]&lt;= 3&apos;d0; r_data_byte[3]&lt;= 3&apos;d0; r_data_byte[4]&lt;= 3&apos;d0; r_data_byte[5]&lt;= 3&apos;d0; r_data_byte[6]&lt;= 3&apos;d0; r_data_byte[7]&lt;= 3&apos;d0; STOP_BIT &lt;= 3&apos;d0; end 6,7,8,9,10,11:START_BIT &lt;= START_BIT + s1_Rs232_Rx; 22,23,24,25,26,27:r_data_byte[0] &lt;= r_data_byte[0] + s1_Rs232_Rx; 38,39,40,41,42,43:r_data_byte[1] &lt;= r_data_byte[1] + s1_Rs232_Rx; 54,55,56,57,58,59:r_data_byte[2] &lt;= r_data_byte[2] + s1_Rs232_Rx; 70,71,72,73,74,75:r_data_byte[3] &lt;= r_data_byte[3] + s1_Rs232_Rx; 86,87,88,89,90,91:r_data_byte[4] &lt;= r_data_byte[4] + s1_Rs232_Rx; 102,103,104,105,106,107:r_data_byte[5] &lt;= r_data_byte[5] + s1_Rs232_Rx; 118,119,120,121,122,123:r_data_byte[6] &lt;= r_data_byte[6] + s1_Rs232_Rx; 134,135,136,137,138,139:r_data_byte[7] &lt;= r_data_byte[7] + s1_Rs232_Rx; 150,151,152,153,154,155:STOP_BIT &lt;= STOP_BIT + s1_Rs232_Rx; default: begin START_BIT = START_BIT; r_data_byte[0] &lt;= r_data_byte[0]; r_data_byte[1] &lt;= r_data_byte[1]; r_data_byte[2] &lt;= r_data_byte[2]; r_data_byte[3] &lt;= r_data_byte[3]; r_data_byte[4] &lt;= r_data_byte[4]; r_data_byte[5] &lt;= r_data_byte[5]; r_data_byte[6] &lt;= r_data_byte[6]; r_data_byte[7] &lt;= r_data_byte[7]; STOP_BIT = STOP_BIT; end endcase end always@(posedge Clk or negedge Rst_n) if(Rst_n == 1&apos;b0) uart_state &lt;= 1&apos;b0; else if(nedge) uart_state &lt;= 1&apos;b1; else if(Rx_Done || (bps_cnt == 8&apos;d12 &amp;&amp; (START_BIT &gt; 2)))//接收结束或者接收到错误的开始位 uart_state &lt;= 1&apos;b0; else uart_state &lt;= uart_state; endmodule VGA VGA全称Video Graphic Array，也叫显示绘图阵列，是逐行扫描的显示制式，其支持的分辨率为640X480，对更高分辨率800X600称为SVGA模式；1024X768称为XVGA VGA时序分行时序和帧时序，两者都包含同步脉冲（Sync a），显示后延（Back porch b），显示时序段（Display interval c）和显示前沿（Front porch d）四个部分 VGA时序 各种分辨率的行场同步时序如图 VGA参考时序数据表 基于NIOS II的SOPC技术 Nios II处理器 典型系统架构 可二次开发的32位RISC软核处理器，基于哈佛结构，免版税 32个通用寄存器，3种指令格式，32位指令，32位数据总线，平面寄存器文件，高速缓冲Cache(指令缓存和数据缓存分开)，分支预测，紧耦合型存储器选项，32级中断支持 凡是需要存储程序代码的外设都需要连接到nios的指令总线上 经验之谈 异步信号的同步处理 对于异步信号输入，为了避免时钟沿采到的数据处于亚稳态引起电路振荡，一般在异步信号输入后面加入两级D触发器 分频后的时钟信号不能直接去驱动D触发器","tags":[{"name":"Verilog","slug":"Verilog","permalink":"https://suda-morris.github.io/tags/Verilog/"}]},{"title":"Linux Basic","date":"2015-11-12T07:40:17.000Z","path":"2015/11/12/linux-basic/","text":"Linux内核组成部分 内存管理 进程管理负责控制进程对CPU的访问，如任务的创建、调度和终止等。任务调度是进程管理最核心的工作，由Linux内核调度器来完成。Linux内核调度器根据一定算法来选择最值得运行的进程 运行态：已经获得了资源，并且进程正在被CPU执行进程既可以运行在内核态，也可运行在用户态 内核态：内核和驱动所运行时的状态，程序处于特权阶级，能够访问系统的任何资源 用户态：用户程序运行的状态，处于非特权阶级，不能随意访问系统资源，必须通过驱动程序方可访问，用户态程序运行的状态，处于非特权阶级，不能随意访问系统资源，必须通过驱动程序方可访问，用户态程序可通过系统调用进入内核态。 就绪态：当系统资源已经可用，但由于前一个进程还没有执行完而释放CPU，准备进入运行状态 可中断睡眠状态：当进程处于可中断等待状态时，系统不会调度改程序执行。当系统产生一个中断或者释放了进程正在等待的资源，或者进程收到一个信号，都可以被唤醒进入就绪状态或者运行态 不可中断睡眠状态：处于中断等待状态，但是该进程只能被使用wake_up（）函数明确唤醒的时候才可进入就绪状态。 暂停状态：当进程收到SIGSTOP、SIGSTP、SIGTTIN或者SIGTTOU就会进入暂停状态，收到SIGCONT信号即可进入运行态 僵死态：进程已经被停止运行，但是其父进程还没有询问其状态 Linux进程状态和转换 内存管理 内存管理的主要作用是控制和管理多个进程，使之能够安全的共享主内存区域。当CPU提供内存管理单元MMU时，内存管理为各进程实现虚拟地址到内存物理地址的转换。在32位系统上，Linux内核将4G空间分为1G内核空间（3~4G）和3G（0~3G）用户控件，通过内存管理，每个进程都可以使用3G的用户空间 文件系统 Linux内核支持众多的逻辑文件系统，如Ext2、Ext3、Ext4、btrfs、NFS、VFAT等。VFS则是Linux基于各种逻辑文件系统抽象出的一种内存中的文件系统，隐藏了各种硬件设备的细节，为用户提供了同意的操作接口，是用户访问各种不同文件系统和设备时，不用区分具体的逻辑文件系统。 网络接口 Linux对网络支持相当完善，网络接口提供了对各种网络标准的存取和各种网络硬件的支持，接口可分为网络协议和网络驱动程序。网络协议部分负责实现每一种可能的网络传输协议。网络设备驱动程序负责与硬件设备通讯，每一种可能的硬件设备都有相应的设备驱动程序 进程间通信 支持进程间各种通信机制，如管道、命令管道、信号、消息队列、内存共享、信号量和套接字等。 管道通常用于具有亲缘关系的父子进程或者兄弟进程间通信，是半双工的，数据只能往一个方向流动，先入先出，与自来水管很相似。如果双方胡同时，需要建立两个管道 命名管道突破了进程间的亲缘关系限制，即非父子、兄弟进程之间也可以相互通信 信号是软件中断，用于在多个进程之间传递一步信号。 信号能传递的信息很有限，而消息队列正好弥补了这点。 共享内存常用于不同进程间进行大量数据传递。Linux下每个进程都有自己的独立空间，各自都不能直接访问其他进程的空间。 信号量用于进程同步。只有获得了信号量的进程才可以运行，没有获得信号量的进程则只能等待。 套接字起源于BSD，也常称“BSD套接字”，用于多个进程间通信，可以基于文件，也可以基于网络。 Linux操作系统基本体系结构 设置主板支持虚拟化 进入BIOS（F2或者F10等等） 找到Intel Virtualization Technology选项，设置为Enable 设置好后重启电脑 虚拟网卡有三种模式 桥接模式 这种情况下，虚拟机虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台主机。在桥接模式下，虚拟系统和宿主机的关系就像连接在同一个Hub上的两台电脑。用户需要手工为虚拟系统配置IP地址、子网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的而一个独立的主机系统，那么就可以手工配置它的TCP/IP配置信息，以实现通过局域网的网关或罗尤其访问互联网。在进行嵌入式Linux开发，要目标板通过NFS挂载虚拟机的NFS共享目录的话，必须将虚拟王珂配置为桥接模式 NAT模式 使用NAT模式，就是让虚拟机系统借助NAT（网络地址转化）功能，通过宿主机器在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8（NAT）虚拟网络的DHCP服务器提供的，虚拟机无法正常对主机锁链网络中的其他主机提供普通的而络服务，如TFTP、NFS和FTP等。采用NAT模式最大的优势是虚拟系统接入互联网非常简单，用户不需要进行任何其他的配置，只需要宿主机器能访问互联网即可 Host-Only模式 在某些特殊的网络调试环境中，要求将真实环境和虚拟环境隔开，这是用户就可采用仅主机（Host-Only）模式。在Host-Only模式中，所有的虚拟系统是可以相互通信的，但虚拟系统和真实的网络是被隔离开的。 简单的Shell cd -:切换至之前的工作目录 ls -lash:查看当前目录文件信息 pwd：查看当前路径 mkdir -p：创建多级目录 rmdir：删除空目录 alias rm=”rm -vi”：为rm -vi取别名 rm -rf:强制删除某些文件或者目录 touch a：创建a文件，文件大小为0 file a：读取a文件的文件头并识别文件类型。a文件必须具有可读属性 more/less：两个命令都能用来浏览文本文件，可以分页查看文件内容，空格翻页。文件浏览完毕，按键盘q退出。相比来说，less命令更加灵活，支持键盘Page Up和Page Down键，可任意向前后翻页浏览，并且还支持文本搜索。使用less打开文件后，输入/abc可在文本中搜索字符串abc head/tail：这两个命令可分别查看文件头部和文件尾部，一般用于查看ASCII文件。默认显示10行，加上参数-n【数字】可以指定显示行数或者加上参数-c【数字】指定显示的字节数 cat：cat命令可以将一个或者多个文件输出到标准输出上，可以用于文件查看 文件合并：cat [选项] 文件1 文件2 … [&gt;文件3] 选项 -n ：从1开始对输出进行编号 -b：类似于-n，从1开始编号，但是忽略空白行 -s：遇到连续两行或者以上的空白行，就替换为一行空白行 文件压缩/解压：tar [选项] 文件 tar是UNIX系统的一个文件打包工具，只是连续首位相连的将文件堆放起来，并不具备压缩功能，但是加上选项，tar可以调用其它压缩/解压工具，能够实现文件的压缩和解压 选项 -c：创建存档文件，与-x相斥 -t：列出档案文件的文件列表 -x：解包存档文件，与-c相斥 -A：合并存档文件 -d：比较存档文件与源文件 -r：追加文件到存档文件末尾 -u：更新存档文件 -f：指定存档文件，与其他选项同时使用时，必须在最后，如tar -xjvf a.tar.bz2 -v:显示详细处理信息 -C：转到指定目录，常用于解开存档文件 -j：调用bzip2程序 -z：调用gzip程序 -Z：调用compress程序 –exclude=PATH：排除指定文件或者目录，常用于打包文件 文件复制：cp [选项] 源文件/目录 目的文件/目录 选项： -a：保留链接，文件属性并递归复制，等同于-dpR组合，常用于复制目录 -d：复制时保留链接 -f：若目标文件已经存在，则直接删除而不提示 -i：若目标文件已经存在，需要用户确认操作，与-f相反 -p：除复制文件内容外，把访问权限和修改时间也复制到新文件中 -f：递归复制，递归复制指定目录下的文件和目录 -v：显示文件复制过程 创建链接：ln [选项] 源文件/目录 目标文件 硬链接通过索引节点进行链接，相当于源文件的镜像，占用源文件一样大小的空间，修改其中任何一个，另外一个都会进行同样的改动。给一个文件创建硬链接后，文件属性的硬连接数会增加。硬链接不能跨越文件系统，只能在同一个文件系统内进行链接，且不能对目录文件建立硬链接，给目录文件建立硬链接会出错 软连接和硬链接不同，软连接是产生一个新文件，这个文件指向另一个文件的位置，类似于Windows下的快捷方式。软连接可以跨越文件系统，且用于任何文件，包括目录文件 网卡配置：ifconfig 网络接口 [选项] 地址/参数 选项： -a：查看系统拥有的全部网络接口 网络接口如eth0：指定操作某个网口 broadcast：设置网口的广播地址 netmask：设置网口的子网掩码 hw ether：设置网卡物理地址（如果驱动不支持则无效） up：激活指定网卡 down：关闭指定网卡 安装和卸载文件系统 linux允许多个文件系统存在于同一个系统中，也允许用户在系统运行中安装内核所支持的文件系统。例如，讲一个FAT格式的U盘插入到linux系统中。 linux安装文件系统：mount [参数] [设备名] [挂载点] 参数： -a：挂载/etc/fstab文件中列出的所有文件系统 -r：以只读的方式挂载 -w：以可写的方式挂载（默认） -v：显示详细安装信息 -t&lt;文件系统类型&gt;：指定文件系统类型，常见的有： ext/ext2/ext3/ext4:Linux常用文件系统 msdos：MS-DOS的FAT，即FAT16 vfat：Windows系统的FAT，FAT32 nfs：网络文件系统 ntfs：Windows2000/NT/XP的ntfs文件系统 auto：自动检测文件系统 -o&lt;选项&gt;：指定挂载时的一些选项，常用有： defaults：使用默认值（auto，nouser，rw，suid） suid/nosuid：确认/不确认suid和sgid位 user/nouser：允许/不允许一般用户挂载 codepage=XXX：指定codepage iocharset=XXX：指定字符集 ro：以只读方式挂载 rw：以读写方式挂载 remount：重新安装已经安装了的文件系统 loop：挂载loopback设备以及ISO文件 挂载点必须是一个已经存在的目录 一个挂载点可以被多个设备/文件重复挂载，只是后一次挂载将覆盖前一次内容，卸载后可用 使用多个-o参数的时候，-o只用一次，参数之间用半角逗号隔开 例如，挂载FAT格式的U盘： mount -t vfat /dev/sda1 /mnt nfs挂载，将远程主机主机Linux的某个共享目录挂载到嵌入式系统本地，当成本地设备进行操作： mount -t nfs 192.168.1.138:/home/morris/lpc/mnt -o nolock nolock表示禁用文件锁，当连接到一个旧版本的NFS服务器时常加该选项 此外，嵌入式开发中常用的文件系统还有cramfs，jffs2，yaffs2以及ubifs等，特别是用于NOR Flash的jffs2和用于NAND Flash的yaffs/yaffs2,ubifs等，在进行系统操作中通常需要对各设备进行挂载或者卸载，需要在挂载的时候指定正确的文件系统类型。 挂载yaffs2分区的命令示例：mount -t yaffs2 /dev/mtdblock2 /mnt 挂载ubifs分区的命令示例：mount -t ubifs ubi0:rootfs /mnt 文件系统卸载：umount 挂载点 使用sudo命令需要管理员将用户添加到sudoer组中，一般在/etc/sudoer文件中修改 linux中，对文件的操作都是先保存在缓存中，并没有立即写入磁盘，经系统调度后方可写入磁盘。如果修改了缓存，还没来得及写到磁盘就断电，自然就会造成文件改变丢失。要避免这种情况，就是修改文件后，立即强制进行一次文件同步操作，将缓存的内容写入磁盘，确保文件系统的完整性。能完成这样功能的命令是sync。只需要在关闭文本编辑器后再shell输入sync即可 文件搜索，find 路径 选项 其他 最常用的就是根据文件名来查找，加上-name就可以了，还可以支持通配符，进行模糊搜索。例如：find arch/arm/ -name mux*.c 字符串搜索： grep 选项 例如：grep “pcf8563” -R arch/arm 关键字最好加上双引号，特别是包含空格的关键字。 -R表示递归查找 执行Shell脚本有多种方式： 点+斜线+文件名，这种方式要求文件必须具有可执行权限 点+空格+文件名，这种方式不要求文件一定具有可执行权限 sh+空格+文件名，这种方式不要求文件一定具有可执行权限 source+空格+文件名，这种方式不要求文件一定具有可执行权限 重定向 Linux Shell终端启动的时候会打开3个标准文件：标准输入（stdin）、标准输出（stdout）和标准错误（stderr）。shell从标准输入（通常是键盘）接收命令，命令执行结果信息打印到标准输出（通常是终端屏幕）上，如有错误信息，则打印到标准错误（通常是终端屏幕）上。 Shell允许用户对输入输出进行重定向。输出重定向允许将输出信息从标准输出重定向到其他文件上，也可以重定向到某个设备如打印机上。 重定向在Linux下用“&gt;”和“&gt;&gt;”表示，“&gt;”表示输出到一个新文件中，而“&gt;&gt;”则表示输出到现有文件的末尾。如果文件已经存在，直接操作文件，否则将创建新文件。 echo命令将内容回显到标准输出上，使用echo命令加上重定向可以创建一个带内容的非空文件。 回显内容如果不加引号，则用单空格替代多个连续空格，如果加了引号，则原封不动回显 使用内核模块和驱动 加载（插入）模块 linux能够动态加载和卸载模块。如果某些功能平时用不到，可以不编译进内核，而采取模块方式编译，在需要的时候再插入内核，不再需要的时候卸载。linux中最常见的模块是内核驱动 insmod [选项] 模块 [符号名称=值]，常用选项 -f：强制将模块载入，不检查目前kernel版本与模块编译时的kernel是否一致 -k：将模块设置为自动卸载 -p：测试模块是否能正确插入 -x：不导出模块符号 -X：导出模块所有外部符号（默认） -v：显示执行过程 查看系统已经加载的模块：lsmod，其实际上就是列出/proc/modules的内容 卸载驱动模块：rm [选项] 模块，常用选项 -f：强制卸载正在被使用的模块，非常危险。需要内核支持CONFIG_MODULE_FORCE_UNLOAD使能，否则无效 -w：通常情况下不能卸载正在被使用的模块，加上-w选项，指定模块将会被孤立，直到不再被使用 -s：将错误信息写入syslog，而不是标准错误 -v：显示执行过程 自动处理可加载模块：insmod/rmmod分别用于加载和卸载模块，但是每次只能加载/卸载一个模块，如果一个模块依赖于多个模块，则需要进行多次操作，比较繁琐。modprobe命令集加载/卸载功能于一身，并且可以自动解决模块的依赖关系。modprobe [选项] 模块[符号=值]，常用选项： -C&lt;文件&gt;：不使用默认配置文件，使用指定文件作为配置文件 -i：忽略配置文件中的加载和卸载命令 -r：卸载指定模块，包括依赖模块 -f：强制安装 -l：显示所有匹配模块 -a：安装所有匹配的模块 –show-depends：显示模块的依赖关系 -v：显示执行过程 -q：不显示任何信息 -V：显示版本信息 modprob处理模块时忽略模块的路径，这要求系统模块和驱动是按照make modules_install方式安装的，即模块必须放在/lib/modules/$(uname -r)目录下，并且有正确的/lib/modules/$(uname -r)/modules.dep文件，modprobe根据该文件来寻找和解决依赖关系 如果系统不能自动创建设备节点，加载驱动后，则需要为驱动建立对应的设备节点，否则无法通过驱动来操作设备。mknod 设备名 设备类型 主设备号 次设备号 环境变量 Linux是一个多用户操作系统，每个用户都有自己专有的运行环境，用户所使用的环境由一系列变量所定义，这些变量被称为环境变量，系统环境变量一般都是大写 常见的环境变量： PATH：决定了Shell将到哪些目录中寻找命令或程序，这个变量是在日常使用中经常需要修改的变量 TERM：指定系统终端 SHELL：当前用户shell类型 HOME：当前用户主目录 LOGNAME：当前用户的登录名 USER：当前用户名 HISTSIZE：历史命令记录数 HOSTNAME：主机名 LANGUGE：语言相关的环境变量，多语言可以修改此环境变量 MAIL：当前用户的邮件存放目录 PS1：基本提示符，对于root用户是#，对于普通用户是$ PS2：附属提示符，默认是“&gt;” LS_COLORS:ls命令结果颜色显示 在shell下通过$符号来引用环境变量，使用echo可以查看某个具体环境变量的值 使用env或者printenv命令可以查看系统全部的环境变量设置 修改系统配置文件以达到修改环境变量的目的 修改/etc/profile文件会影响使用本机的全部用户 修改~/.bashrc则仅仅影响当前用户 Linux目录树标准与文件系统 文件层次标准（FHS）对Linux根文件系统的基本目录结构做了比较详细的规定 bin：基本命令的程序文件，里面不能再包含目录 boot：Bootloader静态文件 dev：设备文件 etc：系统配置文件，配置文件必须是静态文件，不能是二进制文件 home：存放各用户的个人数据 lib：基本的共享库和内核模块 media：可移动介质的挂载点 mnt：临时的文件系统挂载点 opt：附件的应用程序软件包 root：root用户目录 sbin：基本的系统命令二进制文件 srv：系统服务的一些数据 tmp：临时文件 usr /usr/bin:众多的应用程序 /usr/sbin:超级用户的一些管理程序 /usr/doc:linux文档 /usr/lib:常用的动态链接库和软件包的配置文件 /usr/man:帮助文档 /usr/src:源代码 /usr/local/bin:本地增加的命令 /usr/local/lib:本地增加的库 var：可变数据 Linux下所有文件的描述结构都是相同的，包含索引节点和数据 索引节点：又称I节点，是Linux文件系统用来记录文件信息的一种数据结构，信息包括文件名、文件长度、文件权限、存放位置、所属关系、创建和修改时间。文件系统维护了一个索引节点的数组，每个文件都与索引节点数组中的唯一元素对应，索引节点在数组中的索引号称为索引节点号。每个文件都有一个索引号与之对应，而一个索引节点号可以对应多个文件。 数据：文件的实际内容，可以是空的，也可以非常大，并且拥有自己的结构 Linux系统中，文件名以点号（.）开始的文件是隐藏文件，用ls命令不加-a将看不到这类文件 设备文件 设备是一种特殊的的文件，除了存放在文件I节点中的信息外，它们不包含任何数据，有效的设备文件与相应的设备对应，通过设备文件，可以操作与之对应的硬件设备 设备文件包括字符设备和块设备文件。字符设备按照字符操作设备，如键盘、中断等；块设备文件以块为单位操作设备，如磁盘、光盘等。Linux系统的设备文件都放在/dev目录下，用ls -la命令可以查看各设备的属性 Linux支持多种文件系统，且同时存在于一个一个运行的系统中，查看/proc/filesystems文件，可以看到系统支持的全部文件系统 proc文件系统 proc是Linux系统中的一种特殊的文件系统，是内核和内核模块用来向进程发送消息的机制，只存在于内存中，实际上是一个伪文件系统。用户和应用程序可通过/proc获得系统的信息，还可以改变内核的某些参数。 /proc/cpuinfo：CPU信息 /proc/meminfo：物理内存，交换空间信息 /proc/mounts：已加载的文件系统列表 /proc/devices：可用设备的列表 /proc/filesystems：被支持的文件系统 /proc/modules：已加载的模块 /proc/version：内核版本 /proc/cmdline：系统启动时输入的内核命令行参数 sysfs文件系统 sysfs是Linux2.6引入的新型文件系统是一个基于内存的文件系统，它的作用是将内核的信息以文件的方式提供给用户程序使用。该文件系统的目录层次结构严格按照内核的数据结构组织，除了二进制文件外，sysfs文件内容均以ASCII格式保存，且一个文件只保存一个数据，另外，一个文件不可大于一个内存页（通常为4096字节） sysfs提供一种机制，使得可以显式地描述内核对象，对象属性及对象间关系。sysfs有两组接口，一组针对内核，用于将设备映射到文件系统中，另一组针对用户程序，用于读取或操作这些设备 sysfs内部结构与外部表现 sysfs产生了一个包含所有系统硬件的层次视图，把连接在系统上的设备和总线组织成为一个分级的文件，向用户空间导出内核数据结构和以及它们的属性。sysfs清晰地展示了设备驱动模型中各组件的关系，顶层目录包括block、device、bus、drivers、class、power和firmware等。各目录和所包含的内容如下 sysfs目录结构 vi的使用 从命令模式进入编辑模式：插入（i或者I），附件（a或者A），打开（o或者O） 光标移动：命令模式下，h（左），j（下），k（上），l（右） 快速光标定位： 命令G：将光标定位到最后一行 命令nG：将光标定位到第n行 命令gg：将光标定位到第1行 命令ngg：将光标定位到第n行 命令:n将光标定位到第n行 文本块选定 将光标移动到将要选定的文本块开始处，按esc进入命令模式，再按v，进入可视状态，然后移动光标至文本块结尾，被选定的文本块高亮显示。连按两次esc可以取消所选定的文本块 复制和粘贴 如果已经选定文本块，按y即可将所选定文本复制到缓冲区，将光标移到将要粘贴的地方，按p，就可完成文本粘贴 在命令模式下，连按yy，即可复制光标所在的行的内容，连按yny即可复制从光标所在行开始的n行 剪切和删除 最后一次剪切和删除的内容都可以被粘贴到其他位置 x或nx：剪切从光标所在位置开始的一个或者n个字符 X或nX：剪切光标前的一个或n个字符 dd：删除光标所在行 D：删除光标位置开始至行尾 dw：删除从光标位置至该词末尾的所有字符 d0：删除从光标位置开始至行首 dnd：删除光标所在行开始的n行 dnG：将光标所在行至第n行删除 文本查找 在命令模式下，输入“/字符串”即可从光标位置开始向下查找字符串。输入“？字符串”则从光标位置开始向上查找字符串。无论向上还是向下查找，查找下一个，按键盘n键即可 全局匹配搜索：先将光标移动到字符串abc，然后按下“SHIFT+*”，完成搜索。 文本替换 在命令模式下，输入：%s /old/new/gc，能够将文本内全部的字符串old替换为new，为了安全起见，可以在替换命令尾部加上c，这样每次替换前都需要确认一下 撤销和回复 在命令模式下输入u，可以撤销所做的更改，回复编辑前的状态，这里的编辑以保存命令为界。不小心多按了u时可以用Ctrl+R来恢复 Vi的配置文件 在vi内执行的配置命令的效果是临时IDE，关闭vi，再次打开vi，需要重新配置。vi有自己的配置文件，可以是”/etc/vim/vimrc”或者”~/.vimrc”。两者的区别是前者是全局的，影响登陆本机的全部用户，后者仅仅对当前用户有效 文本对比 Vim提供了文本对比工具vimdiff 用法：vimdiff file1 file2 file3 vimdiff可以同时进行2个以上文件的对比 如何使全局环境变量生效 添加在/etc/profile中的全局变量生效的方法：. /etc/profile（点+空格+文件名）","tags":[{"name":"ARM","slug":"ARM","permalink":"https://suda-morris.github.io/tags/ARM/"}]},{"title":"Matlab Basic","date":"2015-11-11T14:45:49.000Z","path":"2015/11/11/matlab/","text":"几个常用命令 help：查看某个命令的帮助文档 version：获得当前Matlab的版本 pwd：给出当前的工作目录名 dir：ls或dir列出当前目录下的所有文件名清单 cd：改变目录 what：列出当前工作目录下所有的M文件、MAT文件和MEX文件 who：列出当前工作空间里的变量名 clock：时钟设置命令 data：日期设置命令 path：显示MATLAB的当前搜索路径 getenv：getenv（‘matlabpath’）显示当前的MATLAB路径 diary on，diary off：利用diary可以记录MATLAB窗口中进行的所有操作 ！（escape）：符号！是MATLAB的扩展运算符，通过该符号，用户有权使用DOS或UNIX命令 demo：该命令引导使用者通过菜单选择为数众多的演示程序 format：数据显示格式。系统默认的数据显示格式是5位 clear：清除工作空间中所有的变量 clear all：从工作空间中清除所有变量和函数 clf：清除图形窗口内容 delete&lt;文件名&gt;：从磁盘中删除指定文件 load name：载入‘name’文件中的所有变量到工作空间 load name x y：载入‘name’文件中的变量x，y到工作空间 save name：保存工作空间变量到文件name.mat中 save name x y：保存工作空间变量x y到文件name.mat中 pack：整理工作空间内存 size：显示当前工作空间中变量的尺寸 length：显示当前工作空间中变量的长度 disp：显示当前工作空间中的变量 运算符 反除运算符：\\:该运算符得到商的倒数，即a\\b等于b/a 不等于：~= 逻辑与：&amp; 逻辑或：| 逻辑非：~ 变量名 区分大小写 长度不能超过31位 变量名以字母开头，可以是字母、数字、下划线组成 分支结构 if-else-end语句中的else子句是可选项嵌套：if-elseif-elseif-…-else-end 循环结构 for-endwhile-end；该语句中的循环判断语句为矩阵时，当且仅当所有的矩阵元素非零时，逻辑表达式的值为真break；退出循环体，执行循环后的其他语句 数据输入与输出 input：通过键盘输入数据 fprintf：输出格式化信息和数字 disp：可以在命令窗口输出数字、向量、矩阵或字符串，无需变量名 sprintf：将输出写入字符串 数组 MATLAB中，行数组与行向量是同义语，列数组和列向量是同义语 对于加法和减法，数组运算与线性代数中的向量运算相同。但是符号.*和./分别被称为数组乘法运算符和数组除法运算符，它们不同于矩阵和向量乘除法。 计算数组长度：length（x） 删除数组元素：z（3）=[] MATLAB里，二维数组变量等同于一个矩阵，每一行的元素以分号结束 二维数组的整行或整列可以用一个冒号表示。例如：m(1,:)和m(:,3)分别表示m的第一列和第三列 只有长度相同的向量才能在if语句中进行比较，如果将两个长度不同的向量进行比较，命令窗口会出现出错信息提示。在if语句中比较字符串之前一定要通过增加空格使字符串长度完全相同 MATLAB特有的数字特性 在MATLAB里，所有的变量均为双精度，整数变量和实数变量之间没有区别，实数变量和复数变量同样也没有区别 初等数学函数 sin(x) cos(x) tan(x) asin(x) acos(x) atan(x):[-π/2,π/2] atan2(y,x):与atan(y/x)结果相同，但是-π/2≥atan2(y,x)≥π sinh(x) cosh(x) tanh(x) asinh(x) acosh(x) atanh(x) abs(x):x的绝对值 angle(x):复数x的相位角 sqrt(x):x的平方根 real(x) imag(x) conj(x):复数x的共轭数 round(x):向最近整数取整 fix(x):向0取整 floor(x):向-∞取整 ceil(x):向+∞取整 sign(x):如果x&gt;0,则为+1；如果x&lt;0,则为-1 mod(x,y)：除后余数：x-y*fix(x/y) rem(x,y):除后余数：x-y*fix(x/y).如果y≤0，则与mod不同 exp(x):以e为底的指数 log(x):以e为底的对数 log10(x):以10为底的对数 factor(x):将x分解质因数 isprime(x):如果x为素数，值为1，否则为0 factorial(x):x! 功能函数 sort(x):将x按照升序重新排列,如果x是矩阵，则重新排列按列进行 sum(x):如果是x是矩阵，返回值由矩阵各列元素和组成的一个行向量 max(x),min(x):如果x是矩阵，函数值为一个行向量，每个元素为矩阵相应列的最大或最小值 rand(n),返回一个nxn的矩阵，元素全是随机数。除非特别规定，否则所生成的是0~1之间均匀分布的随机数 eval：该命令可以作为字符串被编辑，然后用eval执行。字符串可以通过input读取，或在程序中创建 M文件 M文件可以分为脚本文件和函数文件两种 脚本文件操作对象为MATLAB工作空间内的变量，并且在脚本执行结束后，脚本中对变量的一切操作均会被保留。在MATLAB语言中也可以在脚本内部定义变量，并且该变量将会自动地被加入到当前的MATLAB工作空间中，并可以为其他的脚本或函数引用，直到MATLAB被关闭或采用一定的命令将其删除 MATLAB语言的函数文件包含5个部分： 函数题头：指函数的定义行，是函数语句的第一行，在该行中将定义函数名，输入变量列表以及输出变量列表等 HI行：指函数帮助文档的第一行 帮助信息 函数体 注释部分：注释语句是以%引导的 echo on,echo off:M文件执行过程中，其命令语句通常不出现在屏幕上，但是当echo on命令将echo开启后，屏幕上会显示所有语句。这时，用户可以看到正在执行的那部分M文件。 开发函数M文件最基本且很有效的一个办法是将第一行的函数语句用%注释掉，然后作为一个命令M文件进行测试。测试通过后，再将函数语句恢复 保存和载入数据 save，load：如果直接使用save，则所有当前变量将被保存到默认文件matlab.mat里。load是与save相反的命令，它取回所有被save保存的变量。 save file_name data-ascii：save能以ASCII码格式保存数据。带有ASCII选项的save和load非常重要，因为他们可以从MATLAB导入和导出数据 自动创建文件名：在一个M文件中，常常需要自动创建一些文件名。如果整条命令连同文件名写为一个字符串，则可通过eval执行。 硬拷贝 使用diary命令制作一个屏幕内容的拷贝，如果其后不加任何文件名，屏幕内容将存入名为diary的文件中，此文件可以用文本方式打开。但是在diary文件里无法得到图形 Matlab中的默认常量 pi：圆周率 inf：无穷大 nan：不定值，即0/0 realmax：最大正实数 realmin：最小正实数 eps：浮点数的相对误差 i：虚数单位 nargin：函数实际输入参数个数 nargout：函数实际输出参数个数 ans：默认变量名 常用矩阵函数运算 rot90（）：矩阵逆时针旋转90° flipud（）：矩阵上下翻转 fliplr（）：矩阵左右翻转 flipdim（）：矩阵的某维元素翻转 shiftdim（）：矩阵的元素移位 eig（）：计算矩阵的特征值和特征向量 rank（）：计算矩阵的秩 trace（）：计算矩阵的迹 norm（）：计算矩阵的范数 poly（）：计算矩阵的特征方程的根 svd（）：矩阵的奇异值分解 qr（）：矩阵的QR分解 chol（）：矩阵的Cholesky分解 schur（）：矩阵的Schur分解 lu（）：矩阵的LU分解 符号运算 syms 符号变量名1 符号变量名2 … 符号变量名n 用这种格式定义符号变量时不要在变量名上加字符串分界符，变量间用空格而不用逗号分隔 含有符号对象的表达式称为符号表达式，建立符号表达式有以下3中方法： 利用单引号来生成符号表达式 用sym函数建立符号表达式 使用已经定义的符号变量组成符号表达式 符号表达式创建实例 Matlab中，数值矩阵不能直接参与符号运算，必须先转化为符号矩阵 将数值矩阵转化为符号矩阵：sym（数值矩阵） 将符号矩阵转化为数值矩阵：numeric（A） 关于符号矩阵的函数 transpose（S）：返回S矩阵的转置矩阵 determ（S）：返回S矩阵的行列式值 许多数值矩阵的函数，如diag，triu，tril，inv，det，rank，eig等也可直接应用于符号矩阵 符号表达式的四则运算 factor（S）：对S分解因式，S是符号表达式或符号矩阵 expand（S）：对S进行展开，S是符号表达式或符号矩阵 collect（S，v）：对S按变量v合并同类项，S是符号表达式或符号矩阵 simplify（S）：应用函数规则对S进行简化 simple（S）：调用MATLAB的其他函数对表达式进行综合化简，并显示化简过程 常用的符号运算 limit，求极限的符号函数，常用的格式：limit（F，x，a，‘right’）或limit（F，x，a，‘left’）。当自变量x从右侧或左侧逼近a时，函数F的极值 diff，求微分用的符号函数，常用格式：diff（f，x，n），表示f关于x求n阶导数 int，求积分用的符号函数，常用格式：int（f，r，x0，x1），f为所要积分的表达式，r为积分变量，若为定积分，则x0与x1为积分上下限 symsum，级数求和的符号函数，常用的格式：S=symsum（fk，k，k0，kn），其中fk为级数的通项，k为级数自变量，k0和kn为级数求和的起始项和终止项，且可设为inf dsolve，求解常微分方程的符号函数，常用格式：dsolve（’eqnl’,’condition’,’var’）;该函数求解微分方程eqnl在初始条件condition下的特解。参数var描述方程中的自变量符号，省略时按默认原则处理，若没有给出初值条件condition，则求方程的通解 极限和极值的符号运算实例 微积分的符号运算实例 常微分方程符号运算实例 图形绘制 ploy,绘制二维图形，常用格式：plot(x1,y,option1,x2,y2,option2,…) plot3,绘制三维图形，常用格式：plot3(x1,y1,z1,option1,x2,y2,z2,option2,…) mesh,绘制三维曲面，常用格式：mesh(X,Y,Z,C),参数X,Y,Z都为矩阵值，C表示网格曲面的颜色分布。mesh(x,y,Z,C),参数x，y为长度分别是n和m的向量值，而参数Z是维数为mxn的矩阵 surf，绘制三维阴影曲面，常用格式：surf(X,Y,Z,C),surf(x,y,Z,C) 三维网格曲面图绘制应用实例 绘图命令使用实例 MATLAB程序 MATLAB程序基本组成结构","tags":[{"name":"Matlab","slug":"Matlab","permalink":"https://suda-morris.github.io/tags/Matlab/"}]},{"title":"StarUML Install","date":"2015-11-10T07:44:29.000Z","path":"2015/11/10/star-uml/","text":"StarUML 软件破解 官网地址 该软件为跨平台的UML建模工具，采用NodeJs编写 破解：安装目录/www/license/node/LicenseManagerDomain.js文件修改为如下： LicenseManagerDomain.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283(function () &#123; \"use strict\"; var NodeRSA = require('node-rsa'); function validate(PK, name, product, licenseKey) &#123; var pk, decrypted; return &#123; name: \"morris\", product: \"StarUML\", licenseType: \"vip\", quantity: \"suda_morris.github.io\", licenseKey: \"later equals never!\" &#125;; try &#123; pk = new NodeRSA(PK); decrypted = pk.decrypt(licenseKey, 'utf8'); &#125; catch (err) &#123; return false; &#125; var terms = decrypted.trim().split(\"\\n\"); if (terms[0] === name &amp;&amp; terms[1] === product) &#123; return &#123; name: name, product: product, licenseType: terms[2], quantity: terms[3], licenseKey: licenseKey &#125;; &#125; else &#123; return false; &#125; &#125; /** * Initializes the domain with several commands. * @param &#123;DomainManager&#125; domainManager The DomainManager for the server */ function init(domainManager) &#123; if (!domainManager.hasDomain(\"LicenseManager\")) &#123; domainManager.registerDomain(\"LicenseManager\", &#123;major: 0, minor: 1&#125;); &#125; domainManager.registerCommand( \"LicenseManager\", // domain name \"validate\", // command name validate, // command handler function false, // this command is synchronous in Node (\"false\" means synchronous\") \"Validate License\", [ &#123; name: \"PK\", type: \"string\", description: \"PK\" &#125;, &#123; name: \"name\", type: \"string\", description: \"name of license owner\" &#125;, &#123; name: \"product\", type: \"string\", description: \"product name\" &#125;, &#123; name: \"licenseKey\", type: \"string\", description: \"license key\" &#125; ], [ &#123; name: \"result\", // return values type: \"object\", description: \"result\" &#125; ] ); &#125; exports.init = init;&#125;()); 打开软件，，help-&gt;Enter License,随便输入用户名密码即可破解成功","tags":[{"name":"StarUML","slug":"StarUML","permalink":"https://suda-morris.github.io/tags/StarUML/"}]},{"title":"SD Card Driver","date":"2015-10-30T08:58:07.000Z","path":"2015/10/30/sd-card/","text":"Micro SD卡简介 SD卡 Micro SD卡的控制指令功能强大，支持SPI、SDIO模式，兼容MMC。在SPI模式下，CS/MOSI/MISO/CLK都需要加10~100K左右的上拉电阻 SD卡有5个寄存器 CID：128比特，卡标识寄存器,只读 RCA：16比特，相对卡地址寄存器，即本地系统中卡的地址，动态变化，在主机初始化的时候确定。SPI模式中没有此寄存器 CSD：128比特，卡描述数据，主要存储了卡的容量、数据格式、DSR寄存器是否可用、数据传输相关参数、数据传输速度、最大的数据访问时间、最大的读写数据块长度等，是可配置寄存器 SCR：64比特，SD配置寄存器，即SD卡特定信息数据如：SCR版本号、SD卡版本号、是否支持安全性、擦除后卡状态默认值、SD总线宽度等，由生产商在卡生产阶段写入 OCR：32比特，操作条件寄存器,提供SD Host查询SD卡支持的电压范围，是否是大容量卡OCR[30],卡省电过程是否结束OCR[31] 每发送一个命令，SD卡都会给出一个应答，以告知主机该命令的执行情况，或者返回主机需要获取的数据。SPI模式下，SD卡针对不同的命令，应答可以是R1~R7。命令与响应都是MSB优先。除了SEND_STATUS和READ_OCR指令外，其他指令的响应格式都是R1，格式R1的长度是1Byte，并且最高位总是0，其余每位均是错误提示，在指令接收过程中发生了什么样的错误，对应的错误位就会是‘1’。R1b和R1具有相同的格式，它将伴随一个附加的busy信号，busy信号的长度可以是任意个字节，全0表示卡处在“忙”的状态。格式R2的长度为2字节，它是指令SEND_STATUS的响应，它的高字节和R1相同，低字节同样作为状态提示。格式R3的长度是5字节，它是指令READ_OCR的响应，最高字节和R1相同，其余4字节包含SD卡的OCR寄存器信息 在SD卡收到复位命令（CMD0）时，CS为低电平则SD卡的SPI模式被启用。不过在发送CMD0之前，要发送&gt;74个时钟这是因为SD卡内部有一个供电电压上升时间，大概为64个CLK，剩下的10个CLK用于SD卡同步，之后才能开始CMD0的操作。在卡初始化的时候，CLK时钟最大不能超过400KHz 对SD卡的常用基本操作主要由：单块读、连续读、单块写、连续写。SPI模式下，通过向SD卡发送响应的命令并读取相应的响应来实现对SD卡的控制。 SD 命令 命令:每个命令都有一个起始位和结束位，总长度为48 bits，并且每个命令都有 7 bits 的CRC 校验码，高字节优先传输 SD Command Command 共分为12类（class0 - class11），在寄存器CSD中有12 bits CCC（Card Command Class）对本卡支持的分类进行描述 SD命令 几个重要的命令 常用命令 CMD8命令格式 CMD8 SD 应答 R1响应格式 R1响应格式 SD卡初始化 SD卡初始化流程 配置时钟，慢速一般为400Hz，设置工作模式 发送CMD0，对卡进行软复位，进入空闲态，该指令没有反馈 发送CMD8命令用于读取卡的接口信息，如果是SD2.0，则支持CMD8命令；如果是SD1.x，MMC，则不支持CMD8 发送CMD55+ACMD41，判断当前电压是否在卡的工作范围内，看卡能否识别命令，如果是MMC卡，则CMD55不能被识别，短反馈 发送CMD2，验证SD卡是否接入，长反馈 发送CMD3，读取SD卡的RCA地址，短反馈 以RCA作为参数，发送CMD9读取CSD，长反馈 发送CMD7，选中要操作的SD卡，短反馈 配置告诉时钟，准备数据传输，一般为20~25MHz 设置工作模式：DMA、中断或者查询模式 SD卡读取数据流程 发送CMD17 接收卡响应R1 接收数据起始令牌0xFE 接收数据 接收2字节的CRC，如果不使用CRC，这两个字节在读取后可以丢掉 禁止片选之后，发多8个CLK SD卡写数据流程 发送CMD24 接收卡响应R1 发送写数据起始令牌0xFE 发送数据 发送2字节的伪CRC 禁止片选之后，发多8个CLK SD卡读数据块操作 在读数据块模式下，数据传输的基本单元是数据块，它的大小在CSD中（READ_BL_LEN）定义 为了保证数据传输的正确，每个数据块后都有一个CRC校验码。 CMD17（Read_Single_Block）启动一次读数据块操作，在传输结束后返回返回到发送状态。 CMD18（Read_Multiple_Block）启动一次连续多个数据块的读操作 主机可以在多数据块读操作的任何时候终止操作，而不管操作的类型。发送停止传输命令即可终止操作 如果在多数据块读操作中，卡检测到错误（如越界，地址错位或内部错误），它将停止数据传输并仍处于数据状态；此时主机必须发送停止传输命令，终止操作 FATFS简介 FATFS是一个完全免费开源的FAT文件系统模块，专门为小型的嵌入式系统而设计。支持FAT12、FAT16和FAT32，支持多个存储媒介；有独立的缓冲区，可以对多个文件进行读/写。 拥有多种配置选项： 支持多卷（物理驱动器或分区，最多10个卷） 多个ANSI/OEM代码页包括DBCS 支持长文件名、ANSI/OEM或Unicode 支持RTOS 支持多种扇区大小 只读、最小化的API和I/O缓冲区等 需要我们编写移植代码的是FATFS模块提供的底层接口，包括存储媒介读/写接口(disk I/O)和供给文件创建修改时间的实时时钟 ffconf.h:FATFS模块配置文件 ff.h:FATFS和应用模块共用的包含文件 ff.c:FATFS模块 diskio.h:FATFS和disk I/O模块共用的包含文件 interger.h:数据类型定义 option：可选的外部功能(比如支持中文等) diskio.c:FATFS和disk I/O模块接口层文件 ffconf.h _CODE_PAGE,根据具体使用的而语言在ffconf.h中定义具体的宏定义。如果使用简体中文，则选择936；如果使用英文，则选择437；如果使用日文，则选择932。打开option文件夹，打开cc936.c文件，里面有一个很大的数组static const WCHAR uni2oem[]。这个数组用于unicode码和OEM码之间的相互转换。接下来又有两个函数，ff_convert()和ff_wtoupper()具体执行码型转换和将字符串转换为大写。unicode是一种双字节字符编码，无论中文还是英文，或者其他语言统一到2字节。与现有的任何编码都不兼容。WindowsNT的内核即使用该编码，所有数据进入内核前转换成UNICODE，退出内核后再转换成版本相关的编码(通常称为OEM，在简体中文下即为GB) _FS_TINY，使用浓缩版的FATFS就设置为1 _FS_READONLY,这个用来配置是不是只读 _USE_STRFUNC,这个用来设置是否支持字符串类操作，比如f_putc,f_puts等 _USE_MKFS,这个用来设置是否使能格式化 _USE_FASTSEEK，这个用来使能快速定位 _USE_LABEL,这个用来设置是否支持磁盘盘符（磁盘名字）读取与设置 _USE_LFN,该选项用于设置是否支持长文件名，还需要_CODE_PAGE支持，取值范围为0~3。0表示不支持长文件名，1~3是支持长文件名，但是存储地方不一样 _VOLUMES,用于设置FATFS支持的逻辑设备数目 _MAX_SS,扇区缓冲的最大值，一般设置为512 ff.h中的函数定义 FRESULT f_mount (FATFS fs, const TCHAR path, BYTE opt);加载文件系统 fs表示文件系统对象，path表示本地设备驱动号，opt=1表示立即挂载，0表示延迟挂载 FRESULT f_lseek (FIL* fp, DWORD ofs);移动文件的读写指针 ofs表示文件偏移量的数目 FRESULT f_close (FIL* fp);关闭打开的文件对象 FRESULT f_opendir (DIR dp, const TCHAR path);打开目录，返回目录对象 FRESULT f_readdir (DIR dp, FILINFO fno);读取目录获得文件信息 FRESULT f_stat (const TCHAR path, FILINFO fno);读取文件的状态 FRESULT f_getfree (const TCHAR path, DWORD nclst, FATFS** fatfs);获取驱动器上的空闲簇数 FRESULT f_truncate (FIL* fp);截断文件 FRESULT f_sync (FIL* fp);刷新写文件的缓冲数据 FRESULT f_unlink (const TCHAR* path);删除目录中的一个文件 FRESULT f_mkdir (const TCHAR* path);创建一个新目录 FRESULT f_chmod (const TCHAR* path, BYTE attr, BYTE mask);更改文件/目录的属性 FRESULT f_utime (const TCHAR path, const FILINFO fno);更改文件/目录的时间戳 FRESULT f_rename (const TCHAR path_old, const TCHAR path_new);重命名/移动文件或目录 FRESULT f_forward (FIL fp, UINT(func)(const BYTE,UINT), UINT btf, UINT bf);转发数据流 FRESULT f_mkfs (const TCHAR* path, BYTE sfd, UINT au);在驱动器上创建一个文件系统 FRESULT f_chdir (const TCHAR* path);改变当前目录 FRESULT f_chdrive (const TCHAR* path);更改当前驱动器 int f_putc (TCHAR c, FIL* fp); int f_puts (const TCHAR str, FIL cp); int f_printf (FIL fp, const TCHAR str, …); TCHAR f_gets (TCHAR buff, int len, FIL* fp); diskio.c(需要用户提供如下几个函数接口) DSTATUS disk_initialize (BYTE pdrv);初始化磁盘驱动器 DSTATUS disk_status (BYTE pdrv);获取磁盘状态 DRESULT disk_read (BYTE pdrv, BYTE* buff, DWORD sector, UINT count);读扇区 DRESULT disk_write (BYTE pdrv, const BYTE* buff, DWORD sector, UINT count);写扇区 DRESULT disk_ioctl (BYTE pdrv, BYTE cmd, void* buff);设备相关的控制特性 get_fattime获取当前时间 簇：文件数据分配的基本单位 FAT文件系统依次应该为:引导扇区、文件分配表两个、根目录区和数据区 汉字字库 常用的汉字内码系统有GB2312，GB13000，GBK，BIG5（繁体）等几种，其中GB2312支持的汉字仅有几千个，很多时候不够用，而GBK内码不仅完全兼容GB2312，还支持繁体字，总汉字数量达到2万多个。 每个GBK码由2字节组成，第一个字节为0X81~0xFE，第二个字节分为两部分，一是0x40~0x7E，二是0x80~0xFE。第一个字节代表的意义称为区，GBK里面总共有126个区，每个区内有190个汉字。","tags":[{"name":"SD","slug":"SD","permalink":"https://suda-morris.github.io/tags/SD/"}]},{"title":"GPS Introduction","date":"2015-10-16T01:06:12.000Z","path":"2015/10/16/gps/","text":"NEO-M8N模块 内嵌USB转串口功能 三维位置定位 测速 授时 MAXIM公司20.5dB高增益LNA芯片 应用场合： 语音报站 航模，飞控，无人机 同步授时 汽车导航 接收制式： GPS GLONASS Galileo BeiDou QZSS SBAS 72路接收通道 水平定位精度：2米（空旷地） 输出频率1Hz~10Hz 速度精度：0.1m/s 加速度精度：0.1m/s2 最大高度18000米，最大速度515m/s 最大加速度4g 基于UBX协议进行模块的配置 IIC接口的SDA与SCL已经内部接了上拉电阻 XH414法拉电容 参数:3.3V 0.07F 功能和锂电池一样，在主电源掉电的时候可以为GPS模块的RTC部分供电，以使GPS模块在下次启动时能快速搜索到卫星，一般可维持供电1小时 NMEA-0183协议 NMEA是美国国家海洋电子协会为海用电子设备指定的标准格式，目前已经成为了GPS导航设备统一的RTCM标准协议 NMEA-0183是一套定义接收机输出的标准信息，有几种不同的二格式，每种都是独立相关的ASCII，使用逗号隔开数据，数据流长度30-100字符不等，通常以每秒间隔选择输出，最常用的格式为“GGA”，它包含了定位时间，纬度，经度，高度，定位所用的卫星数，DOP值，差分状态和校正时段，其他的有速度，跟踪，日期等。 NMEA-0183常用语句格式说明： $GPGGA:全球定位数据，最大帧长72 $GPGSA：卫星PRN数据，最大帧长65 $GPGSV：卫星状态信息，最大帧长210 $GPRMC：推荐最小数据，最大帧长70 $GPVTG：地面速度信息，最大帧长34 $GPGLL：大地坐标信息 $GPZDA：UTC时间和日期 协议帧总说明：该协议采用ASCII码。帧格式形如：$aacc,dd,dd,…,ddd*hh $表示帧命令起始位 aaccc表示地址域，前两位是标识符，后三位为语句名 ddd…ddd表示数据 *表示校验和前缀 hh表示校验和，$与*之间所有字符ASCII码的校验和(各字节做异或运算，得到校验和后，再转换16进制格式的ASCII字符) 表示回车和换行 GPGGA：GPS固定数据输出语句 格式：$GPGGA,,,,,,,,,,,,,,* 例子：$GPGGA,092725.00,4717.11399,N,00833.91590,E,1,8,1.01,499.6,M,48.0,M,,0*5B UTC时间，格式为hhmmss.sss 纬度，格式ddmm.mmmm 纬度半球，N或者S 经度，格式ddmm.mmmm 经度半球，E或W 定位质量指标，0=定位无效，1=标准定位，2=差分定位，6=估算 使用卫星数量，从00到12 水平精确度，0.5到99.9 天线离海平面的高度，-9999.9到9999.9米 高度单位，M表示单位米 大地椭球面相对海平面的高度 高度单位，M表示单位米 差分GPS数据期限（RTCM SC-104），最后设立RTCM传送的秒数量 差分参考基站标号，从0000到1023 校验和 GPGSA：GPS精度指针及使用卫星 格式：$GPGSA,,,,,,,,,,,,,,,,,* 例子：$GPGSA,A,3,23,29,07,08,09,18,26,28,,,,,1.94,1.18,1.54*0D 模式2：M=手动，A=自动 模式1：定位型式1=未定位，2=二维定位，3=三维定位 第1信道正在使用的卫星PRN码编号(Pseudo Random Noise，伪随机噪声吗)，01至32 第2信道正在使用的卫星PRN码编号 第3信道正在使用的卫星PRN码编号 第4信道正在使用的卫星PRN码编号 第5信道正在使用的卫星PRN码编号 第6信道正在使用的卫星PRN码编号 第7信道正在使用的卫星PRN码编号 第8信道正在使用的卫星PRN码编号 第9信道正在使用的卫星PRN码编号 第10信道正在使用的卫星PRN码编号 第11信道正在使用的卫星PRN码编号 第12信道正在使用的卫星PRN码编号 PDOP综合位置精度因子（0.5 - 99.9） HDOP水平精度因子（0.5 - 99.9） VDOP垂直精度因子（0.5 - 99.9） 校验和 GPGSV：可视卫星状态输出语句 格式：：$GPGSV, ,,,,,,,…,,,,* 例子：$GPGSV,3,1,10,23,38,230,44,29,71,156,47,07,29,116,41,08,09,081,36*7F 总的GSV语句电文数 当前GSV语句号 可视卫星总数，00至12 卫星编号，01至32 卫星仰角，00至90度 卫星方位角，000至359度。实际值 信噪比（C/No），00至99dB；无表示未接收到讯号 校验和。 每条语句最多包括四颗卫星的信息，每颗卫星的信息有四个数据项，即：卫星编号，卫星仰角，卫星方位角，信噪比 GPRMC：推荐最小数据量的GPS信息 格式：$GPRMC,,,,,,,,,,,,* 例子：$GPRMC,083559.00,A,4717.11437,N,00833.91522,E,0.004,77.52,091202,,,A*57 UTC（Coordinated Universal Time）时间，hhmmss（时分秒）格式 定位状态，A=有效定位，V=无效定位 Latitude，纬度ddmm.mmmm（度分）格式（前导位数不足则补0） 纬度半球N（北半球）或S（南半球） Longitude，经度dddmm.mmmm（度分）格式（前导位数不足则补0 经度半球E（东经）或W（西经） 地面速率（000.0~999.9节，Knot，前导位数不足则补0） 地面航向（000.0~359.9度，以真北为参考基准，前导位数不足则补0） UTC日期，ddmmyy（日月年）格式 Magnetic Variation，磁偏角（000.0~180.0度，前导位数不足则补0） Declination，磁偏角方向，E（东）或W（西） Mode Indicator，模式指示（仅NMEA0183 3.00版本输出，A=自主定位，D=差分，E=估算，N=数据无效） 校验和。 GPVTG：地面速度信息 格式：$GPVTG,,,,,,,,,* 例子：$GPVTG,77.52,T,,M,0.004,N,0.008,K,A*06 以真北为参考基准的地面航向 T，表示“真” 以磁北为参考基准的地面航向 M，表示“磁场” 地面速率 N，表示“节” 地面速率 K，表示“千米/小时” 模式指示（A=自主定位，D=差分，E=估算，N=数据无效） 校验和 GPGLL：定位地理信息 格式：$GPGLL,,,,,,,* 例子：$GPGLL,4717.11364,N,00833.91565,E,092321.00,A,A*60 纬度 ddmm.mmmmm（度分） 纬度半球 N（北半球）或 S（南半球） 经度 dddmm.mmmmm（度分） 经度半球 E（东经）或 W（西经） UTC 时间：hhmmss（时分秒） 定位状态，A=有效定位，V=无效定位 模式指示（A=自主定位，D=差分，E=估算，N=数据无效） 校验和 GPZDA：当前时间信息 格式：$GPZDA,,,,,,* 例子：$GPZDA,082710.00,16,09,2002,00,00*64 UTC 时间：hhmmss（时分秒，格林威治时间） 日 月 年 本地区域小时（NEO-6M 不支持，为 00） 本地区域分钟（NEO-6M不支持，为 00） 校验和","tags":[{"name":"GPS","slug":"GPS","permalink":"https://suda-morris.github.io/tags/GPS/"}]},{"title":"Micro Fabrication","date":"2015-10-11T08:59:00.000Z","path":"2015/10/11/micro-fabrication/","text":"信息时代 微电子产业是信息时代的基础 基于硅的晶体管是最基本的信息载体 以硅/半导体为基础的微纳加工技术是信息时代的材料技术基础 IC制造高度专业化 设计-&gt;制造-&gt;测试-&gt;封装 芯片制造工艺 芯片制造工艺是指由“硅片”到“集成电路结构晶圆”之间的工艺步骤 二氧化硅在半导体制造中的作用以原因 作用 层间隔离 器件隔离 屏蔽层 原因 电阻率高，大于10MΩ·cm 击穿场强大，大于10MV/cm 禁带宽度较宽，越9eV 微纳加工技术的使用场合 集成电路领域 MEMS传感器（如用在投影机里面的DLP芯片) 医疗微电子（如使用带摄像头的胶囊来看人体内的情况，通过一个微系统控制药释放的速度） 平板显示行业 太阳能电池行业 微纳加工技术的特点 资本密集。超净间和设备需要大量资金投入 分批工艺。单个晶元上有上亿的晶体管 杰出的可生产性。良率控制在95%以上,可靠性强（寿命要求不小于10年） 随着产品更新换代，成本更加低 技术渗透性强。集成电路，MEMS，太阳能电池，平板显示器，医疗微电子等领域都离不开微纳加工技术 微纳加工技术中选择Si作为常用材料的原因 Si是人类能做的最纯净、没有缺陷、最完美的材料 Si资源丰富，是地壳中第二大丰富的化学元素 Si形成的SiO2界面性好，Si材料提供了可控、稳定且可重复生产的表面SiO2钝化层，从而使现代集成电路技术真正可以实现 在众多半导体中，Si是唯一能够通过氧化形成稳定绝缘层的材料 集成电路发展历程 历史上第一个晶体管(点接触)是1947年在美国贝尔实验室研制出来；1956年获得了诺贝尔奖，发明人是：威廉·肖克利，约翰·巴丁和沃尔特·布拉顿 1949年第一个面结型晶体管诞生 1958年第一个集成电路只有一个晶体管加3个电阻和1个电容,基片用的材质是锗；获得了2000年的诺贝尔奖；器件之间的连线就是简单的用焊接实现的 1959第一个硅基集成电路实现，也只有4个晶体管加2个电阻 1960年平面工艺技术诞生,塑造了现代IC制造的基本特征 1960年MOSFET诞生，从此MOSFET成为成为构建集成电路的主要器件。相对于BJT，MOS具有更高的集成密度，更低的功耗以及更好的电路设计灵活性 平面工艺 定义：在Si半导体上通过氧化、光刻、扩散、离子注入等一系列流程，制作出晶体管和集成电路的工艺；器件和电路都是在芯片表面一层附近处，整个芯片基本上保持是平坦的 特征：批量生产，成本低廉 摩尔定律 当价格不变时，集成电路上晶体管的数目，约每隔18~24个月便会增加一倍，性能也将提升一倍 摩尔定律是一个经济学定律 在摩尔定律下，新一代产品的的体积缩小30%(实现相同功能的前提下)，晶体管密度增加一倍，开关管开关速度增加0.5倍，功耗降低，成本降低，功能增加 More than Moore’s Law(MtM):更加注重系统集成而不是增加晶体管数量 SoC(System on Chip)片上系统;SiP(System in Package)系统级封装 特征尺寸每两年缩小0.7倍，0.7≈1/根号二 微电子工艺综述 微纳加工工艺技术分类： 光刻：在硅片上图上光刻胶，然后通过曝光显影的办法把集成电路版图投影到硅片上的光刻胶上 刻蚀:除去裸露部分的硅或者介质材料，从而把光刻胶上的图形转移到硅片上，具体工艺手段分为： 湿法腐蚀 干法刻蚀 掺杂：分为离子注入和热扩散 热处理：包括热氧化来制备介质膜，杂质的热扩散，离子注入后的热退火以及硅化物形成过程中的热处理 介质膜的沉积：微电子器件和集成电路中需要大量的各种介质层和隔离结构，制作方法是化学气相沉积(CVD) 化学机械抛光（CMP）：这是一种平坦化的技术，在现代集成电路的布线中，也用它来做图形加工，就是所谓的大马士革工艺 金属化：形成器件的引出电极以及电路的互连线，实现手段主要是：溅射和电镀 加工步骤： 加工步骤 通过氧化，在晶元上长一层很厚的氧化层（场氧化层），这个氧化就是得到二氧化硅材料 旋转涂胶的方法涂上一层光刻胶，光刻胶是一种有机物，起到图形转移的作用 曝光，激光通过掩膜版，将图形照到了光刻胶上 显影，将已经曝光的光刻胶移除 刻蚀，将没有光刻胶保护的二氧化硅的部分移出 将光刻胶移出 再一次进行氧化，生长出高质量的栅极介质氧化层，也是二氧化硅 沉淀一层多晶硅材料 图形化方式将栅极图形转移到删介质层的二氧化硅上面 通过离子注入的方式将掺杂给加入进去 沉积氮化硅 包含了接触口的图形化 在集成电路工艺制备过程中，就是加材料，图形化，减材料的过程不断循环，在每一循环中，后一次的图形需要和前一次的图形对准 超净间简介 为了保证零缺陷需要：避免引入颗粒，避免金属离子；颗粒引起成品率和可靠性问题，金属离子沾污会引起电性能和可靠性问题 超净间的净化级别：典型的IC Fab为光刻10级（每立方英尺中直径超过0.5um的颗粒不大于10个），其它工艺操作区为100级，“灰区”为1000级或者10000级 0.1~0.3um的颗粒最棘手：更大的颗粒容易沉淀，更小的颗粒容易凝结到更大的颗粒中 人员是一个重要的污染源，所以应当尽量采用SMIF(Standard Mechanical interface)和自动传输系统 SMIF是一个具有标准接口的盒子，可以与各个工艺设备来对接 人员需要穿戴特制的超净服，经过封磷才能进入超净间 超纯水：IC制造中用的超纯水电阻率必须超过18MΩ·cm，制备过程包括多级数值过滤以及反渗透离子过滤；超纯水的输运需要通过特殊的聚四氟管道进行 标准的硅片的清洗流程叫做RCA清洗 浓硫酸+双氧水去除有机物，H2SO4碳化有机物，H2O2使C氧化成CO2 氢氟酸去除二氧化硅 氨水+双氧水去除可能的重金属离子沾污 盐酸去除碱金属离子沾污 超纯水漂洗 超净间净化级别（最新的级别定义规范是Fed.Std.209E） 英制： CLASS（X）：单位立方英尺中的空气中，直径超过0.5um的颗粒不超过X个，1英尺=12英寸=30.48厘米 公制： M(X):单位立方米的空气中，直径超过0.5um的颗粒不超过10^M个 超净间的“无尘”的原因： 层层筛选滤除空气中的颗粒物，大颗粒使用超细纤维过滤，小颗粒使用静电吸附 空气流动采用层流的方式 设备使用无尘的材料制造 晶元在迷你工作台之间转移使用SMIF 超净间温度要求：20~22℃，湿度要求：40~46%RH 超净间着装要求： 佩戴帽子，护目镜，面罩，手套，超净服和靴子 超净服由合成纤维制作，里面有一层是聚四氟乙烯材料。超净服是导电的，因此不会积累电荷产生静电发电或者吸附颗粒 集成电路工艺用到的材料 单晶材料：结构晶体内部的微粒在三维空间呈有规律地，周期性的排列。整个晶体中质点在空间的排列短程有序，而且长程有序。单晶整个晶格是连续的 多晶材料：多晶是众多取向晶体的单晶的集合，短程有序，长程无序 非晶材料：短程长程均无序 单晶硅的特性及生长方法 熔融的单质硅在凝固时，硅原子以金刚石晶格结构，排列成许多晶核，如果这些晶核长成晶面取向相同的晶粒，则这些晶粒平行结合起来便结晶成单晶硅。单晶硅具有准金属的物理特性，有较弱的导电性，其电导率随温度升高而增加 单晶硅英文：Monocrystallinesilicon/Single Crystal Silicon 制备单晶硅的原材料是高纯度的多晶硅材料 多晶硅原料的制备： 从石英砂中提炼冶金级硅（纯度98%） 用冶金级的硅粉提炼电子级的硅（纯度9~11个“9”） 单晶硅的生长： 直拉法（CZ）（生长单晶硅的棒材），切克劳斯基发明， 在一个直筒型的热系统里面，用石墨电阻加热，将装在高纯度石英坩埚中的多晶硅熔化，然后将籽晶插入熔体表面进行熔接，同时转动籽晶，再反转坩埚，籽晶缓慢向上提升，经过引晶，放大，转肩，等径生长，收尾等过程，一支单晶硅就能生长出来 区熔法（FZ）（生长单晶硅的棒材） 外延法（生长单晶硅薄膜） 在集成电路中主要用的是CZ的抛光片或者是外延片 直拉法生长机理： 可生产大直径单晶，是目前IC用Si单晶的主流拉制方法 将电子级多晶硅原料在石英坩埚中加温至Si的熔点以上使其熔化，“拉制”是溶液在籽晶上冷凝并规则排布的过程，采用单晶籽晶作为起始材料，籽晶的晶向决定着所拉出单晶的晶向 核心问题是温度场的控制，拉晶速度决定了单晶棒的直径，而单晶的晶格完整性，掺杂均匀性等也主要由冷凝过程的温度分布决定 直拉法中晶体在熔体表面处生长，而不与坩埚相接触，这样能显著地减小晶体的应力，并防止锅壁的寄生成核 高温下石英晶坩埚中的O、C等杂质会进入Si溶液，如何处理这些杂质也是一个关键问题 单晶硅棒通过切片得到硅片，硅片尺寸一般有4寸，6寸，8寸或者12寸，通过化学机械抛光磨平表面，再在化学溶液中腐蚀，获得表面非常光整的单晶硅片（厚度约0.5mm，直径约300mm） 几种常见的半导体化学性质比较 禁带宽度：GaAs(砷化镓)&gt;Si&gt;Ge,因此Si的PN结反向电流比Ge小 禁带类型，Si和Ge都是间接带隙，GaAs是直接带隙，因此光电器件采用GaAs 电子迁移率：Si&lt;Ge&lt;GaAs,因此Si不适于在高频下工作，高频高速以及微波器件多采用GaAs 集成电路和其它微结构器件中需要多种多样的薄膜 介质膜：高质量的超薄氧化层薄膜，绝缘性能好，包括MOS器件的栅氧化薄膜 超薄，1~3nm；很低的界面态；很好的绝缘性，约9eV bandgap，击穿场强需要7~15MV/cm；能够阻止硼（B）穿过 包括高质量超薄介质层和低热预算介质薄膜 制备技术： 热氧化和ALD(Atomic Layer Deposition，原子级沉积)技术 CVD(Chemical Vapor Deposition)技术：在器件形成或者金属互联之后淀积介质膜，要求低的热预算（thermal budget，温度与时间的乘积），使得在淀积薄膜的工艺下，不对已经形成的器件的杂质分布或者已经形成的金属互联网络产生不好的影响 氧化的速率受温度和氧化时间的影响很大。当氧气浓度很丰富时，二氧化硅的生长速度由硅键断裂速度决定，而此过程大部分取决于温度的高低。为了得到致密的氧化层，必须使反应炉内的温度保持恒定 二氧化硅在整个工艺流程中多次用来作为硅衬底保护层和连个电极之间的隔离层 氮化硅非常致密并且比其他材料更能抵抗杂质扩散 金属膜 布线层数和总长度：10层布线，最细线宽在45nm左右，而布线总长度可达到5公里量级 包括用于金属半导体接触的和用于金属互联网络的 制备技术： 溅射，蒸发，电镀 单晶态的半导体薄膜 制备技术：外延 为了满足不同的应用场景的要求，对薄膜的要求也是不同的，制备技术的选择和优化要针对应用的需求：应力，附着性，化学稳定性，化学腐蚀的选择性和可加工性，保角性(conformation) 保角性：在图形的面上，沉积的速度大致相同 二氧化硅的应用 在MOSFET中 栅极氧化 绝缘层 钝化层 在IC中 器件隔离 层间介质 掩蔽层 IC中使用的SiO2是非晶体，即短程无序，长程也无序。晶体二氧化硅的密度2.65g/cm3,非晶体二氧化硅的密度2.2g/cm3 ALD(Atomic layer deposition)原子层沉积 原子层沉积是一种可以将物质以单原子膜形式一层一层的镀在基底表面的方法 通常用来制作MOS器件的栅氧化层(又薄质量又高的氧化层) 不是靠衬底（Si）氧化，而是靠化学气相沉积，可用于制备非SiO2系列的high-k(高介电常数)介质 热氧化过程 氧化气氛 干氧：O2;干氧能够提供更好的氧化质量和Si/SiO2界面，良好的界面性使得Si超越别的半导体材料，成为半导体工艺中最受欢迎的一种 湿氧：O2和H2O；需要注意，水汽在二氧化硅中的扩散速度远远大于氧气在二氧化硅中的扩散速度，可以形成厚的氧化层 其他添加元素：H（H2），Cl（TCA或者TCE），N（NH3或者N2O）。其中含氯氧化目的在于去除金属离子 实际生产中会采用dry-wet-dry-anneal的组合形式来进行氧化。anneal即退火，可以促进原子重排，将未反应的Si离子氧化，并减少界面缺陷 热氧化过程 Deal-Grove模型 Deal-Grove 氧化工艺中应注意的其他问题： Na、K等碱金属离子在SiO2中是块扩散杂质，将在SiO2中起移动电荷作用，引起MOS器件阈值电压漂移。因此要严格栅氧化前的硅片清洗和氧化环节的污染控制。氧化气氛中通少量HCl气氛也是控制金属离子沾污的一个办法 Si/SiO2界面的缺陷将成为MOS器件栅下的界面态，也会引起MOS器件阈值电压漂移。需要优化氧化前的硅片表面处理，优化氧化工艺，尽量减少Si/SiO2界面缺陷 后续的家文过程中可能会引起多晶硅删中的B参杂穿透SiO2层进入沟道（B在SiO2中是快扩散杂质），从而改变沟道内的杂质分布；应对办法：提高SiO2的致密性，如采用氧化时加少量NO，形成更致密的SiON；采用尽可能厚的栅介质；不采用参杂的多晶硅栅 氧化层质量的影响因素： 衬底洁净度 气体的纯净度 氧化过程 反应扩散模型，可以有效解释氧化膜厚度大于20nm的时候，超薄氧化层不适用此模型，如栅氧 基础公式 反应扩散模型 氧化层很薄的时候，氧化速率由反应速率控制；氧化层很厚的时候，氧化速率由扩散速率控制 k是反应速率常数，D是扩散系数，C0是氧化剂在SiO2中的固溶度，N是单位体积二氧化硅中氧分子数，x0表示t=0时刻氧化膜厚度。其中k，D和C0均与温度有关，C0还与压强有关，可以增大压强提高C0 影响氧化反应速率的因素： 温度 压强 重掺杂削弱Si-Si键，提高了反应速率 含氯氧化，cl能与绝大多数金属反应，生成的氯化物易挥发，提高了反应质量。反应副产品H2O的加入加快了反应速率 不同的晶向反应速率不同，原因在于晶面之间的距离不同，111面最快，100面最慢 干氧湿氧法的特点及原因 干氧：氧化层质量高，Si/SiO2界面特性更好，但是反应速率较慢 湿氧：氧化层较稀疏，通常适合生长较厚的氧化层，反应速率较快 原因：水分子比氧分子小，更容易在SiO2中扩散，水分子在SiO2中的溶解度大于氧分子 RTO（Rapid Thermal Oxidation） 超薄氧化膜（如栅极氧化膜）在低温或者低压下很难操控 ，不易生长 RTO技术能够生长1.8nm的氧化膜，氧化硅片的使用高功率的碘钨灯加热硅片以降低Thermal Budget，反应温度在1000℃左右，反应时间是毫秒级，更高的反应温度能够生长高质量的薄膜。RTO工艺只能单片操作，但是每一片消耗的时间很短。RTO技术的缺点在于，温度均匀性很难保证 Si/SiO2表面的杂质分离 分离系数 参杂的硅片在氧化和退火过程中，杂质会重分布，因为杂质在Si和SiO2中的平衡浓度不同 氧化过程中，新生长的SiO2会吸引受体，如硼（B），并且排斥施主，如磷（P）和砷（As） 杂质在SiO2中没有电学活性 热氧化前的清洗 SC1标准清洗，去除有机物和金属，使用氨水，80摄氏度 SC2标准清洗，去除离子，使用盐酸，80摄氏度 自然氧化层去除，使用HF，室温，几十秒时间就完成 评估清洗干净的标准是检测清洗后的水的电阻率是否超过18MΩ·cm Si/SiO2氧化层电荷 评价界面的好坏 氧化层中的电荷越少越好 界面缺陷越少越好，即界面上Si的断键（悬挂键）越少越好 可移动离子 阳离子Na会在氧化层中移动 氧化前的清洗非常重要，可以减少离子污染 固定氧化电荷 在Si片表面的传输去区域由于最后停止O的输送导致Si与O没有形成完全的Si-O键（未完成的氧化反应） 可以通过后续的退火进行原子重排来减少，但是无法避免，因为与工艺相关 氧化层内部残留电荷 由非桥氧所致，可正可负 表面残留电荷 Si/SiO2表面原子级突变，形成缺陷 晶格不对齐导致的悬挂键 可以通入H2与Si形成Si-H键来降低缺陷态，但是不如Si-O稳定，在高压大电流，有应力的情况下，Si-H键容易断裂，影响器件特性 LOCOS &amp; STI LOCOS（Local Oxidation of Silicon，局部氧化隔离）是硅的选择性氧化，SiN作为扩散掩膜层，绝大多数分子很难扩散穿过SiN。先在有源区覆盖一层SiN，接着在暴露的隔离区通过湿氧氧化生长一层较厚的氧化层，最后去除SiN层，形成有源区，在有源区中制作器件。 SiN可以防止O2或者H2O扩散至底层与Si发生氧化反应，但是SiN无法防止气体从侧面扩散，导致横向氧化，因此会形成鸟嘴（bird’s beak），鸟嘴处应力较大，易形成缺陷 STI即浅沟槽隔离，先淀积氧化硅，然后在隔离区腐蚀出一定深度的沟槽，再进行侧墙氧化，用CVD的方法在沟槽中淀积SiO2，最后通过CMP法平坦化，形成沟槽隔离区和有源区。与LOCOS相比较，更有效地隔离了器件，表面非常平坦，有利于下一代工艺的加工。但是STI工艺贵且复杂 LOCOS 氧化膜厚度测量 椭偏仪，可以同时测量厚度与折射率，精度达到1nm，原理是光的偏振，可以测量介质膜 台阶仪，可以测量多种膜，但是需要 先刻蚀出一个台阶 外延 一种特殊的CVD过程三种外延过程，淀积产物呈单晶状态 外延技术 为了形成单晶，外延与普通CVD有两点主要不同： 衬底界面处理更加苛刻，需要利用衬底的晶格来引导薄膜的单晶生长 生长温度比普通CVD高很多 典型应用： 功率器件：功率器件中耐压较高的器件需要在高阻的半导体上制备，同时为了使整体串联电阻很小，衬底需要低阻。整个wafer的上面是低参杂，下面高参杂，而且低参杂的厚度很厚，达到几十微米 改变硅的晶格常数，制备高迁移率应变沟道 溅射、蒸发和电镀（制备金属薄膜） 集成电路对金属化的主要要求： 金属与半导体接触 肖特基接触 欧姆接触 高参杂后利用遂穿机制形成欧姆接触 硅化物的使用。在金属与半导体接触时，通常使用硅化物来作为接触层，避免金属和硅化物的共融体。主要采用钛硅化物，钴硅化物，镍硅化物 金属作为互连线。Al是目前集成电路工艺中最常用的金属链接材料，电阻率较低，工艺简单，易形成欧姆接触。但是铝容易形成电迁徙（高电流密度引发的电子风造成电迁徙），而且铝的RC延迟比较大。目前金属互联正从铝互联转向铜互联。但是铜的刻蚀比较困难，需要采用大马士革工艺。此外，为了简化工艺，在一些短距离的“局部互连”常使用多晶硅和硅化物。 有良好的导电性 容易与N型、P型硅形成低阻欧姆接触 与硅和二氧化硅等有良好的粘附性 易于淀积和刻蚀，便于键合 性能稳定可靠 互连线对台阶的覆盖性要好 蒸发：不易制备合金的膜 溅射（PVD）：可以制备合金膜，粘附性好，但是台阶覆盖性不太好 溅射 电镀：台阶覆盖性最好 典型的金属化应用场合总结 金属化 光刻工艺综述 光刻常用在：有源区的图形化，栅极的图形化，接触孔的图形化，金属图形化 光刻过程的信息流：设计人员CAD设计-&gt;版图转移到掩膜版上MASK-&gt;通过光刻工艺在光刻胶表面的空中形成aerial image-&gt;转移到光刻胶表面real image-&gt;在1um的光刻胶里面形成Latent image-&gt;显影后形成Resist image-&gt;在器件上形成Device Layer；Each step can lose information, distoring device pattern 典型的图形化转移步骤： 旋转涂胶 曝光 显影 湿法刻蚀 去除光刻胶 光刻工艺详解 MOS制备工艺中栅极的光刻步骤 光刻步骤](http://i.imgur.com/fkNnt3m.png)![光刻步骤 硅片清洗：将表面的颗粒和污染物去除，增强光刻胶和硅表面的附着力 化学清洗 去离子水漂净 甩干 预烘及涂底胶 预烘在100℃左右，目的是去除硅片表面的水汽 涂底胶一般涂一层非常薄的HMDS，能够很好地促进光刻胶和硅片表面的结合 涂光刻胶 光刻胶旋图的厚度影响因素： 光刻胶的种类 光刻胶的粘度 真空吸盘的转速 光刻胶喷嘴在喷完光刻胶之后需要suck back（回吸）的动作，目的是避免悬在喷嘴口上的光刻胶掉落在硅片上 光刻胶旋涂后不仅覆盖硅片的正表面，还会覆盖边缘和背面一部分。边缘和背面的部分光刻胶称作Edge bead，需要去除（Edge bead removal，EBR），方法有化学EBR，曝光EBR 软烤：将光刻胶里面80%的溶剂蒸发掉，提高光刻胶和硅片的粘附性 温度90℃~100℃ 具体温度和软烤时间需要具体设置 方法： 烘箱退火 电炉烘烤 过渡烘烤会降低光刻胶的光敏度 对准： 这一步工艺决定了整个微纳加工的最小线宽 分类：接触式，接近式，投影式 曝光 分为接触式，接近式和投影式 后烤：停止光化学反应，让光刻胶的侧面光滑，提高精度，均匀驻波对光刻胶侧面带来的形貌的影响 温度高于软烤的温度，100℃，烘烤10分钟 显影，硬烘和检测 在碱性溶液中显影，沉浸式或者喷雾，可以利用超声波来搅拌，让反应均匀 硬烤目的是将光刻胶中所有的溶剂都蒸发，光刻胶完成聚合化和剥离化，提供光刻胶抵抗刻蚀和注入的能力。同时在硬烤过程中，光刻胶内部的流动将内部的针孔给填满了 光刻机的原理：光的衍射 光刻机就是讲掩膜版上的图形与前次工序中已刻在硅片上的图形对准后，再将硅片表面的光刻胶进行曝光实现图形复制的设备 三个主要性能指标： 分辨率 是可以曝光出来的最小特征尺寸 对准和套刻精度 是描述光刻机加工图形重复性能的一个指标，是层间套刻精度的度量，主要取决于掩膜版和硅片的支撑平台图形对准和移动控制精度性能 产率 每个小时可加工的硅片的数目 接触式光刻：掩膜版直接与光刻胶接触 优点：结构简单，成本低，光的衍射效应小，曝光出来的图形与掩膜版上的图形分辨率相当，设备简单 缺点：光刻胶污染掩膜版，产能低 接近式光刻：掩膜版和光刻胶略微分开，越2~20μm 优点：可以避免与光刻胶的直接接触而引起的掩膜版损伤 缺点：引入了衍射效应，降低了分辨率 投影式曝光：在掩膜版和光刻胶之间使用透镜聚集光实现曝光。一般掩膜版的尺寸会以需要转移图形的4倍制作 优点：提高了分辨率；掩膜版的制作更加容易；掩膜版上的缺陷影响减小 缺点：成本非常高，维护成本也很高 分类： 扫描投影曝光（Scanning Project Printing） 掩膜版1：1，全尺寸 步进重复投影曝光 掩膜版缩小比例（4：1），曝光区域22X22mm 掩膜版由石英作为基座，表面有一层50~500nm的铬层或者乳胶层，这层是带图形的 掩膜图形的制作方法有：镭射光刻写（不精确），电子束刻写（精确），两种方式都比较慢，需要几个小时 光刻胶：光刻胶对光线敏感，所以需要在黄光下进行操作。光刻胶=基材+感光材料+溶剂 正性光刻胶：曝光区域更容易在显影液中溶解（光照破坏了聚合物链式结构） 负性光刻胶：曝光区域更不容易在显影液中溶解（光照促使产生了链式结构） 对光刻胶的要求： 旋涂方便 曝光性好 尺寸稳定 抗刻蚀 光刻胶的清洗 浓硫酸+双氧水去除金属 使用有机溶剂清洗，但是很难去除硬化的光刻胶 氧的等离子体，将光刻胶燃烧 光线通过掩膜版后进入光刻胶，在硅片表面反射，与入射的光波产生干涉，形成驻波（standing wave），驻波的强光区域在显影时候溶解更多，驻波的弱光区域在显影的时候溶解更少，从而导致形成波浪状的侧面图形。避免形成驻波的方法： 在光刻胶里面加入吸收性更强的成分，削弱反射光 使用多层光刻胶 在硅片表面涂上一层防止反射的图层（bottom anti-reflection coating，BARC）。光刻胶不平整，底层反射会使被掩膜保护的光刻胶也得到了曝光，此时必须使用BARC材料。图形化工艺之前必须要平坦化工艺 PEB（后烤）均匀驻波对光刻胶侧面带来的形貌的影响 多层对准（Overlay）产生的误差 掩膜版和硅片的热膨胀系数不同导致硅片上的图形与掩膜版上面的图形有误差，称为：Thermal run-in/run-out error 往同一个方向偏移（translation error） 旋转偏移（Rotational Error） 最大允许误差不能超过特征尺寸的1/3 采用OPC（optical proximity correction）的方法对由于光学衍射和干涉带来的图形畸变 提高光刻分辨率的若干技术 更短波长的光源 汞灯G线波长436nm，H线405nm，I线365nm；KrF准分子激光波长248nm；ArF准分子激光波长193nm。进一步缩小波长，一方面受到没有足够功率和稳定性激光器的限制，另一方面也受到光线大气吸收的限制 浸润式光刻技术 在光刻胶和投影镜头之间填充介电常数n大于1的物质，如水，等效波长就会减小为原来的1/n 移相掩膜技术（光强不变，相位翻转，相长干涉变成相消干涉），移相子通常由透明的薄膜如SiO2来担任 DFM（Design For Manufacture）技术 EUV（Extreme Ultraviolet Lithography，极紫外光刻）使用波长非常小的紫外光来进行光刻，是一套光反射系统，波长11.2nm。目前EUV的瓶颈是光强 偏轴入射光，可以提高NA，原因是增加了高阶衍射的入射量（高阶衍射光中携带了精细图形的信息） 光刻的非理想因素 光刻胶有厚度，上表面的光刻胶接收的光照比下表面强，显影过后，光刻胶的横截面呈现梯形。解决办法有：使用高对比度的光刻胶 光刻胶便面不平整，导致部分图形失焦，解决方案：平坦化工艺 平坦化工艺对光刻的重要意义 随着光刻工艺分辨率的提高，DOF（焦深）在下降，对焦过程中很容易失焦，平坦化工艺可以避免 在不平坦的表面，由于光刻胶厚度不均匀，导致曝光不均匀 不平坦的表面会导致光的散射，使得曝光过程不受控制 分辨率与焦深 最小特征尺寸：W=k1λ/NA（瑞利判据）。k1是工艺决定的参数，约0.6~0.8，λ为波长，NA为光学系统的数值孔径NA=n0*sinα，n0为中间介质的折射率，NA代表光学系统收集光的能力。 焦深（景深）DOF=k2λ/(NA)^2,k2也是工艺决定的参数。焦深越大，最小特征尺寸也越大，利用平坦化工艺可以解决焦深的问题 图形转移 图形转移就是利用光刻胶作为掩蔽，通过物理和化学的办法把下面的衬底或薄膜材料中没有被掩蔽的部分腐蚀掉。腐蚀的方式有：湿法腐蚀和干法刻蚀 湿法腐蚀：利用化学试剂进行腐蚀 通常是各向同性的，垂直和侧面刻蚀速率比约为1.2：1。但是KOH对Si的腐蚀与晶向有关，100面的腐蚀速率是111的一百倍 需要控制腐蚀液的浓度和腐蚀温度 不适合在更小尺度下进行刻蚀 只用于wafer的清洗和光刻胶的去除 温度敏感，工艺不好受控 均匀性不好，反应物在硅片表面运输受限 有时候与晶向相关 干法刻蚀：在腐蚀气体的气氛下完成腐蚀。为了增强腐蚀气体的化学活性，通常需要将腐蚀气体激发成等离子体 为了形成等离子体，反应在低压下进行 反应生成物应该是易挥发性的 离子轰击： 电容极板的等离子状态下，等离子体与衬底表面会产生一个鞘层，鞘层产生的自电电势会加速这个离子轰击到衬底表面，离子轰击能量达到10~700eV。离子轰击增强腐蚀效果，腐蚀速率提高几到几十倍 所以Wafer放在阴极，离子轰击的效果更明显 离子轰击将被刻蚀材料表面的原子键破坏 将再沉淀于被刻蚀表面的产物或聚合物打掉，使被刻蚀表面能再与刻蚀气体接触 化学反应生成的聚合物淀积在侧壁，起到保护侧壁的作用，是的整个反应向下进行比较快 增强等离子体离化的手段 用电感耦合产生高密度的等离子体。可单独调节轰击电压和等离子体密度 电子回旋共振 磁性增强RIE 各向异性（Anisotropy）A=1-Vh/Vv,Vh表示水平刻蚀速度，Vv表示垂直刻蚀速度 选择性（Selectivity）Sab=Ea/Eb，Ea表示材料a的刻蚀速率，Eb表示材料b的刻蚀速率 影响干法刻蚀的因素： 压强 气体流量 射频功率 温度 腔体几何形状 各向同性刻蚀：以光刻胶的暴露的表面为起点，向下和向两侧的腐蚀速度相同 完全各向异性刻蚀：以光刻胶的暴露的表面为起点，腐蚀的放下仅仅向下进行，不向两侧扩展 部分各向异性刻蚀：腐蚀的过程向下推进，同时也向两侧扩展，但是速率不一样 刻蚀Si和SiO2 材料：CF4+O2，氧气是用来去除反应生成的聚合物 当氧气表较少的时候，随着氧气浓度的增加，刻蚀速率会增加；当氧气浓度高到一定程度，氧气浓度再上升，会导致刻蚀速率的下降 H2的存在会导致刻蚀速率下降，而且刻蚀Si的速度下降更快 通过通入O2和H2来调节刻蚀速度和选择比 干法刻蚀的物理化学过程 化学腐蚀（中兴活性反应物参与） 等离子增强的化学腐蚀 离子轰击增强刻蚀 生成物的侧壁沉积 刻蚀过程中需要over-etch，确保刻蚀的完全性，同时也需要很高的选择比，如果选择比达不到要求，又需要over-etch，这时候需要加一层etch-stop层。 刻蚀Si上面的氮氧化物，需要先在Si上加一层SiO2充当etch stop layer 如果etch-stop layer很薄，在工艺的最后阶段可以通过降低功率的方式来提高选择比 湿法刻蚀机制： 固体与流体之间存在边界层，厚度在微米量级 反应物通过扩散穿过边界层到达wafer表面 热激发化学反应 反应物通过扩散穿过边界层离开 湿法刻蚀SiO2 SiO2+6HF-&gt;2H2SiF6+2H2O HF对Si，SiNx和光刻胶的选择比很高 反应生成的H2O降低了反应液的酸度，反应速率随之下降 通过加入NH4F可以保持溶液中HF浓度的稳定，因为NH4F+H2O-&gt;NH4OH+HF Si的氮化物湿法刻蚀 使用热磷酸H3PO4，温度150~160℃ 对Si和氧化物有着高的选择比，但是对光刻胶和金属的选择比很低 所以需要加一层硬掩膜来提高对光刻胶的选择比，解决光刻胶不耐酸的问题。（选择比在下面很低用etch-stop layer，在光刻胶部分很低用Hard Mask） Si/Poly-Si的湿法刻蚀 各向同性：Si+HNO3+HF-&gt;H2SiF6+HNO2+H2+2H2O KOH定向刻蚀Si的100面，保留111面不被刻蚀，得到原子级别的光滑面，倒金字塔形状 Al的湿法刻蚀 氧化掉Al，然后用H3PO4刻蚀Al2O3，反应过程中会产生H2带来气泡，需要超声波辅助 干法刻蚀的分类： 溅射：离子轰击靶表面，转移动量，表面几层原子的化学键断裂。溅射的各向异性好，选择性差 RIE（Reactive ion etch）：同时存在物理作用和化学反应，需要在各向异性和选择性之间权衡 化学干法刻蚀：各向异性差，更好的选择性 不同材料的刻蚀 等离子体 自然状态下，气体中会有一小部分分子由于热激发而离化，离化后的离子在内部复合地非常快。 等离子体就是被激发的电离气体，可看作是高度离化的气体，相比分子总数量，它包含了很少的离化分子。这些例子处于热激发态，并快速重组。整体表现为近似电中性的电离气体 常见的等离子体：太阳，闪电，汞灯H线，I线就是水银的等离子体从激发态转到基态而发出的光 等离子体内部组成：电子+离子+分子+自由基+激发态（快要离化的分子） 活化基（Radicals）：中性分子失去外围电子形成的非常有活性的化学物质，参与各向同性的化学反应，形成易挥发的物质 激发态物质：化学活性也很高 正电离子和自由电子：由被电离的物质形成，在电场作用下加速，能量高，各向异性好，参与刻蚀的物理作用：离子轰击，物理溅射 举例：CF4 激发态：CF4* 自由基：CF3-，CF2–，F- 离子态：CF3+ Plasma Etch与RIE Plasma etch：Wafer 放在阳极（或者接地电极）一侧，属于各向同性刻蚀；避免了离子轰击，刻蚀主要依靠化学反应 RIE：Wafer放在阴极（或者功率电极）一侧，各向异性较好 离子朝着Wafer加速，促进了更多的各向异性刻蚀 同时存在化学反应和物理作用 离子轰击增强了化学作用，并且是各向异性的 实质上，垂直的物理刻蚀是微不足道的，因为离子的动量不大（气压高意味着自由程短，加速距离短） PID（Plasma Induced Damage） 表面损伤，缺陷和玷污 天线效应（金属、多晶硅刻蚀）。悬浮导体收集电荷，损伤下面的介质层 离子轰击可能的机制 离子轰击给Wafer表面造成的损伤对整个化学反应起到了催化作用 离子轰击直接分裂了反应物分子 离子轰击去除了那些抑制反应继续进行的不易挥发的物质 干法刻蚀与湿法刻蚀的比较 干湿法刻蚀的比较 刻蚀的评价指标 选择比（有两个，膜与光刻胶，膜与下方一层的介质） 各向异性 均匀性 刻蚀中三个最重要的考虑要素 刻蚀的选择比 各向异性 离子轰击损伤 等离子体刻蚀的试剂中加入C、H、O的原因 C、H、O的有意引入目的在于使反应生成聚合物保护侧壁不被刻蚀，加强了各向异性的刻蚀 刻蚀的终点控制 干涉法，检测薄膜厚度 根据光发射谱，检测反应物浓度（最常用） 质谱法（最准确，最贵） 刻蚀中的若干问题 掩膜损失 刻蚀过程中光刻胶也会有所损失，使得光刻胶定义的窗口展宽，不利于定向腐蚀 解决办法：使用硬掩膜 侧壁沉积物的控制 反应生成有机物在侧壁的沉积过多会使得光刻胶定义的窗口缩小 通过反应气氛中接入小量的O2去除适当的侧壁生成物，使之不产生大量的堆积 侧壁堆积的聚合物对电路可靠性产生不利影响 刻蚀完成后需要加入阳等离子体的处理，去除侧壁聚合物，提高电路的可靠性 负载效应（Loading effect） 刻蚀速率与被刻蚀材料的暴露表面积相关，表面积越大，刻蚀速率越慢，使得刻蚀均匀性受很大影响 解决方法：在图形稀疏区域加一些dummy pattern（加图形），使各个区域的图形密度大致相当 天线效应 离子轰击是带电荷的，在对金属引线或者多晶硅的刻蚀过程中，金属对于器件来说相当于天线，收集了大量的电荷，这些电荷产生的电场有可能会击穿介质层 解决方法：工艺与设计相结合，设计时候避免较大较长的金属引线的刻蚀 刻蚀过程中，由于几何表面不平整带来的影响（有好有坏） 光刻胶的重淀积，一方面保护了侧壁，另一方面会影响器件的性能 纵梁（stringer）效应：台阶处的薄膜厚度各不相同，各向异性刻蚀会在台阶侧壁形成一道“纵梁”，需要大量的over-etch才能消除纵梁效应 Blanket Metal Etch-back 填充连接孔（contact hole）–钨塞：首先用LPCVD 的方式淀积金属W，然后用RIE的方式刻蚀掉表面多余的W，只留下连接孔里面的金属W 回刻是不需要掩膜的 Lift-Off 工艺（剥离工艺） 如果薄膜在等离子体中刻蚀不能生成易挥发的化合物，比如刻蚀铜Cu，可以采用Lift-Off的方法 使用图形化的工艺淀积一层牺牲层（一般是光刻胶），只留下需要的图形没有淀积上光刻胶 淀积需要的金属铜Cu，此时没有覆盖光刻胶的部分就会淀积上一层Cu 使用简单的湿法刻蚀，去除掉光刻胶，最后剩下的就是需要的金属铜构成的图形 低产量，低均匀性，不适用于量产 MOSFET多晶硅删的刻蚀 MOSFET多晶硅删的刻蚀 TSV（through silicon via）刻蚀 TSV刻蚀 掺杂 掺杂是将掺杂物替位式地引入半导体材料的晶体结构中以改变其电学特性 分类： 离子注入 热扩散 原位掺杂，用在单晶硅生长或者薄膜生长的过程中，例如拉单晶时候对硅进行磷或硼掺杂 想要在掺杂区域获得良好的掺杂分布图需要对深度（depth）和浓度（concentration）有好的控制能力。离子注入方式在这方面做得比较好 参杂的来源可以是固体，气体，液体（BBr3，AsCl3，POCl3，在高温熔炉里此时都已称为蒸汽）和沉积源（如SOG，方法是让包含杂质的玻璃溶解） 固溶度（Solid solubility limit）：能够被热扩散进入Si的最大剂量。离子注入不受固溶度的限制 在氧化过程中将杂质引入，热扩散过程中伴随着Si的氧化 掺杂过程中有意引入氧气 掺杂B使用B2O3 掺杂P使用P2O5 掺杂As使用As2O3 H,Li,Na,K,Ar等I，VIII族元素在Si的扩散属于间隙扩散，间隙扩散适用于原子半径小的元素。 替位扩散是一种空位扩散，依赖两种情况： 相邻位置有空位 杂质原子有足够的能量克服势垒 替位式掺杂才有电学活性 间隙式扩散的激活能远远小于替位式扩散的激活能 扩散工艺综述 扩散工艺介绍 杂质在纵向扩散的同时，也进行横向扩散。一般横向扩散长度为纵向扩散深度的0.75~0.85，横向扩散是“设计规则”要考虑的重要因素，影响IC的集成度，也影响PN结电容 扩散系数D表征杂质在硅的晶体里面扩散的运动速率，不同的杂质在不同温度下有不同的扩散系数。 扩散系数 Ea是原子扩散的激活能 在Si中，B和P的扩散属于替位式原子扩散，这种扩散需要通过晶体的热缺陷的产生和运动来实现，因此需要较高的温度 对于半径很小的原子，比如金原子，它在硅中是通过晶格间隙来扩散的，扩散温度比较低。 扩散中的掩膜使用SiO2，Si3N4这些耐高温的材质 两步扩散工艺 两步扩散工艺 预淀积（Predeposition），确定总体的掺杂数目，有两个影响因素： 杂质的扩散率 杂质的最大固溶度 推进（Drive-in ），确定杂质的分布 为什么要分成两步？ 因为需要控制浓度（剂量）和结深，很难在一步之内同时控制这两个参数 使用SiO2扩散掩膜来实现选择性杂质扩散，SiO2膜需要一定的厚度以保证高的选择比 多晶硅中的热扩散有一种效应叫做：晶界效应。即在晶粒内部的杂质扩散类似于单晶硅，但是在晶粒边界由于晶格缺陷造成大量空位，杂质的扩散速度大大加快 菲克定律 菲克定律 菲克定律公式 扩散过程计算 预淀积过程扩散浓度计算 推进过程的扩散浓度计算 预淀积阶段，杂质分布服从余误差函数，扩散总量Q(t)=2Cssqrt(Dt)/sqrt(π)≈1.13Cssqrt(D*t) 热扩散的推进阶段，杂质分布服从半高斯分布，理论上中心点在0处；离子注入的杂质分布也服从高斯分布，中心在Rp（投影射程）处 离子注入工艺 热扩散方法的缺陷 表面浓度和扩散深度相关 基本上只能获得高斯或余误差分布 受上述各种增强扩散因素的影响，实际上很难精确控制杂质浓度和深度 离职注入可以精确地控制杂质数量和灵活的调节其分布，代价是晶格损伤。晶格损伤可以通过退火工艺来消除 离子注入设备 离子源：气态源或者固态源BF3，AsH3，PH3 放电室：低气压、分解离化气体，如BF3-&gt;B,B+,BF2+,F+等 引出狭缝：负电位，吸引出离子 离子束流量（最大mA量级） 吸极电压约为15~30KV,决定引出离子的能量 质谱仪：选择注入所需的杂质成分 分析磁铁：磁场方向垂直于离子束的速度方向 出口狭缝：只允许一种(m/q)的离子离开分析仪 加速管：加速离子，获得所需能量；高真空。最终获得动能和电压差，离子所带的电荷数有关 终端台：控制离子束扫描和剂量 法拉第杯：捕获进入的电荷，测量离子流 离子注入的优势 对剂量和杂质分布的精确控制，不受固溶度极限的限制 低温工艺，可以使用光刻胶作掩膜 更多的对掩膜材料的选择（如PR，SiO2，多晶硅，金属） 对表面清洁度不敏感 杂质有很少的横向扩散 可以穿过顶层对下层的材料进行掺杂 介质分布可以通过多次不同投影射程的离子注入来实现（如为了形成矩形分布） 杂质纯度非常高（因为使用了质谱仪将需要的杂质分离出来） 离子注入关键的参数： 剂量（dose）：硅片上单位面积注入的离子数量，用法拉第杯测量注入的离子数量来控制束流大小 投影射程（project range）：指深度方向的延伸的距离。注入能量是决定注入深度的关键因素 离子注入的局限性 难以得到B的浅结，或者As的深结，原因在于投影距离受到离子入射能量的限制（能量太高太低都不好做到） 离子注入损伤是无法避免的（部分Si晶格遭破坏，表面非晶化），需要后续高温热退火修复并且激活杂质 通常需要一层氧化层充当牺牲层，来保护衬底 有沟道效应 入射离子的分布 溅射，散射与注入 当真空中有一束离子束摄像一块固体材料，离子束把固体材料的原子或者分子撞出固体材料的表面，这种现象叫做溅射 当离子束从固体表面反弹回来或者穿出固体材料而去，这种现象叫做散射 当离子束射到固体材料以后，受到固体材料的抵抗，速度慢慢降低，最终停留在固体材料中，这种现象叫做离子注入 影响离子注入的因数 横向偏差：入射离子的分布大于光刻胶开孔的区域 MASK的材料，很多情况下是图形化后的光刻胶，光刻胶的厚度要根据实际情况定 现代工艺需要浅结，一味降低加速电压会导致离子束流不稳定，为了实现离子的低能注入，可以采用分子注入的方法。如注入B+可以使用BF2+，B+的注入动能会降低为20% 沟道效应：一束准直带电粒子通单晶相互作用，当入射方向接近某一主晶轴方向，粒子射程明显增加。沟道效应会使注入注入分布产生很长的拖尾。解决方法是偏离轴注入，或者衬底表面非晶化处理。 注入损伤和退火。 注入损伤的形成：高能入射离子与靶原子核发生碰撞时，使靶原子离开初始晶格位置，并引发连续碰撞，引起大量靶原子跑哪里晶格位置，产生空位和填隙原子等晶格损伤。 注入损伤阈值剂量：超过某一剂量注入后，形成完全损伤，晶体的长程有序被破坏。离子越轻，阈值计量越高。温度越高，阈值计量越高。 IC工艺中的热预算 IC制造过程中经过每一步高温工艺，都会对最终的杂质分布产生影响–杂质再分布 随着IC器件中尺寸的不断缩小，要求杂质的再分布要尽可能小，因此“Thermal Budget”称为工艺集成中要考虑的一个非常重要的概念，尽量减少采用高温工艺，采用RTA等 Rapid Thermal Process（RTP）和Rapid Thermal Annealing（RTA）成为常用工艺手段 RTA用来激活杂质，修复缺陷，并且能够防止杂质扩散，具有较低的热预算，在“浅结”器件的制作中不可缺少 浅结的制作 低能离子注入 分子注入代替离子注入 快速热退火RTA 表面非晶化 偏轴方向注入杂质 薄膜的分类 根据电学性质分类： 半导体薄膜，如Si，SiGe，SiC 绝缘体薄膜，如SiO2，PSG，low-k，high-k介质 金属薄膜，如互联使用的W，Al，Cu，金属硅化物TiSi2，NiSi2，和阻挡金属层，如TiN，TaN 根据微结构分类： 单晶材料，如单晶硅 多晶材料，如多晶硅，大多数的金属 非晶材料，如SiO2，SiNx PVD与CVD比较 PVD直接将原子淀积到衬底表面，而CVD通过表面化学反应生成薄膜 PVD主要用来淀积金属膜，CVD主要用来淀积介质薄膜 CVD比PVD有更好的均匀性和保形性（或者叫台阶覆盖性） 外延生长可以通过CVD实现，但是PVD不能够实现外延生长 CVD工艺特点 气相反应物淀积成膜 高温和低压是最常见的反应条件，但也不总是需要 所有的CVD方法都需要某种能量源来将反应气体分解反应活性物质（自由基） 整个CVD过程要么是化学反应控制，要么是质量传输控制 分类：APCVD，LPCVD，PECVD，MOCVD，MBE（分子束外延），ALD（原子层淀积） 薄膜淀积过程（以多晶硅为例） 混合气体进入反应室，反应室尺寸远大于气体分子自由程，所以气流是粘滞流，主气流是层流，在硅片表面形成“边界层” 硅烷（SiH4）从主气流区以扩散方式穿过边界层到达衬底表面 在硅片表面硅烷及其分解的气态含硅原子团被吸附在硅片的表面，成为吸附分子 发生表面反应，生成的硅原子在硅片上聚集，连接成片，成膜； H2从衬底表面解吸，被排出反应室 外延 外延工艺，指在晶体上用化学或者物理的方法规则地再排列所需晶体材料 外延层和衬底晶向相同，但掺杂类型、电阻率、材料可以不同 外延按工艺方法划分： 气相外延（VPE）：最为成熟，在单晶硅上用CVD方式将气态反应物淀积到表面，能够生长出晶格匹配的单晶硅层 液相外延（LVP）：拉单晶过程 固相外延（SPE）：使用单晶硅仔晶使无定型的硅结晶，通常用来修复离子注入损伤 分子束外延（MBE）：分子束注入到衬底表面，外延生长一层单晶层。技术先进，通常用来制备GaAs和其他混合半导体薄膜。能够精确控制单原子层生长。 外延按照材料划分： 同质外延，又称均匀外延 异质外延，又称非均匀外延 外延层要与衬底相容，包括： 两者在外延温度不发生化学反应，不互溶 两者热力学匹配 两者晶格匹配 CVD技术（主要用来淀积介质薄膜，如多晶硅，SiO2和氮化硅） 过程：气态反应物在沉底反应生成固态的薄膜，例如siH4(g)+O2(g)-&gt;SiO2(g)+2H2(g)[400℃],3SiH4(g)+4NH3(g)-&gt;Si3N4(s)+12H2(g)[750℃],其中SiH4称为硅烷,SiH4(g)-&gt;Si(s)+2H2(650℃),WF6(g)+3H2(g)-&gt;W(s)+6HF(g) 工艺步骤： 反应物运输到淀积区域 反应物从主气流穿过边界层运输到晶片表面 反应物吸附在晶片表面 表面作用，包括化学分解或反应，在表面迁移向吸附位置（表面迁移可以消除几何因素，降低台阶效应，反应更加彻底，生成的薄膜更加致密） 副产物的吸解 副产物穿过边界层回到主气流中 副产物离开淀积区域排走 CVD技术分类及设备简介 常压化学气相沉积（APCVD），激励源：温度；特点：产能(throughput)大,但是台阶覆盖性和均匀性不好。设备结构简单，淀积速率较快。但容易发生气相反应、产生微粒污染。 常压指的是亚大气压（约0.1个大气压） 反应速率快，气相质量运输成为瓶颈 优势： 反应设备简单，淀积速率快 缺点 污染，气相反映产生了颗粒（因为APCVD的浓度高，反应可以不用借助表面） 均匀性差，因为是气相质量运输限制 台阶覆盖性差，因为衬底温度低 应用 低温氧化，亚大气压下的气相外延 将工艺温度控制在气相质量输运限制区，薄膜淀积速率对反应剂浓度敏感，而对衬底温度波动不敏感 在工艺过程中要精确控制反应剂成分、剂量以及分布的均匀性 衬底温度远高于气流温度，气流的变化会引起衬底温度略有起伏，但是对淀积速率影响不大 低压化学气相沉积（LPCVD），激励源：温度；特点：气体稀薄，自由程大，硅片可以紧密排列，可以批量加工，并且保角性比较好，但是工艺温度比较高，石英管壁上的沉积物成为后续工艺中的颗粒；有气缺现象。 与APCVD相比增加了真空系统，是淀积多晶硅、氮化硅、二氧化硅、PSG、BPSG、W的常用方法 气缺效应：指一段进气，沿气流方向反应剂不断消耗，淀积膜厚不均现象 工艺控制 主要是工艺温度，气体总压，个反应剂分压，气流速度及分布均匀性。另外，工艺卫生也很重要，如淀积之前应清理反应室颗粒物 LPCVD通常将温度控制在表面化学反应控制区，薄膜淀积速率对温度波动非常敏感，而对反应剂浓度及分布均匀性不太敏感 气缺效应可通过沿气流方向逐步提高加热器温度，加快反应速度，从而提高淀积速率来消除。 优势 较少的污染 均匀性好（因为热墙式反应器的温度控制精确，Wafer受热更均匀） 一致性好（台阶覆盖性好） 缺点 淀积速率较慢 提高反应速率需要更高的温度 应用广泛 低温氧化（LTO），氮化物，多晶硅，W和WSi2 等离子体增强化学气相沉积（PECVD），激励源：等离子体，温度 工艺温度较低，淀积速率是表面反应控制，影响淀积速率与质量的因素除了温度之外，还有反应器结构，射频功率强度和频率，反应剂与稀释剂气体剂量，抽气速率 薄膜均匀性较好，台阶覆盖性和粘附性都好于APCVD和LPCVD。 薄膜较疏松，密度较低，含有较高浓度的氢，有时还含水、氮，成分不是理想的化学配比 PECVD是当前制备SiO2，Si3N4采用较多的CVD方法，所制备的薄膜适合作为集成电路或者分立器件芯片的钝化膜和保护膜 优点 温度低，淀积速率快，台阶覆盖性较好（需要离子轰击的辅助才能改善台阶覆盖性） 缺点 反应内壁也有淀积，存在污染 应用 金属绝缘层，钝化层，在低温材料的淀积（比如塑料） 几种最常见的CVD实例 W plug（钨塞），用于集成电路互联线层间连通金属，需要优化CVD工艺，提高保角性 ClusterTools设备使得硅片在不同的反应腔中传输时不出真空环境，大大减少了环境影响因素，提高了工艺成品率 对下层非平面形貌的覆盖，包括台阶覆盖和孔的填充问题，通过控制反应气体理化特性和各种工艺条件，达到： 适当的粘附系数 主要由反应控制决定薄膜生长有利于台阶覆盖 CVD-SiO2 与热氧化SiO2的理化性质相比略有差异，随着工艺温度降低，密度下降，耐腐蚀性下降，成分偏离化学配比。 TEOS为硅源淀积的SiO2台阶覆盖性好于以硅烷为硅源的反应剂系统 SiO2薄膜用途不同要求不同 作为多层布线中金属层之间的绝缘性，应有较好的台阶覆盖性，具备较高介质击穿电压 作为防止杂质外扩的覆盖层、掩膜以及钝化层：针孔密度低，薄膜致密 PSG（磷硅玻璃）、BPSG（硼磷硅玻璃） SiO2中掺P或B后软化温度下降，通过退火回流，可降低硅片表面台阶，实现平整化，掺杂剂：PH3、B2H4、TMB、TMP（高温下，膜软化，有一定的流动性，改善了台阶覆盖性） PSG薄膜应力小，台阶覆盖性较好，P一般控制在6~8wt% BPSG是三元氧化膜体系，软化温度低于PSG，回流温度在850℃，B控制在5wt%一下 高温退火可以使生成的薄膜致密 APCVD-SiO2 SiH4/O2为源 工艺：通常淀积USG，温度450~500℃，用N2稀释SH4与过量O2的混合气体 特点：工艺成熟，孔隙填充和台阶覆盖性差 用途：作为多层金属铝布线中铝层之间的绝缘层（记为ILD） TEOS/O3为源 工艺：温度400℃，TEOS为液态，沸点168.1℃，用源瓶在其携带，温控流量；O3约1~2%。加入PH3、B2H4来淀积PSG、BPSG 特点：在SiO2薄膜中会含有水汽，针孔密度较高，通常需要高温退火去除潮气，提高薄膜致密度；良好的台阶覆盖性，填充空隙能力较强 用途：多用于淀积多层布线金属层之间的绝缘层。 实际工艺中常将SiH4/O2和TEOS/O3两种系统连用，也可APCVD和其它方法结合起来使用 LPCVD-SiO2 TEOS或TEOS/O2为源 工艺：制备USG、PSG、BPSG，温度：680~750℃ 特点：致密性、台阶覆盖性等好于同类低温工艺；O2的加入能改变薄膜的内应力 用途：USG用于金属层之间的绝缘层，PSG、BPSG作为制备金属化系统之前的绝缘层 SiH2Cl2/N2O为源 工艺：淀积USG和PSG、BPSG，温度约900℃ 特点：是高温工艺，薄膜的均匀性和台阶覆盖能力都好，HF的腐蚀速率、密度，以及电学性质和光学性质也都与热生长的氧化层接近。含有氯 用途：作为掩蔽膜 PECVD-SiO2 源：SiH4/N2O、O2 工艺：200~400℃，10~100Pa 特点：薄膜含H、N，与LPCVD、APCVD相比薄膜应力小、不易开裂、保形性好，离子对衬底有轰击 用途：可作为保护膜、钝化膜 氮化硅薄膜淀积 氮化硅薄膜性质与用途 氮化硅薄膜与二氧化硅薄膜比较： 抗钠能力强，硬度大，针孔少，更致密，化学稳定性好，作为钝化膜、保护膜有优势 掩蔽能力强，SiO2对B、P、As、Sb有掩蔽作用，Si3N4还可以掩蔽Ga、In、ZnO。能作为多种杂质的掩蔽膜 介电常数大，导热性好，作为电容的介质层 与硅失配率大，与Si3N4接触的Si界面缺陷大，称为载流子陷阱，或者复合中心，影响硅的载流子迁移率。因此需要在Si和Si3N4之间生长一层薄的氧化层 用途 MOS器件场区氧化使用Si3N4作为选择性氧化的掩膜(LPCVD) 刻蚀氧化层使用Si3N4作为自停止层(LPCVD) 使用Si3N4作为CMOS电路的保护膜(PECVD) 分类 LPCVD-Si3N4：薄膜密度大，硬度高，耐腐蚀性强，又被称为硬质氮化硅 反应剂：SiCl2H2/NH3 工艺：硅烷应稀释，NH3要充足 速率影响因素：工艺温度，总气压，各气体分压及比例等 特点：台阶覆盖性好，也有粒子污染。薄膜的内应力大，超过200nm的厚度时可发生龟裂，耐HF、KOH等腐蚀 PECVD-SixNy：工艺温度低，薄膜通常含有相当数量的H，密度、硬度、耐腐蚀性都不如LPCVD-Si3N4，又被称为软质氮化硅 反应剂：SiH4/NH3、N2 工艺：温度在200~400℃；压力10~100Pa，以N2为反应剂应比NH3要更充足 特点：薄膜中氢含量高；用N2代替NH3含氯明显下降，淀积速率也降低 用途：作为芯片的保护膜和钝化膜，但有些场合低温淀积薄膜质量的下降，也限制了它的应用 Low-k材料 随着器件特征尺寸减小，栅极延迟和互连层延迟越来越突出，主要是RC delay R的减小可通过将Al替换成Cu，但是Cu很容易扩散到绝缘材料中，造成沾污 C的减小可以将SiO2转换成low-k材料，二氧化硅的介电常数是3.9，low-k材料的介电常数在1~3之间。典型的有： SiOF 多孔介质 有机low-k材料（SiLK，含Si的有机材料） 空气 low-k材料的优点 缩短了信号传播延时 降低了线路串扰 需要开发介电常数在2甚至2以下的介质材料 有稳定的理化特性，保证电路的长期应用可靠性 与金属布线有很好的粘附性 便于RIE等加工 high-k栅介质与金属栅 随着器件特征尺寸减小，栅氧厚度越来越小，随之带来的漏电流也增大，增加了耗电量 使用high-k材料作为栅极电介质，可以在减小等效栅氧厚度的同时不减小栅极电介质厚度 通常使用MOCVD或者ALD方法淀积high-k材料 有前景的high-k材料 HfO2，HfNO，Al2O3 目前HfO2是最常用的，但是HfO2与Si的界面不好，需要加入SiO2过渡层 随着MOS栅长的缩短，为了保持栅控能力，抑制短沟道效应，必须加大单位面积的栅电容Cox。 一方面可以减小栅介质的厚度。栅长缩短到45nm，对应的SiO2栅厚度需要降低到接近1nm，这么薄的栅介质将引起两方面的问题： 1nm的势垒宽度已接近产生明显量子遂穿的宽度 1nm的栅介质很难阻止掺杂多晶硅中的掺杂原子向沟道内的扩散，尤其是B原子 另一方面可以增大栅介质的介电常数。使得较大物理厚度的High-k栅介质与较薄的SiO2有相同的等效电容 多晶硅栅带来的问题 对于22nm技术时代，其EOT为0.5nm，对应的HfO2栅介质2nm，不足以阻挡多晶硅栅中的杂质（尤其是B）向沟道内扩散 参杂多晶硅是半导体，在一定的偏压下会出现界面载流子耗尽，额外引进一个等效厚度0.1~0.5nm的空间电离层，增大栅介质的等效厚度 22nm一下技术代通常采用金属或金属硅化物，取代参杂多晶硅，作为栅极材料。 金属栅的优点： 无耗尽层的问题 无B穿通的问题 更低的串联电阻 抑制短沟道效应 金属栅的缺点 NMOS和PMOS器件采用相同材料的金属栅，则器件的Vth（开启电压）不可能做小； NMOS和PMOS器件采用不同材料的金属栅，则制造工艺复杂 多晶硅薄膜的淀积 多晶硅薄膜的性质与用途 多晶硅薄膜是由无数微小晶粒组成的薄膜，晶粒大小与制备工艺有关，在晶粒与晶粒之间是晶界。晶界原子排列无序，含大量悬挂键以及高密度缺陷。硅多晶的结构特点造成它有一些与单晶不同的特性 杂质扩散系数大：晶界处&gt;&gt;晶粒内部 杂质在晶粒内部与晶界处分凝，分凝系数小于1，且随温度而变化，高温时晶粒内杂质在低温时运动到晶界处，而高温时又返回晶粒内部 特点：多晶硅有良好的高温工艺兼容性，与热生长SiO2有很好的接触性能，保形性良好，应力小 用途 MOS器件的栅电极及多层互连布线 自对准工艺中的硅删 在SRAM中用于制作高值负载电阻 MEMS器件中，制作压学传感器的应变电阻 LPCVD-Poly Si 源：硅烷 质量：淀积温度，淀积速率，总压力，硅烷分压，以及随后的热处理过程 可以在多晶硅生长同时进行原位掺杂 CVD金属 钨机器化学气相淀积 用途：作导电填充物–插塞（plug） 作局部互连材料–W的导电率低，只用作短程互连线 特性：体电阻较小，热稳定性较高，但是超过400℃时，钨膜会被空气中的氧所氧化，较低的应力，良好的抗电迁移能力和抗腐蚀性 LPCVD-W工艺 源：WF6 金属化合物CVD LPCVD-WSix 用途：在多晶硅/难熔金属硅化物的存储器芯片中被用作字线和位线，WSix也可作为覆盖式钨的附着层 CVD-TiN 源：TiCl4 特性：TiN热稳定性好，基面结合强度高，导电性能好，杂质在TiN中的扩散激活能很高 用途：在多层互联系统中作为扩散阻挡层和（或）附着层使用 MOCVDMOCVD常用来淀积三五族和二六族化合物薄膜 能够生长单原子层的工艺MBE和ALD 物理气相淀积PVD PVD是利用某种物理过程实现物质转移，将原子或分子由源（或者靶）气相转移到硅衬底表面形成薄膜的过程 工艺特点：相对于CVD而言，工艺温度低，衬底在室温~几百℃；工艺原理简单，能用于制备各种薄膜。但是，所制备薄膜的台阶覆盖特性，附着性，致密性都不如CVD薄膜 用途：主要用于金属类薄膜，以及其他用CVD工艺难以淀积薄膜的制备。如金属电极，互联系统中的附着层、阻挡层合金以及金属硅化物薄膜的制备 分类： 真空蒸镀：在高真空室内加热原材料使之气化，源气相转移到达衬底，在产地表面凝结形成薄膜。有电阻蒸镀，电子束蒸镀，激光蒸镀 溅射：在一定真空度下，使气体等离子化，其中的离子轰击靶阴极，移出靶原子等粒子气相转移到达衬底，在衬底表面淀积成膜。有直流溅射、射频溅射、磁控溅射等 真空蒸镀（普适性更好，无论什么材料都能用蒸镀工艺制备） 蒸镀指在高真空度下，加热源使其蒸发，蒸汽分子流射到衬底表面，凝结形成薄膜的工艺。可以将蒸镀分解为三个过程： 蒸发过程 气相质量输运过程 淀积成膜过程：吸附-&gt;成核-&gt;连片-&gt;生长 台阶覆盖特性的改善方法 衬底加热，温度应依据所淀积薄膜的材料特性来综合考虑 衬底旋转，除了可以改善因到达角不同带来的台阶阴影区的薄膜覆盖问题之外，还可以改善淀积薄膜厚度的均匀性 蒸发速率的控制 提高蒸发速率，能提高所淀积薄膜的纯度和与衬底的结合力，以及表面质量。蒸发速率过快，蒸汽原子碰撞会加剧，动能降低，甚至会引起蒸汽原子结团后再淀积，这将导致出现薄膜表面不平坦等质量问题 蒸镀工艺，要求蒸镀室为高中空度的原因： 为了满足蒸发分子或原子平均自由程大于放源坩埚到衬底的距离 为了薄膜纯净（避免被泄露的O2，H2O污染） 为了避免蒸发分子或原子在气相被氧化 气相金属源的获得 对于易熔金属，采用热蒸发 对于难熔金属，采用电子束 膜厚较难控制，因为气体压强受温度影响很敏感 阴影效应，由于蒸发出的原子投影距离远，在衬底表面没有迁移或者反映 溅射 溅射工艺是利用等离子体中的离子对阴极靶轰击，导致靶原子等颗粒物飞溅，落到衬底表面淀积成膜的一种薄膜制备工艺 离子对靶的轰击 离子对处于负电位的靶轰击，使靶材料原子或者分子及其原子团从靶表面飞溅出来的过程。 能量在10eV~10KeV时，有中性离子逸出，不同材料的靶，溅射阈值能量不同 靶原子气相运输 较低真空度下，靶原子在到达衬底表面前会与其他离子发生多次散射，衬底表面某点所到达的靶原子数与改点的到达角有关。高真空度下，气相运输轨迹是直线，衬底表面某点所到达的靶原子数是受遮蔽效应限制 淀积成膜 到达衬底的靶原子在衬底表面先成核再成膜的过程 溅射离子与靶原子间有较大的能量传递，逸出原子携带的动量较高，在10~50eV之间。因此，原子在衬底的迁移能力、再发射能力都强，成膜的台阶覆盖性和附着力都较好 溅射薄膜的质量及改善方法 薄膜的保形性覆盖特性较好 薄膜附着性较好 薄膜致密性较好，针孔少 淀积速率较慢，膜厚可控性和重复性较好 薄膜纯度较高，不存在蒸镀时无法避免的坩埚污染现象 淀积过程中对衬底辐射造成的缺陷远少于电子束蒸镀 在制备特殊材质薄膜上电子束蒸镀更有优势 保形覆盖特性的改善 尽量提高衬底温度：以增强衬底所吸附的溅射粒子表面扩散迁移率，同时也要考虑温升后多晶态晶粒也随之长大，使得薄膜表面变粗糙 在衬底上加射频偏压：这使得衬底被高能离子轰击，有助于溅射粒子的再发射淀积，可在一定程度上改善保形覆盖特性 准直溅射技术：在衬底正上方插入准直器，只有速度方向接近于垂直衬底表面的溅射原子才能通过准直器上的孔，到达衬底表面，淀积在接触孔的底部 特点： 常使用惰性气体的等离子体来轰击靶原子 靶源的面积大于衬底的面积能够改善均匀性和台阶覆盖性 靶和衬底之间的距离只有几个厘米 低的真空度，因为需要等离子体气体的存在 溅射到衬底的原子有足够的能量能够在产地表面迁移，改善台阶覆盖特性 便于控制薄膜厚度 成本较蒸发高 PVD金属及化合物薄膜 铝及铝合金薄膜淀积 1um厚铝膜的电阻率约为3uΩ·cm，被用于器件内电极和互连布线的导电层 作内电极时，为与衬底硅形成良好的欧姆接触，通常淀积后在500℃左右退火，退火过程中有“尖楔”现象出现（界面中的Si向铝中扩散，而留下的位置又被铝填充），尖楔现象会引起pn结的穿通。可以用含硅1%的硅铝合金作为内电极 铝膜的抗电迁移特性差，在铝硅中再掺入2%左右的铜可以改善 制备： 真空镀铝 钨丝电阻加热器或石墨坩埚装铝电子束加热 方法简单，但钨丝加热器会引入杂质，衬底附着和台阶覆盖特性也较差 磁控溅射铝及铝合金 薄膜附着力、台阶覆盖特性，以及膜厚可控性较好 铜及其阻挡层薄膜的淀积 Cu电阻率只有Al的40%~45%，抗电迁移性比铝能高两个数量级。早起IC不用铜作互连布线的原因： 中毒现象：Cu在Si和SiO2中都是快扩散杂质，在较低温度就能扩散进Si，会改变硅衬底的电学特性 工艺性差：Cu与Si、SiO2粘附性不好，图形刻蚀难 铜互连技术 化学气相淀积与外延 化学气相淀积（CVD）是把构成薄膜物质的气态反应剂或液态反应剂的蒸汽以合理的流速引入反应室，在衬底表面发生化学反应，淀积成膜的工艺方法 淀积薄膜是非晶或多晶态，衬底不要求是单晶，只要是具有一定平整度，能经受淀积温度即可 CVD工艺主要用于制备SiO2，Si2N4等介质薄膜，poly-Si等半导体薄膜，另外，也用于制备金属化系统中常用的钨、金属硅化物等薄膜 CVD工艺制备的薄膜具有较好的性质，如附着性好，保形覆盖能力较高 不同CVD方法制备的薄膜，性质不同，用途也不同： 低温工艺制备的薄膜质地较疏松、密度低，抗腐蚀性较差，如低温SixNy用作保护膜 中温工艺薄膜密度高，抗腐蚀性好。如中温Si3N4用作腐蚀掩膜 CVD与VPE相似，也可分为气相质量输运和表面化学反应两过程 CVD工艺衬底温度较外延工艺低、淀积速率快，而且衬底表面可以不是单晶；表面反应生成的薄膜原子在衬底上聚集成核，再连接成片、被覆盖成膜，没有外延的规则排列过程或排列不完全，所以，淀积薄膜是非晶或多晶态 CVD工艺反应剂气体分子到达衬底表面特殊位置的机制有：扩散，再发射，表面迁移 金属化 多层金属化的数量达到10层 传统上金属互联电流密度达到10^5A/cm2 金属互联引入了寄生电阻和电容，造成了RC delay，制约芯片的速度 金属膜的用途 互连金属：W、Al、Cu，W通常用作第一层金属，因为W耐高温，可以PVD 硅化物：TiSi2，CoSi2，NiSi，电导率没有金属好，在器件内部作为删极材料以降低电阻率 阻挡层：TiN，TaN 金属膜淀积方法 蒸发，台阶覆盖性差，间隙填充不好，膜厚难以控制 溅射，淀积Al非常常用，是个物理过程 金属氧化物CVD（MoCVD），台阶覆盖性好，最常用来淀积钨塞，现在也用来淀积Cu的仔层 铜的电镀，在大马士革工艺中淀积金属铜，衬底作为负极放入电解液中，铜作为阳极 金属铝的特性 优点： 低电阻率 易于淀积和刻蚀 与Si/SiO2的粘附性较好 与Si工艺兼容性好，价格便宜 与p+Si，n+Si或者Ploy-Si能形成欧姆接触 缺点 抗电迁移性差 有尖楔现象 台阶覆盖性较差 耐腐蚀、稳定性较差 Al/Si接触 只有跟重掺杂的n或者p型Si才能形成欧姆接触 为了形成好的接触，需要合金化 通常在400~450℃，在合成气体（H2/N2）中退火 在界面处消耗SiO2形成合金 工艺 电子书蒸镀，磁控溅射，退火来提高粘附性和减小与SI的接触电阻 Al金属化过程中的尖楔现象 硅在Al中有一定的固溶度，如果Si与Al接触，Si在界面处缓慢溶解到Al中，Al然后回填形成了Al的尖刺 解决方法： 在Al中掺入2%的Si形成Al/Si合金 使用金属阻挡层（TiN，TaN） VLSI中需要金属阻挡层的保护，从而减少电子迁移率和应力迁移 电迁移（不是电子的迁移，而是原子的迁移） 在大电流密度作用下，导电电子碰撞原子，动量转移，金属离子获得能量而迁移，引起金属线的空洞和小丘 当处于大电流密度以及高温时，电迁移更显著 解决方法： 在Al中掺入1~2%的Si和4%Cu，这些杂质在铝中的晶粒间界分凝，可降低铝原子在晶粒简介的扩散系数，来减少电迁移 用金属阻挡层包围Al线 采用电子束蒸镀比磁控溅射更能提高抗电迁移能力 多层金属互联 大约需要10层金属互联 每一层都需要做平坦化工艺 需要刻蚀过孔，淀积金属塞 需要淀积金属层间介质（ILD），最常用的方法就是PECVD TEOS氧化膜 淀积low-k介质可以降低层间的电容 平坦化 局部平坦化使用回刻，比如金属钨塞 全局平坦化使用化学机械抛光CMP，其中使用的研磨液包括刻蚀的化学剂和粗糙的SiO2颗粒,刻蚀速率取决于旋转速度和施加的压力 金属钨塞的制备 LPCVD W RIE的方式回刻，不需要掩膜 铜互联 铜的优点： 低电阻率 能抵抗电迁移 成本低 铜互联的挑战: 其卤化物不易挥发，难以干法刻蚀，因此采用CMP来替代 和金属层间介质有粘附性问题，需要粘接层 在Si和介质中容易扩散造成污染，需要阻挡层 Cu的淀积很困难 双大马士革工艺制备Cu/low-k工艺 对于Al/SiO2体系，0.25微米及以下技术代互联延迟已经超过门延迟，因此需要引入比Al电阻率更低的金属\\比SiO2介电常数低的层间材料 对于Cu/low-k系统，0.13微米及以下技术代互联延迟也超过了门延迟，使得互联延迟成为了现代集成电路速度的“瓶颈” 铜互联的布局：下面几层的互联用很细的线条，上面几层的互联尽可能用比较宽的线条，比较厚的金属，以减小RC延迟 大马士革工艺（Damascene） 为什么需要用大马士革工艺 Al方便使用干法刻蚀加工，Cu无法干法刻蚀 工艺流程 PECVD 层间介质（做通孔用）+氮化硅(etch stop layer)+层间介质（刻槽使用） 根据铜走线刻槽 利用氮化硅作掩蔽，刻相应的孔 溅射金属阻挡层（TaN），阻挡Cu扩散 电镀金属Cu CMP抛光 大马士革工艺 高深宽比的通孔的金属淀积 IMP（Ionized metel plasma）淀积，将溅射的原子离化后引导入深孔中 CVD的方式淀积金属，因为CVD有更好的保形性，比如金属W的回刻 刻蚀小的通孔 刻蚀速率需要特殊校准 刻蚀终点很难检测，因此要求大的over etch 选择比要高 硅化物 Si和金属会结合形成具有金属和半导体特征的混合物，如硅化物，TiSi2，WSi2 硅化物的电阻率相对较低，但比金属高，可以降低源漏端浅结的串联电阻，降低内部互连的多晶硅的电阻 硅化物的形成：在高温下，金属和硅的固相化学反应 自对准硅化物（Salicide） 理想的MOS器件应具备哪些结构和电学参数要求 源-栅，漏-栅之间的距离很近，减小沟道串联电阻 源-栅，漏-栅之间需要一个隔离层 源漏需要有良好的欧姆接触（硅化物），栅上需要低的串联电阻 漏端需要合理的参杂分布以舒缓漏端电场 为了优化器件的漏端串联电阻，需要一个与栅自对准的复杂的参杂分布 为了优化器件的漏端电场分布，也需要一个与栅自对准的复杂的参杂分布 过程： 源漏离子注入后，淀积一层SiO2 RIE刻蚀，栅极形成侧墙（Stringer效应） 淀积金属，高温热退火 选择性地刻蚀金属材料，源漏栅都留下了一层硅化物薄膜 自对准硅化物工艺中，源漏和栅极同时生长出一层硅化物薄膜，以一种自对准的方式 热退火的要求非常苛刻，会消耗一定的Si 栅极两侧的侧墙保证了源漏的化学反应的独自进行，并保证了源漏的深掺杂远离栅极 两方面的自对准 掺杂与栅 硅化物在源、漏、栅上，STI和spacer上没有 为什么要用栅自对准结构？ 漏端串联电阻优化 漏端电场优化 栅掩蔽注入掺杂实现自对准的作用 掺杂分布与栅的位置自然对准，不存在套版偏差 硅化物自对准的作用 减小源漏接触电阻 减小栅极串联电阻 Salicide后的CMOS器件 金属阻挡层材料 Al：Ti，TiN，淀积方法：IMP Cu：Ta，TaN，淀积方法：IMP 金属化材料分类 互连材料：指将同一芯片内的各个独立的元器件连接成为具有一定功能的电路模块 接触材料：指直接与半导体材料接触的材料以及提供与外部相连的连接点 MOSFET栅电极材料：作为MOSFET器件的一个组成部分，对器件的性能起着重要作用 集成电路对互联布线有以下要求 布线材料有低的电阻率和良好的稳定性 布线应具有强的抗电迁移能力 布线材料可被精细刻蚀，并具有抗环境侵蚀的能力 布线材料易于淀积成膜，粘附性要好，台阶覆盖性要好，并有良好的可焊性 PN结隔离特点、用途 工艺成熟，方法简单，成品率高，实现了平面隔离 PN结有反向漏电流现象，反向漏电受温度、辐射等外部环境影响大 密度低，有寄生电容，器件速度做不快 当隔离很深的器件时，需要深的PN结，因此掺杂的时候需要很长的推进时间 横向扩散严重，降低了器件密度 用途 BJT器件的PN结隔离 会带来寄生的MOSFET（金属上的电压使得npn反型，形成了MOSFET） 反向电压增大导致耗尽区长大，本体穿通。为了避免耗尽区的靠近相连，使用guard ring保护 Well-in CMOS 寄生的NPNP结构（由NMOS的有源区、P衬底、N阱、PMOS的有源区构成）会带来闩锁效应（当其中一个三极管正偏时，就会构成正反馈形成闩锁），在闩锁情况下，器件在电源和地之间形成短路，造成大电流 注意事项 避免反向电压击穿，和严重的漏电流 避免反型带来的寄生MOSFET 避免闩锁效应 浅槽隔离 LOCOS的问题 鸟嘴问题：氧化时的横向扩展；氧化层的厚度500nm左右，扩展的尺寸也是这个量级，但目前22nmCMOS器件整个有源区的尺寸也仅仅在100nm量级。鸟嘴属于无用的过渡区，对提高集成电路的集成度极其不利 不平坦的问题：有250nm左右的隆起 应力的问题，鸟嘴处的应力过大 对刻蚀要求高 侧壁光滑 夹角不大于85℃ 沟道处的杂质在氧化过程中重分布 器件边缘会有寄生晶体管 回刻LOCOS工艺，方法简单，通过回刻除去部分场氧化层，使表面平坦并恢复部分被鸟嘴占去的有源区。有源区的边缘应力过于集中，造成晶格缺陷，进一步在边缘区产生大的漏电流 STI（Shallow Trench Insulation with CMP） 在硅片上淀积一层pad oxide（垫氧层），用来舒缓应力 淀积氮化硅层，作为硬掩膜 光刻定义需要隔离的区域 利用硬掩膜刻蚀底下硅的浅槽 离子注入，做STI隔离的高参杂层（Channel stop implant） 热氧化的方法在槽的底部生长一层很薄的氧化层，光滑且阻挡效果好 用PECVD TEOS淀积比较厚的介质 用CMP的方法把多余的介质去除掉（此时氮化硅作为CMP的截止层） 湿法刻蚀（热磷酸）去除氮化硅 STI的优点 有效的隔离，并且很紧凑 STI注意事项 氧化物回填的过程中需要避免中间形成空洞，常使用高密度的等离子体CVD工艺 沟槽侧壁因为干法刻蚀而粗糙，需要先使用liner oxidation来光滑 沟槽底部拐角处的介质很容易被击穿，造成大的漏电流，因此需要对拐角处做圆角处理 CMOS器件为什么还需要隔离：第一层布线的时候可能会引起下面半导体表面反型，从而使得器件和相邻器件之间的井有可能穿通 器件隔离的要求 工艺简单，成本低，良率高 占用面积小，从而提高器件密度 不影响表面形貌，台阶覆盖性要求好 有效并且可靠，相邻器件必须被有效隔离，并且能够承受较高的击穿电压，带来更少的寄生电容（寄生电容影响器件速度） 常用的隔离方案：PN结，LOCOS，STI，SOIChannel stop implant作用 提高场区寄生MOSFET的阈值电压 SOI 是一种特殊的衬底，在氧化硅上有一层薄的单晶硅 将不需要的Si刻蚀就能实现完美的隔离效果，寄生电容小，器件密度可以做的非常高，消除了闩锁效应 价格昂贵 器件特性会有轻微差异，原因是浮体效应 制备SOI的技术 SIMOX（通过离子注入氧离子来分离） 超高剂量的氧离子被注入到衬底 高温热退火修复上层硅片的损伤 未被破坏的表面单晶硅层作为仔层外延生长一层单晶硅 缺点：会破坏上层单晶硅 Smart Cut 需要两个单晶硅衬底A和B，A衬底叫做seed wafer，B衬底叫做handle wafer 将A衬底氧化，形成BOX（buried oxide） 离子注入H+离子到氧化后的A衬底中 A衬底翻过来和B衬底粘合在一起（A的氧化层和B的Si粘合起来） 高温热退火，由于SiO2中的H+的存在使得A衬底部分松动脱落 CMP平坦化，减小上层硅的厚度 缺点：上层硅的厚度难以控制 典型的CMOS制造工艺流程 Front-end process，用来制造CMOS器件 Back-end process，用来制造器件之间的互连线 工艺集成中的一些原则 后续工艺不能影响已形成材料和掺杂结构的稳定，所以原则上讲后续工艺的温度要低于前面工艺 前面工艺的掺杂要尽可能采用扩散系数小的参杂元素 前面工艺要尽可能采用稳定的材料结构 要注意控制整个工艺集成过程的thermal budget，对于前歩工艺形成的掺杂结构，要把后步工艺对其杂质再分布的影响也考虑在内 要避免引入Na/K/Pt/Au等快扩散元素和重金属元素，实在不可避免时候（例如Cu作为互连材料），要注意设置阻挡层 CMOS集成电路的工艺集成 CMOS集成电路工艺集成 CMOS IC的基本工艺模块 阱，在衬底上形成的、参杂类型与硅衬底相反的区域 栅电极，双掺杂多晶硅栅工艺保持对称性 源漏结构，轻掺杂（LDD：Low Doping Drain）；源漏扩展结构（S/D Extension）；晕环（Halo）或袋状（Pocket）结构 自对准和接触，自对准指利用单一掩膜版在硅片上形成多层自对准结构；利用硅化物（TiSi2，CoSi2，NiSi2，WSi2）形成良好的欧姆接触，以减少串联电阻 一般CMOS工艺采用100晶向的硅 CMOS加工步骤 CMOS加工步骤 加工器件之间隔离所需要的STI（Shallow Trench Lsolation），目的是定义有源区（MOS器件工作的区域） 利用高能离子注入，分别为PMOS和NMOS器件制造p阱和n阱（Twin-well Implants），目的是使器件具有预期的阈值电压，同时抑制可能的穿通效应。做完N阱和P阱之后，需要对沟道进行掺杂，掺杂元素能够与需要的器件的阈值电压相匹配，同时整个沟道尽量不向下扩展（否则容易引起器件的穿通）。因此沟道掺杂包括：防穿通注入，调整阈值电压注入 制备超薄栅介质和光刻刻蚀多晶硅栅电极，工艺要求最高（光刻时候线条非常细，如22纳米工艺的栅宽只有22纳米，栅的厚度有几百个纳米，而且将来需要很陡直的刻蚀，并且能够停在几纳米的栅介质上） 利用栅掩蔽形成自对准的源漏轻掺杂区（LDD Implants），也叫源漏延伸（extension）区。为了进一步优化栅下沟道区的杂质分布，分别用光刻胶保护住PMOS区域和NMOS区域，采用大角度倾斜注入的办法分别对PMOS和NMOS栅的侧下方进行N型杂质和P型杂质的补充掺杂，目的是优化器件的串联电阻和防穿通性能 形成栅两侧的Si3N4 spacer层（Sidewall Spacer），首先淀积各向同性的氮化硅，然后RIE各向异性刻蚀，把栅和源漏表面的氮化硅刻蚀掉，保留栅侧面的氮化硅。Spacer层起到栅和源漏接触之间的绝缘 利用带Spacer层的栅作为掩蔽，来注入形成自对准的源漏接触掺杂区（S/D Implants） 制备自对准硅化物（如TiSi2），形成欧姆接触（Contact Formation） 形成多层金属互联 制作钝化层 I/O引出Pad Halo注入 形成多层金属互联 双极性集成电路的工艺集成 双极集成电路 优势：高速，驱动能力强 缺点：功耗大，集成度差 工艺 制作埋层 生长n型外延层 形成横向氧化物隔离区 形成基区 形成接触孔 形成发射区 金属化 合金化 形成钝化层 CMOS scaling中的若干问题 特征尺寸不断缩小的背后，伴随着新材料、新结构、新工艺不断的引入。 180nm：Saclicide中硅化物材料用CoSi2替代TiSi2 130nm：采用Cu布线替代Al布线 90nm：引入应变Si沟道；更多的采用NiSi；在Cu布线中引入Low-k介质 45nm：引入High-k栅介质；光刻版引入DFM（Design for manufacture） 32nm：引入浸润式光刻（Immersion） 22nm：光刻采用双曝光技术（DPT）；金属栅 14-16nm：放弃一直沿用的“平面器件结构”，引入FinFET（multi-gate）结构器件 Gate-last技术：为了避免源漏自对准注入之后的高温退火对金属栅和high-k介质的影响，采用先制备一个替代栅用于形成自对准源漏，之后再填充介质、CMP露出替代栅，腐蚀掉替代栅，并替换成金属栅 FinFET器件结构 平面结构MOS器件，栅控是在沟道一侧完成的，而FinFET的栅控是两侧同时进行的，这样在同样Cox下，它的栅控能力得到很大的改进 为什么14-16nm工艺代需要采用FinFET器件结构 对于20-22nm技术代，栅介质的EOT要降到0.4nm左右，即使采用HfO2高k介质，其物理厚度也仅1.6nm，已经接近了量子遂穿的极限，栅介质EOT的压力使得16nm以后需采用FinFET（multi-gate）器件结构 进一步Scaling Down的主要挑战 目前无法批量实现亚14nm的光刻分辨率：电子束光刻的速度太慢，无法满足量产，EUV光刻技术迟迟不能取得突破 随着尺寸缩小，沟道迁移率急剧下降，需要引进新的高迁移率沟道材料：在Si衬底上外延新材料已经相应的栅和源漏优化都是繁重的工作 需要采用更新的器件结构，一方面适应进一步提高器件栅控能力的要求，另一方面适应进一步降低器件电路工作电压的要求 可能的新沟道材料 NMOS器件沟道用化合物材料，如InAs PMOS器件沟道用Ge材料 基本的CMOS工艺 N阱离子注入 同时进行推进和氧化 去除氮化硅保护膜 制作AA区和LOCOS隔离 针对阈值电压调节的离子注入 栅极氧化以多晶硅栅制备 源漏分别做离子注入 ILD淀积保护膜，打通孔 布第一层金属，钝化膜 闩锁效应 闩锁效应是由NMOS的有源区、P衬底、N阱、PMOS的有源区构成的n-p-n-p结构产生的，当其中一个三极管正偏时，就会构成正反馈形成闩锁。 MOS工艺含有寄生的双极型晶体管。在CMOS工艺下，阱与衬底结合会导致寄生的n-p-n-p结构。这些结构会导致VDD和VSS线的短路，从而通常会破坏芯片，或者引起系统错误。 避免闩锁的方法就是要减小衬底和N阱的寄生电阻，使寄生的三极管不会处于正偏状态 防御措施： 在输入端和输出端加钳位电路，使输入和输出不超过不超过规定电压 芯片的电源输入端加去耦电路，防止VDD端出现瞬间的高压 在VDD和外电源之间加限流电阻，即使有大的电流也不让它进去 双阱工艺（Twin-Well） 传统的单阱工艺，器件部分需要8~10个Mask 现代的双阱工艺，器件部分需要9~10个Mask N阱掩膜 P阱掩膜 有源区掩膜 p场注入掩膜 耗尽型n管掩膜 多晶硅栅掩膜 n+源漏注入掩膜 p+源漏注入掩膜 接触孔掩膜 双阱cmos工艺采用p型硅晶圆片作为衬底，在衬底上做出N阱，用于制作PMOS晶体管，在衬底上做出p阱，用于制作nMOS晶体管。 相比单阱工艺，双阱工艺的优势：NMOS和PMOS能够单独做优化。但是双阱工艺占用面积更大，工艺更复杂 传统NPN BJT工艺流程（6~7个Mask） 埋层注入（n+），需要掩膜 n-Si外延层生长 氧化与guard ring隔离，需要掩膜 基区离子注入，需要掩膜 发射极和集电极离子注入，需要掩膜 形成基区，发射区，集电区的接触孔，金属的图形转移，需要掩膜 制作钝化层，需要掩膜 金属化，需要掩膜 自对准BJT工艺 高性能BJT结构 自对准BJT工艺 特点： 利用多晶硅做发射极，提高了器件性能 埋层集电极 自对准多晶硅基极 STI/LOCOS隔离 需要10~11层的Mask 器件密度不如CMOS，成本比CMOS高 主要用途： 射频器件，工作频率可以做到10~30GHz 大驱动能力的模拟器件 工艺 P-硅衬底上制作埋层集电极 n-Si外延层生长 LOCOS隔离 生长一层薄的氧化层，有源区图形化 淀积P+多晶硅，然后在上面淀积一层LTO 刻蚀，暴露有源区 制作侧墙spacer（先LTO在回刻） 淀积n+多晶硅，图形化后作为发射极 热退火，将重掺杂的n多晶硅和p多晶硅中的杂质扩散到衬底中形成发射区与基区 BiCMOS工艺（BJT+CMOS） 最复杂的工艺技术，不是市场主流，制约该工艺的瓶颈是BJT 需要约15层的Mask来制作器件 集成了CMOS低功耗的特点与BJT高速的特点 随着CMOS器件尺寸逐步减小，BiCMOS工艺的优势越来越弱 Device Scaling要求 沟道表面有一定的势垒，减小漏电流 更好的栅控能力（比如使用Multi-gate工艺） 方案： 增加Cox（降低tox或者使用high-k介质材料） 浅结（降低源漏对沟道的影响，增加栅对沟道的影响） 增加沟道参杂 问题 沟道的载流子散射增加了，降低了迁移率 可靠性降低了，器件变小，电场增加了，更容易击穿，可以通过降低电压来维持稳定性 浅结带来的源漏的寄生电阻的增加 短沟道器件结构 短沟道器件结构 为了抑制段沟道效应，采用了很多手段来优化栅极，源漏以及沟道的组成 栅极材料的选择 沟道掺杂表面浓度低，底下浓度高 halo-implant来避免沟道底部的本体穿通（阻挡S/D对沟道的影响，通过大角度的围绕着沟道的离子注入） 浅的源漏延伸 浅结 掺杂浓度低 降低了S/D串联电阻 LDD降低了耗尽区的电场强度，减少了热载流子影响，优化了源漏电场分布 倒退阱（Retro-grade Well） 一般的，沟道表面参杂浓度会更高，但是在倒退阱中，表面掺杂浓度低于沟道参杂浓度 这样会提高载流子迁移率，增加对闩锁效应和本体穿通的体抗力 制备手段 高能量的深离子注入 epi-wafer上的外延生长 栅介质材料 high-k介质材料通常使用的淀积工艺：ALD和MOCVD 通常high-k材料与Si的界面接触特性不好 High-k与金属的兼容性不好 High-k的热稳定性不好 要求high-k介质薄膜很薄 N+多晶硅栅与N+/P+多晶硅栅 N+多晶硅栅 使用广泛，因为工艺简单 在淀积多晶硅栅的同时原位重掺杂P元素 PMOSFETs需要阈值电压调节注入 问题（主要原因在于n+与n和n+与p的功函数差很大）： 大的漏电流 严重的本体穿通问题 P+/N+多晶硅栅 NMOS用N+多晶硅，PMOS用P+多晶硅 降低了漏电流和本体穿通的几率 对短沟道器件很有必要 源漏离子注入的同时可以进行多晶硅参杂，可以实现对称的沟道表面 问题 硼渗透问题，解决方法：多晶硅分层，SiO2中掺N 金属栅与High-k 多晶硅与high-k介质兼容性不好的原因： 多晶硅栅的电势降落导致EOT增大 多晶硅与high-k界面的不稳定性 双金属栅工艺 为了NMOS与PMOS的阈值电压对称，需要使用不同功函数的金属 MOS晶体管自对准工艺需要改进，变成：Gate-last 工艺 金属栅工艺流程 金属栅制备流程1 金属栅制备流程2 标准的STI隔离，双阱和沟道的掺杂 ALD一层high-k介质膜 LPCVD多晶硅牺牲层，并在两侧形成侧墙 源漏掺杂，并未PMOS的源漏外延生长SiGe层（给Si沟道引入压应力，空穴迁移率增加） 用应力的方式增强沟道迁移率，提高驱动电流，降低漏电流 SiGe外延属于异质外延，造成晶格错位 另外一种引入应力的方式是在NMOS外面包一层Si3N4，给沟道带来张应力，电子迁移率增加 CVD淀积氧化层，接着CMP平坦化 将多晶硅牺牲层刻蚀掉 选择性淀积PMOS的第一层金属（与P-si有小的功函数差） 淀积NMOS的第一层金属（与N-si有小的功函数差） 填充Al，然后平坦化","tags":[{"name":"Micromaching","slug":"Micromaching","permalink":"https://suda-morris.github.io/tags/Micromaching/"}]},{"title":"Coetex-M0 Introduction","date":"2015-10-06T04:23:50.000Z","path":"2015/10/06/cortex-m0-introduction/","text":"ARM体系变种 M变种： 长乘法操作：32位整数乘以32位整数，生成64位整数 长乘加操作：32位整数乘以32位整数，加上32位整数，生成64位整数 T变种： Thumb指令集是ARM指令集的一个子集重新编码而成的，它使ARM更加高效地进行运作 E变种： 增加了新的16位数据乘法与乘加操作指令 实现饱和的带符号数的加减法操作指令 进行双字数据操作的指令，包含LDRD、STDR、MCRR\\MRRC cache预取指令PLD J变种： Jazelle技术：将Java代码运行速度提高了8倍，功耗降低了80% SIMD变种： 可同时进行两个16位操作数或者4个8位操作数的运算 用户可以定义饱和运算模式 32位乘以32位的小数MAC 音频\\视频处理性能提高了4倍 提供小数算数运算 两套16位操作数的乘加\\乘减运算 ARM处理器系列 ARM7系列 小型、快速、低能耗、集成式的RISC芯片 冯诺依曼体系结构 三级流水线制 优秀的调试机制 ARM9、ARM9E系列 哈佛体系结构：这种体系结构是一种将程序指令存储和数据存储分开的存储器结构，是一种并行体系结构 支持32位的ARM指令和16位Thumb指令 支持一般的操作系统 五级流水处理及分离的Cache结构 ARM9E内核在ARM9内核的基础上增加了紧密耦合存储器的TCM及DSP部分 ARM10E系列 支持AMBA总线接口（包含AHB，ASB总线） 六级流水线制 包含DSP指令集 可选浮点协处理器 统一的数据cache和指令cache 能够支持多种商用操作系统 ARM11系列(ARM V6结构) 针对媒体处理的SIMD 用以提高安全性能的TrustZone技术 智能能源管理IEM 系统多处理技术 SecurCore系列 采用软内核技术 提供面前智能卡和低成本的存储保护单元 可集成用户自己的安全特性和其他处理器 极具安全性 Cortex系列处理器 ARM公司在经典处理器ARM11以后的产品改用Cortex命名，并分成A、R和M三类，旨在为各种不同的市场提供服务 A系列面向尖端的基于虚拟内存的操作系统和用户应用 R系列针对实时系统 M系列针对成本和功耗敏感的MCU和终端应用 Cortex-M0/M0+ CortexM0/M0+均是ARMv6M架构,均支持Thumb指令集，支持NVIC和WIC，但不支持Thumb2指令集，其中M0是三级流水线架构，M0+是二级流水线架构 CortexM3，CortexM4均是ARMv7M架构，均支持Thumb，Thumb2指令集，支持NVIC和WIC；CortexA5，CortexA8，CortexA9均是ARMv7A架构 存储器模型： ARM CortexM存储器模型 4GB可寻址线性空间 标准实现，适用于所有Cortex-M系列 无须paging和banking 软件访问可访问性 两种工作模式 Thread模式 Handler模式 异常模型 异常发生-&gt;加载向量列表-&gt;异常处理-&gt;返回 ARM Cortex-M0+寄存器 32位位宽寄存器： 13个通用寄存器： R0-R7（Low registers） R8-R12(High registers) 3个特殊用处寄存器 SP-R13，初始值：0x00000000 LR-R14 PC-R15，初始值0x00000004,Bit[0]为1，表示当前为Thumb代码 特殊寄存器 PSR（Program Status Register） PRIMASK（Interrupt mask register），仅有Bit[0],值为1表示关闭所有中断，只有NMI和硬件错误才能被响应，缺省值为0 CONTROL（control register），只有Bit[0]（定义权限级别，0表示特权级线程模式，1表示普通线程模式，所有的Handler模式都是特权级模式）和Bit[1]（选择当前使用哪个栈指针，0表示选择主栈指针MSP，1表示选择进程栈指针PSP） 寄存器使用方法 R0-R3：传递函数参数，返回函数结果，因此也称为a1-a4；也可用于程序内部保存临时变量 R4-R11：保存程序内部的变量值，因此又称为v1-v8，其中r9是个平台相关的寄存器，需要半导体厂商自己定义 R12-R15：专门用途寄存器，R12-IP 程序状态寄存器PSR APSR(Application Program Status Register)，包括Negative，Zero，Carry和Overflow的标志位 IPSR(Interrupt Program Status Register)，包括Exception number(前6位) EPSR(Execution Program Status Register)，包括Thumb code is executed的指示位 程序状态寄存器的访问指令：MSR和MRS ARM Cortex-M0+指令集 每条Thumb指令有相同处理器模型所对应的32位ARM指令，比如可以将Thumb指令ADD Rd，#immed_8转换为ARM指令ADD Rd，Rd，#immed_8 Thumb的56条指令分类： 存储器访问指令 ADR:Generate PC-relative address LDM:Load Multiple registers LDR{type}:Load Register using immediate offset LDR{type}:Load Register using register offset LDR:Load Register from PC-relative address POP:Pop register from stack PUSH:Push registers onto stack STM:Store Multiple registers STR{type}:Store Register using immediate offset STR{type}:Store Register using register offset 数据处理指令 分支和控制指令 B{cc}:Branch {conditionally},如果使用了条件执行，那么跳转范围在-256~254字节内；如果没有使用条件执行，那么跳转范围在±1M内 BL:Branch with Link,跳转范围±16MB BLX:Branch indirect with Link BX:Branch indirect 杂项指令 MRS:Move from special register to register MSR:Move from register to special register CPSID:Change Processor State,Disable Interrupts,C语言操作函数:void __disable_irq(void); CPSIE:Change Processor State,Enable Interrupts,C语言操作函数：void __enable_irq(void); WFE:Wait For Event,C语言操作函数：void __WFE(void); WFI:Wait For Interrupt,C语言操作函数：void __WFI(void); NOP:No Operation,C语言操作函数：void __NOP(void); SVC:Supervisor Call ARM Cortex-M0+外设 外设的映射 Private Peripheral Bus（PPB）的映射(0xE0000000-0xE00FFFFF) SysTick:24位计数器，扩展的NVIC特性 NVIC：中断设置与配置 SCB:提供系统实现和系统控制；包括配置、控制和上报系统异常 MPU（Memory Protection Unit） NVIC接口API： void NVIC_EnableIRQ(IRQn_t IRQn); void NVIC_DisableIRQ(IRQn_t IRQn); uint32_t NVIC_GetPendingIRQ(IRQn_t IRQn); void NVIC_SetPendingIRQ(IRQn_t IRQn); void NVIC_ClearPendingIRQ(IRQn_t IRQn); void NVIC_SetPriority(IRQn_t IRQn,uint32_t priority); uint32_t NVIC_GetPriority(IRQn_t IRQn); void NVIC_SystemReset(void);请求一次系统复位 ARM Cortex-M0+可执行镜像 ELF：定义了对象文件的内容和格式 BIN：直接的内存镜像 HEX：包含了目标程序镜像的存储地址 AXF：ARM工具链产生，BIN文件内容+调试信息 WEAK和alias属性 当两个或者两个以上行数具有相同的名字，并其中之一声明为weak属性时，则不会引发重定义错误。连接器会忽略弱属性的函数，而使用普通的函数来解析所有对这些符号的引用 如果普通的函数不可用时，连接器会使用weak属性的函数 alias属性：声明别名，当weak和alias属性连用时，可以声明弱别 错误异常 优先级仅次于复位和NMI 引起错误异常的来源： Memory访问异常 程序异常 错误异常分析： 错误异常分析 当异常发生时，处理器首先会保护现场，因此可以得到当前寄存器的值，以及异常发生前被压栈的寄存器的值 判断PC的返回值是否合法，存储器的访问地址是否正确，栈地址是否正确以及是否出现了溢出 访问PSR寄存器来获取当前处理器的状态信息 锁定 锁定（Lockup）的发生： 在处理NMI或者HardFault时产生错误异常 异常处理返回，当PSP出栈时，系统总线错误 锁定的退出： 复位 Debugger 锁定的预防： 尽量缩短NMI和HardFault异常的处理时间 在进入HardFault异常处理前，添加汇编代码，检查SP指针","tags":[{"name":"ARM","slug":"ARM","permalink":"https://suda-morris.github.io/tags/ARM/"}]},{"title":"W7500 Introduction","date":"2015-10-04T14:51:33.000Z","path":"2015/10/04/w7500/","text":"WIZwiki-W7500平台介绍 W7500单芯片解决方案：ARM Cortex-M0，48MHz，128KB Flash，16KB RAM，硬件TCP/IP内核，32KB TCP/IP专属RAM，MII接口，8个socket 程序下载方法： CMSIS-DAP USB下载 利用串口的ISP固件下载方式(按住boot键不放，按一下sw键进入boot模式) SWD(Serial Wire Debug)调试 2路SPI接口，2路I2C接口，3路UART接口，8路ADC(12bit，1Msps)，6路DMA控制器，1个32位的RNG（随机数生成器） 外部PHY芯片：IP101GA 支持自动MDI / MDIX功能以简化网络的安装以及降低系统维护成本，即自动识别交叉线与直连线 提供媒体独立接口（MII）或简化媒体独立接口（RMII）与不同类型的10/100Mbps的媒体访问控制器（MAC）连接 支持MDC和MDIO与MAC沟通 CMSIS-DAP实现芯片：LPC11U35FHI33/501 CMSIS-DAP功能： 通过USB烧写固件到W7500 利用W7500的UART1，通过USB接口与外界进行串口通讯（PC端需要安装驱动，驱动安装成功后会虚拟出串口名如：mbed Seral Port(COMn)） 开发板框图： 板子框图 W7500芯片框图： W7500芯片框图 MII MII即媒体独立接口，也叫介质无关接口，它是IEEE-802.3定义的以太网行业标准，它包括一个数据接口，以及一个MAC和PHY之间的管理接口,MAC与PHY间的管理接口一般是MDIO 数据接口包括分别用于发送器和接收器的两条独立信道，每条信道都有自己的数据、时钟和控制信号。 管理接口是个双信号接口：一个是时钟信号，另一个是数据信号。通过管理接口，上层能监视和控制PHY MII数据接口总共需要16个信号： MII接口 Tx_CLK/Rx_CLK：分别是Tx和Rx的时钟信号。均由PHY驱动 TxD[0···3]/RxD[0···3]：分别是Tx和Rx的数据传输线。TxD是控制器驱动，RxD是PHY驱动 Tx_EN/Rx_DV：分别是Tx和Rx的开关。这两根线都是PHY驱动。只有在Tx_EN有效时，TxD才会被PHY接收；只有在Rx_DV有效时，RxD才会被控制器接收 Tx_ER/Rx_ER：分别是Tx和Rx的报错线。这两根线都是PHY驱动。即使是在Tx_EN或Rx_DV期间，只要此两根线有效，则出错的那个周期所传数据无效。10Mb以太网传输时，ER信号不影响正常传输，若不使用ER线，需将其接地 CRS/COL：监听介质是否空闲/监听是否有冲突发生。这两根线都是由PHY驱动，并且只在半双工模式下有效 MII控制接口：MDC和MDIO。通过它，控制芯片可以访问PHY的寄存器(100M物理层芯片中介绍的寄存器组，但不仅限于100M物理层芯片，10M物理层芯片也可以拥有这些寄存器)，并通过这些寄存器来对物理层芯片进行控制和管理 MDC：管理接口时钟。它是由控制器驱动，与TX_CLK和RX_CLK无任何关系 MDIO：用来传送MAC层的控制信息和物理层的状态信息。它是一根双向的数据线。因MDIO在某个时钟周期内会空闲，呈高阻状态，故使用时须将其上拉 事实上，一个控制器，可以通过Management Interface来管理32个PHY。即，MDC和MDIO是可以复用的。 MAC主要是通过MDIO（以MDC为时钟）来读写PHY的寄存器，MDIO上数据帧的格式如下： MDIO上数据帧的格式 数据开始前，会发32个1，然后数据开始时先发送一个0，然后恢复到1；接下来两位，10表示读，01表示写；紧接着的5为是PHY地址；下面5位是寄存器地址；接下来两位表示状态转换域，若为读操作，则第一比特时MDIO为高阻态，第二比特时由物理层芯片使MDIO置“0”。若为写操作，则MDIO仍由MAC层芯片控制，其连续输出“10”两个比特。;接下来是16位的数据；空闲时线上为高阻 以前的10M的MAC层芯片和物理层芯片之间传送数据是通过一根数据线来进行的，其时钟是10M，在100M中，如果也用一根数据线来传送的话，时钟需要100M，这会带来一些问题，所以定义了MII接口，它是用4根数据线来传送数据的，这样在传送100M数据时，时钟就会由100M降低为25M，而在传送10M数据时，时钟会降低到2.5M，这样就实现了10M和100M的兼容。 MII接口的MAC模式定义： MII接口MAC模式 MII接口PHY模式定义： MII接口PHY模式 在MII接口的连线中，如果TX_ER信号线没有用到，必须将它下拉接地。 RXD_DV同步于RX_CLK，被PHY驱动，它的作用如同于发送通道中的TX_EN，不同的是在时序上稍有一点差别：为了让数据能够成功被RS接收，要求RXD_DV有效的时间必须覆盖整个FRAME的过程 MDC：管理接口的时钟，它是一个非周期信号，信号的最小周期（实际是正电平时间和负电平时间之和）为400ns，最小正电平时间和负电平时间为160ns，最大的正负电平时间无限制。它与TX_CLK和RX_CLK无任何关系。 MDIO是一根双向的数据线。用来传送MAC层的控制信息和物理层的状态信息。MDIO数据与MDC时钟同步，在MDC上升沿有效。 MDIO数据帧的时序关系： MDIO数据帧的时序关系 MII接口也有一些不足之处，主要是其接口信号线很多，发送和接收和指示接口有14根数据线(不包括MDIO接口的信号线，因为其被所有MII接口所共享)，当交换芯片的端口数据较多时，会造成芯片的管脚数目很多的问题，这给芯片的设计和单板的设计都带来了一定的问题。为了解决这些问题，人们设计了两种新的MII接口，它们是RMII接口(Reduced MII接口)和SMII接口(StreamMII接口)。这两种接口都减少了MII接口的数据线，不过它们一般只用在以太网交换机的交换MAC芯片和多口物理层芯片中，而很少用于单口的MAC层芯片和物理层芯片中。RMII接口和SMII接口都可以用于10M以太网和100M以太网，但不可能用于1000M以太网，因为此时时钟频率太高，不可能实现。 中断和事件 W7500包含26路中断请求IRQ，一个非屏蔽中断NMI，一个事件信号 W7500可以处理内部事件以唤醒内核（WFE），唤醒事件可以通过如下方式产生： DMA进程完成之后 供电 W7500内部嵌入一个稳压器来提供内部1.5V的电压，稳压器没有掉电模式或者休眠模式 ADC参考电压和VDD相同 W7500在系统或电源复位后会处于工作模式，当CPU停止工作时可以采用两种低功耗模式(W7500没有掉电模式)：休眠模式(Sleep)和深度休眠(Deep Sleep) 休眠模式仅仅关闭了CPU时钟，总线时钟依旧开启，深度休眠模式中总线时钟和存储器时钟都被关闭 TOE TCP/IP卸载引擎(TOE)是一个嵌入式全硬件TCP/IP以太网控制器，它可以提供更简洁的嵌入式网络接入方案。TOE提供WOL(网络唤醒)功能可以大大降低系统功耗 TOE框图： TOE区域框图 NCONFLR（网络配置锁存寄存器）用来锁定和解锁对网络配置寄存器(SIR,SUBR,GAR和SHAR)的访问。当LOCK处于ON，受保护的寄存器无法进行配置，在这种情况下，写入NCONFLR寄存器的值是0x01ACCE55，当LOCK处于OFF，受保护的寄存器可以进行配置，这是该寄存器的值为非0x01ACCE55的其他任意值。 TCKCNTR(Ticker计数寄存器)，用于向TOE内部定时器提供100us的Ticker计数。Ticker计数器单元是HCLK 启动顺序 W7500有三种不同的启动模式，可以通过BOOT引脚和TEST引脚选定。TEST=0，BOOT=0，在主Flash存储器中执行用户代码；TEST=0，BOOT=1，W7500支持ISP功能以便于用串口控制flash 存储器 Flash存储器由长度为32为宽的存储单元构成，可以用于存储代码或者数据 存储器的构成基于一个主Flash存储器块，包含256字节的512扇区，或者4KB的32个块。块和扇区停工读/写保护 时钟复位发生器CRG CRG包括PLL和POR 三种类型的复位： 外部复位，上电复位，系统复位 系统复位是当下面的情况发生时产生复位： 看门狗事件 重映射之后 软件复位(在Cortex-M0的SYSRESETREQ为) 两种时钟源可以用来驱动系统时钟： 外部振荡器时钟(8MHz~24MHz)(OCLK) 内部8MHz RC振荡器(RCLK) RNGCLK只有一个源(pll输出)并且没有预分频器 CRG框图： CRG框图 监视时钟源： 监视引脚：PA_02 配置寄存器：MONCLK_SSR 随机数发生器RNG RNG是一个32位随机数发生器，当上电复位时，RNG会产生一个上电随机数，RNG可以通过软件来运行/停止。RNG的初始值和多项式值可以通过软件来更新 外部中断 不管任何功能引脚功能设置，功能引脚都可以被用作一个外部中断源 外部中断控制器的中断极性分为上升沿和下降沿 Pad控制器 W7500具有数字I/O功能引脚和数字/模拟多路复用I/O功能引脚，功能引脚的可控性特性包括上拉，下拉，驱动强度，输入开启和CMOS/Schmitt触发输入缓存 GPIO 屏蔽寄存器可将端口位视为整体而其他位不变 访问屏蔽功能允许一位或者多位在单向传输过程中读或写，这避免了基于软件的读-修改-写操作的非线程安全问题。有了访问屏蔽操作，16-bit I/O被分成两半，低字节和高字节，这个位被定义为两个数组，每一个包含256字节 UART 发送的数据存储在一个32字节的FIFO中，将需要发送的数据写入发送FIFO中，如果UART被启用，它会按照UARTxLCR_H只是的参数开始发送数据帧。数据会持续发送，直到发送FIFO为空。当有数据被写入发送FIFO或当前处于发送的过程中时，UARTxFR的BUSY位会保持为“1”，表示FIFO中有数据。 接收的数据存储在一个32字节的FIFO里面。当接收到一个起始位，它开始运行，并对UART模式中计数器的第8个周期进行采样。如果UARTRXD为“1”，证实接收到了有效的停止位。当一个完整的字符数据被接收到，数据会被存储在接收FIFO中。错误位会被存储在UARTxCR的【10：8】位置，溢出的被存储在UARTxCR的【11】位 更改UART控制寄存器的步骤： 禁用UART 等待接收到或者发送完最后的字符 设置行控制寄存器中FEN位为0，从而刷新发送FIFO 更改UARTCR寄存器 使能UART W7500有个Simple Uart，其实就是UART2，用来ISP烧写程序的，一般用户不直接拿来使用 uDMAC 共6个通道，每个通道用于管理来自某个或者多个外设的内存访问请求 不要给一个第优先级的 通道分配大不要给一个低优先级的通道分配大的R_power值，因为直到重仲裁之前来自控制器高优先级的请求都会被阻止 当N&gt;2^R，并且不是2^R的整数倍时，控制器总是会执行2^R的传输序列，直到N&lt;2^R时再传输，控制器会在DMA周期的末尾，再执行剩余N次传输 DMA周期类型： Invalid Basic Auto-request ping-pong Ping-pong cycle DMA控制器轮流切换主、副两个数据通道，直到接收到一个无效的数据结构或者是circle_type被设置成了basic模式，或者是控制器停止了该通道的工作 当DMA使用其中一个通道进行数据传输时候，处理器可以重新配置另外一个通道的参数 SSP SSP接口可以同具有以下接口的主句或者从机进行通讯 摩托罗拉SPI接口 TI的同步串行接口 国家半导体的Microware接口 SSP接口可作为主机或者从机接口，支持2MHz甚至更高的位速率 PrimeCell SSP复位之后默认是禁用状态，需要按照以下步骤进行配置： 更改SSP控制器SSPCR0和SSPCR1来配置SSP接口外设的主从工作模式以及工作的协议标准：Motorola SPI，Texas Instruments SSP，National Semiconductor 通过更改时钟预分频寄存器SSPCRSR来将外部SSPCLK时钟进行分频，从而可以更改位速率 有两种方法可以启动PrimeCell SSP： 激活发送FIFO：Prime Cell SSP禁用时，可以通过写入8个16位值发送FIFO 通过发送FIFO服务请求到CPU中断 在从机模式的操作中，为了确保正确的操作，SSPCLK必须必预期的SSPCLKIN最快频率快12倍；在主机模式的操作中，为了确保正确的操作，SSPCLK必须为预期的SSPCLKOUT最快频率的2倍。 SSPCLK的最低频率可以通过下列公式计算，两个条件必须同时被满足： FSSPCLK(min) &gt;= 2 x FSSPCLKOUT(max), for master mode FSSPCLK(min) &gt;= 12 x FSSPCLKIN(max), for slave mode. SSPCLK的最高频率可以通过下列公式计算，两个条件必须被同时满足： FSSPCLK(max) &lt;= 254 x 256 x FSSPCLKOUT(min), for master mode FSSPCLK(max) &lt;= 254 x 256 x FSSPCLKIN(min), for slave mode. SSPCR0寄存器被用来： 编写穿行时钟速率 在三个协议模式中进行选择 选择合适的数据长度 SSPCR1寄存器被用来： 选择主/从模式 启用loopback回环测试功能 启用PrimeCell SSP外设 位速率的产生 串行位速率通过将输入时钟SSPCLK分频获得。首先，使用范围在2~254的偶数分频值CPSDVSR对输入时钟进行分频，CPSDVSR的值在SSPCPSR寄存器中设置。然后再使用1~256的其中一个值（即1+SCR）对时钟进一步分频T，此处SCR在SSI控制SSPCR0寄存器中设置。 帧格式：根据所设置的数据大小，每个数据帧的长度均在4~16位之间，并且从最高有效位MSB开始发送。 德州仪器（TI）同步串行的帧格式 在该模式中，任何时候当SSP空闲时，SSPCLKOUT和SSPFSSOUT被强制为低电平，发送数据线SSPTx为三态。一旦发送FIFO的底部入口包含数据，SSPFSSOUT就会变为高电平并持续一个SSPCLKOUT周期。要发送的值也从发送FIFO传输到发送逻辑的穿行移位寄存器中 Motorola SPI的帧格式 4线接口，其中SSPFSSOUT信号用作从机选择。Motorola SPI格式的主要特性为：SSPCLKOUT信号的不活动状态和相位均通过SSPSCR0控制寄存器中的SPO和SPH来设置。 SPO，时钟极性位。当SPO时钟极性控制位为低时，它在SSPCLKOUT管脚上产生稳定的低电平值。如果SPO位为高，则在没有进行数据传输的情况下，在SSPCLKPUT管脚上产生一个稳定的高电平值。 SPH，相位控制位。SPH相位控制位用来选择捕获数据的时钟边沿并允许边沿改变状态。SPH在第一个传输位上的影响最大，因为它可以在第一个数据捕获边沿之前允许或不允许一次时钟转换。当SPH相位控制位为低时，在第一个时钟边沿转换时捕获数据。如果SPH位为高，则在第二个时钟边沿转换时捕获数据 National Semiconductor帧格式 National Semiconductor格式与SPI格式非常相似，不同的是其采用的是使用主-从消息传递技术的半双工模式而非全双工模式。 此穿行传输都由PrimeCell SSP向片外从器件发送8位控制字开始。在此传输过程中，PrimeCell SSP不会接收到输入的数据，在消息发送完毕后，片外从机对消息进行译码，并在PrimeCell SSP将8位控制消息的最后一位发送完成之后等待一个串行时钟周期，之后从机以请求的数据来响应。 I2C 支持标准模式100Kbps和高速模式400Kbps SDA是双向的串行数据线，SCL是双向的串行时钟线。总线空闲时，这两根线都为高。每次操作都是9位，包括8个数据位和1个应答位，并且发送数据前必须先传输MSB 数据有效性：在时钟的高电平周期期间，SDA线上的数据必须保持稳定，SDA线上的数据仅可在时钟SCL为低电平时改变。 所有总线传输都带有所需的应答时钟周期，该时钟周期由主机产生。在相应周期内，发送器不能执行下一操作 I2C开始条件和结束条件 当SCL为高电平时，SDA线上由高到低的跳变被定义为开始条件，由低到高的跳变被定义为结束条件 开始条件和结束条件总是由主机产生 I2C总线在结束条件之后一段时间重新被释放。如果使用重新开始条件替代结束条件的话，I2C将会保持占用状态 放到SDA线上的每个数据字节应该都是8位，每个字节之后跟随一个应答位。 7位地址之后的第8位是数据方向位（R/W）,0代表写操作，1代表读操作 每个字节之后都有一个应答位，应答位可以使接收者在成功接收到本字节之后，告诉发送者此数据已经被成功接收，可以发送下个字节。主机产生所有的时钟脉冲，包括应答位(第9位)的时钟脉冲 W7500P芯片介绍 IOP4IoT（Internet Offload Processor for Internet of Things）芯片，集成ARM Cortex-M0，128KB Flash，硬件TCP/IP内核，10/100M 以太网MAC与PHY，PHY符合IEEE802.3u标准，硬件TCP/IP核支持TCP、UDP、IPv4、ICMP、ARP、IGMP和PPPoE CPU最大支持48MHz的工作频率 硬件TCP/IP核支持8个套接字，总共可以使用32KB的专用内存，物理层与数据链路层的通信接口符合MII PHY实际上是内嵌了IC+（IP101G）芯片 除了32KB的Socket专用内存外，还有16KB的通用内存 有6KB的ROM存放boot代码 内部8MHz的RC振荡器 8路12位的ADC，采样速率1Msps 6通道DMA控制器 1路看门狗（32位的向下计数器），4路定时器（32位或者16位的下降计数器），8路PWM控制器（32位计数器，其中6位为可编程的预分频器） 3路串口（其中两路带有FIFO与流控，另一个是简单串口），2路SPI，2路I2C（主从模式均可，最大支持400Kbps） 1个伪随机数产生器 程序内存，数据内存，寄存器和IO口统一被组织在4G的线型地址空间中，所有字节按照小端格式编写 当上电时BOOT引脚和TEST引脚都为低电平时，系统进入正常工作模式；当BOOT引脚为高电平，TEST引脚为低电平，系统进入Boot模式（ISP下载） 支持25路中断请求，1路非屏蔽中断，一路内部事件信号请求（当DMA传输结束后会触发） VDD电压范围：2.7V~5.5V，ADC的参考电压同VDD W7500P没有power-off模式，但是有Sleep和Deep Sleep模式,Sleep模式仅停止PCU工作，Deep Sleep模式还会切断所有外设的时钟 W7500P内存映射图 SYSCFG(System Configuration Controller)的主要功能 控制内存重映射 可以使能系统锁死后自动复位 保存着最近一次系统复位的原因信息 suda-morris","tags":[{"name":"W7500","slug":"W7500","permalink":"https://suda-morris.github.io/tags/W7500/"}]},{"title":"Javascript Basic","date":"2015-09-28T04:20:50.000Z","path":"2015/09/28/javascript/","text":"==与===的区别 对于string,number等基础类型，==和===是有区别的 不同类型间比较，==之比较“转化成同一类型后的值”看“值”是否相等，===如果类型不同，其结果就是不等 同类型比较，直接进行“值”比较，两者结果一样 对于Array,Object等高级类型，==和===是没有区别的 进行“指针地址”比较 基础类型与高级类型，==和===是有区别的 对于==，将高级转化为基础类型，进行“值”比较 因为类型不同，===结果为false 事件 常用事件 onClick单击事件 onMouseOver鼠标经过事件 onMouseOut鼠标移出事件 onChange文本内容改变事件 onSelect文本框选中事件 onFocus光标聚集事件 onBlur移开光标事件 onLoad网页加载事件 onUnload关闭网页事件 事件冒泡 由最具体的元素接收，然后逐级向上传播至最不具体的元素的节点(文档) 事件捕获 最不具体的节点先接收事件，而最具体的节点应该是最后接收事件 事件处理 HTML事件处理 直接添加到HTML结构中 DOM0级事件处理 把一个函数赋值给一个事件处理程序 同一个元素多个事件会被覆盖，只有最后一个事件起作用 DOM2级事件处理 addEventListener(“事件名”，“事件处理函数”，“布尔值”)； true：事件捕获 false：事件冒泡 removeEventListen(); IE事件处理程序(IE8及以下) attachEvent detachEvent 事件对象 在触发DOM事件的时候都会产生一个对象 事件对象event type：获取事件类型 target：获取事件目标 stopPropagation()；阻止事件冒泡 preventDefault()；阻止事件默认行为(比如超链接) DOM对象 当网页被加载时，浏览器会创建页面的文档对象模型(Document Object Model) DOM对象模型 DOM操作HTML 改变HTML输出流： 注意，绝对不要在文档加载完成后使用document.write(),这会覆盖该文档 寻找元素： 通过id找到HTML元素,document.getElementById(); 通过标签名找到HTML元素,document.getElementByTagName(); 改变HTML内容 使用属性：innerHTML 改变HTML属性 使用属性：attribute，例如：document.getElementById(&quot;aid&quot;).href=&quot;http://www.baid.com&quot;; 常用方法： getElementsByName();获取name getElementsByTagName();获取元素 getAttribute();获取元素属性 setAttribute();设置元素属性 childNodes();访问子节点 parentNode();访问父节点 createElement();创建元素节点 createTextNode();创建文本节点 insertBefore();插入节点 removeChild();删除节点 offsetHeight;网页尺寸,例如：var width=document.body.offsetWidth; crollHeight;网页尺寸 创建节点示例 var body=document.body;var input=document.creatElement(&quot;input&quot;);input.type=&quot;button&quot;;input.value=&quot;按钮&quot;；body.appendChild(input); DOM操作CSS 基本语法：document.getElementById(id).style.property=new style; DOM操作事件句柄 addEventListener();向指定元素添加事件句柄 removeEventListener();移出方法添加的事件句柄 内置对象 String对象 字符串可以使用使用单引号或者双引号 获取字符串长度：length属性 在字符串中查找字符串的方法：indexOf(),成功返回位置，失败返回-1 内容匹配的方法：match(),成功返回匹配成功的字符串，失败返回空 替换内容的方法：replace() 字符串大小写转换：toUpperCase()/toLowerCase() 字符串转为数组：split Date对象 常用方法： getFullYear():获取年份 getTime():获取毫秒 setFullYear():设置具体的日期 getDay():获取星期 Array数组对象 数组的创建 var myArray=[&quot;Hello&quot;,&quot;iwen&quot;,&quot;ime&quot;]; 数组的访问 通过指定数组名以及索引号码(下标从0开始)，可以访问某个特定的元素 常用方法 concat();合并数组 sort();排序 push();末尾追加元素 reverse();数组元素翻转 Math对象 常用方法 round():四舍五入;例如Math.round(2.5)等于3 random();返回0~1之间的随机数;例如parseInt(Math.random()*10); max();返回最高值 min();返回最低值 abs();返回绝对值 浏览器对象 Window对象 window对象时BOM的核心，window对象指当前的浏览器窗口。所有JavaScript全局对象，函数以及变量均自动成为window对象的成员；全局变量是window对象的属性，全局函数是window对象的方法，甚至HTML DOM的document也是window对象的属性之一 window.innerHeight:浏览器窗口的内部高度 window.innerWidth:浏览器窗口的内部宽度 window.open(“url”，“windowname”，“style”):打开新的网页 计时器 方法 setInterval();间隔指定的好描述不同的执行指定的代码 clearInterval();停止setInterval()方法执行的函数代码 setTimeout();暂停指定的毫秒数后执行指定的代码 clearTimeout();停止之慈宁宫setTimeout()方法的函数代码 History对象 history.back()与在浏览器中点击后退按钮相同 history.forward()与在浏览器中点击向前按钮相同 history.go()进入历史中的某个页面 Location对象 location对象用于获得当前页面的地址(URL)，并把浏览器重定向到新的页面 属性与方法 location.hostname返回web主机的域名 location.pathname返回当前页面的路径和文件名 location.port返回web主机的端口 location.protocol返回所使用的web协议(http://或https://) location.href返回当前页面的URL location.assign()加载新的文档 Screen对象 属性 screen.availWidth可用的屏幕宽度 screen.availHeight可用的屏幕高度 screen.Height屏幕高度 screen.Width屏幕宽度 面向对象使用闭包以及function来模拟类1234567891011121314151617181920212223242526272829303132(function () &#123; function People(name, age) &#123; this._name = name; this._age = age; &#125; People.prototype.say = function () &#123; alert(\"People:Hello \" + this._name + \",\" + this._age + \" years old\"); &#125; window.People = People;&#125;());(function () &#123; function Student(name, age, grade) &#123; this._grade = grade; this._name = name; this._age = age; &#125; Student.prototype = new People(this._name,this._age); var superSay = Student.prototype.say; Student.prototype.say = function () &#123; superSay.call(this); alert(\"Student:Hello \" + this._name + \",\" + this._age + \" years old\" + \",Grade: \" + this._grade); &#125; window.Student = Student;&#125;());var stu = new Student(\"morris\",20,\"one\");stu.say(); AJAX AJAX(Asynchronous Javascript And XML) 编程模板 创建XMLHttpRequest对象 open操作初始化请求信息 监听事件处理响应结果 send操作发出请求 创建各浏览器兼容的XMLHttpRequest对象 1234567891011121314151617function creatXHR() &#123; var xhr = null; if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123; try &#123; xhr = new ActiveXObject('Msxml2.XMLHTTP'); &#125; catch (e) &#123; try &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; catch (e) &#123; &#125; &#125; &#125; return xhr;&#125; 发送请求信息 get方法 xhr.open(&quot;GET&quot;,&quot;http://test/keyword/hit?keyword=c&quot;,true); xhr.send(); post方法 xhr.open(&quot;POST&quot;,&quot;http://test/keyword/hit&quot;,true); xhr.send(&quot;keyword=c&quot;); 设置请求头信息 xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/json&quot;); xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); 响应的接收与请求 12345678910xhr.onreadystatechange = function(e)&#123; if(xhr.readyState ==4 &amp;&amp; xhr.status == 200)&#123; console.log(xhr.responseText); console.log(xhr.responseXML); console.log(xhr.getAllResponseHeaders()); console.log(xhr.getResponseHeader(\"Content-Type\")); console.log(xhr.status); console.log(xhr.statusText); &#125;&#125; 将Json字符串转换成Json对象： JSON.parse(xhr.responseText); eval(xhr.responseText); 设计模式 设计原则 开闭原则：对扩展开放，对修改关闭 里氏转换原则：子类继承父类，单独调用完全可以运行 依赖倒转原则：引用一个对象，如果这个对象有底层类型，直接饮用底层 接口隔离原则：每一个接口应该是一种角色 合成/聚合复用原则：新的对象应使用一些已有的对象，使之成为新对象的一部分 迪米特原则：一个对象应对其他对象有尽可能少的了解 单例模式 jQuery jQuery库可以通过一行简单的标记被添加到网页中 jQuery是一个JavaScript函数库 jQuery库包含的功能: HTML元素选取 HTML元素操作 CSS操作 HTML事件函数 JavaScript特效和动画 HTML DOM遍历和修改 AJAX Utilities 从CDN中载入jQuery，例如：http://libs.baidu.com/jquery/1.10.1/jquery.min.js 基础语法： $(selector).action() 美元符号定义jQuery 选择符selector“查询”和“查找”HTML元素 jQuery的action()执行对元素的操作 例如： $(this).hide()隐藏当前元素","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://suda-morris.github.io/tags/Javascript/"}]},{"title":"CSS Basic","date":"2015-09-27T02:51:00.000Z","path":"2015/09/27/css/","text":"基础语法 selector{property:value}其中selector有派生选择器，id选择器，类选择器，属性选择器 头部声明&lt;link href=&quot;MyCSS.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt; id选择器 id选择器可以为标有id的HTML元素指定特定的样式 id选择器以“#”来定义 类选择器 类选择器以一个点来定义 属性选择器 &lt;style type=&quot;text/css&quot;&gt; [title=te]{color:blue}&lt;/style&gt; &lt;p title=&quot;te&quot;&gt;属性选择器&lt;/p&gt; CSS背景 background-attachment:背景图像是否固定或者随着页面的其余部分滚动 background-color:设置元素的背景颜色 background-image:把图片设置为背景，url(“bg.jpg”) background-position:设置背景图片的起始位置 background-repeat:设置背景图片是否及如何重复 background-size:规定背景图片的尺寸 background-origin:规定背景图片的定位区域 background-clip:规定背景的绘制区域 CSS文本 color：文本颜色 direction：文本方向 line-height：行高 letter-spacing：字符间距 text-align：对齐元素中的文本 text-decoration：向文本中添加修饰 text-indent：缩进元素中文本的首行 text-transform：元素中的字母 unicode-bidi：设置文本方向 white-space：元素中空白的处理方式 word-spacing：字间距 text-shadow:文本阴影 word-wrap:规定文本的换行规则 CSS字体 font-family:设置字体系列 font-size:设置字体的尺寸 font-style:设置字体风格 font-variant:以小型大写字体或正常字体显示文本 font-weight:设置字体的粗细 CSS链接 CSS链接的四种状态： a:link 普通的、未被访问的链接 a:visited 用户已经访问的链接 a:hover 鼠标指针位于链接的上方 a:active 链接被点击的时刻 常见的链接样式： text-decoration属于大多用于去掉链接中的下划线 CSS列表 list-style简写列表项 list-style-image列表项图像 list-style-position列表标志位置 list-style-type列表类型 CSS表格1234567891011121314151617#tb&#123; border-collapse:collapse; width:500px;&#125;#tb td,#tb th&#123; border:1px solid bisque; padding:5px;&#125;#tb th&#123; text-align:right; background-color:aqua; color:#FFFFFF;&#125;#tb tr.alt td&#123; color:black; background-color:aquamarine;&#125; CSS轮廓 outline设置轮廓属性 outline-color设置轮廓的颜色 outline-style设置轮廓的样式 outline-width设置轮廓的宽度","tags":[{"name":"CSS","slug":"CSS","permalink":"https://suda-morris.github.io/tags/CSS/"}]},{"title":"HTML5 Basic","date":"2015-09-25T14:26:00.000Z","path":"2015/09/25/html5/","text":"基础 声明：&lt;!DOCTYPE&gt; HTML有多个不同版本，只有完全明白页面中使用的确切的HTML版本，浏览器才能完全正确地显示出HTML页面 HTML5： &lt;!DOCTYPE html&gt; 元素：指的是从开始标签到结束标签的所有代码 &lt;p&gt; this is my web page &lt;/p&gt;中的this is my web page就是元素内容 &lt;br/&gt;表示不含任何元素的空标签，即换行 空元素在开始标签中进行关闭 大多数的HTML元素可拥有属性 属性 属性以键值对的形式出现 常用标签属性 &lt;h1&gt;:align对齐方式 &lt;body&gt;:bgcolor背景颜色 &lt;a&gt;:target规定在何处打开连接 通用属性 class：规定元素的类名 id：规定元素唯一ID style：规定元素的样式 title：规定元素的额外信息 格式化 &lt;b&gt;定义粗体文字 &lt;big&gt;定义大号文字 &lt;em&gt;定义着重文字 &lt;i&gt;定义斜体文字 &lt;small&gt;定义小号文字 &lt;strong&gt;定义加重语气 &lt;sub&gt;定义下标文字 &lt;sup&gt;定义上标文字 &lt;ins&gt;定义插入字 &lt;del&gt;定义删除字 样式 标签 &lt;style&gt;:样式定义 &lt;link&gt;:资源引用 属性 rel=&quot;stylesheet&quot;：外部样式表 type=&quot;text/css&quot;:引入文档的类型 margin-left:边距 三种样式表插入方法： 外部样式表：&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt; 内部样式表：&lt;style type=&quot;text/css&quot;&gt;body{background-color:red} p{margin-left:20px}&lt;/style&gt; 内联样式表：&lt;p style=&quot;color:red&quot;&gt; 链接 标签： 连接数据：文本链接，图片链接 属性： href属性：指向另一个文档的链接 name属性：创建文档内的链接 &lt;a name=&quot;tips&quot;&gt;hello&lt;/a&gt; &lt;a href=&quot;#tips&quot;&gt;跳转&lt;/a&gt; img标签属性 alt：替换文本属性 width：宽 height：高 表格 标签 &lt;table&gt;：定义表格,属性border定义边框大小，属性cellpadding定义单元格边距，属性cellspacing定义单元格间距，属性bgcolor定义表格背景色，属性background定义表格图片 &lt;caption&gt;：定义表格标题 &lt;th&gt;：定义表格表头 &lt;tr&gt;：定义表格的行 &lt;td&gt;：定义表格的单元,属性colspan的值定义了要合并的单元格数目 &lt;thead&gt;：定义表格的页眉 &lt;tbody&gt;：定义表格的主题 &lt;tfoot&gt;：定义表格的页脚 &lt;col&gt;：定义表格的列属性 列表 标签 &lt;ol&gt;：有序列表，type属性值A,a,I ,i,start &lt;ul&gt;：无序列表，type属性值disc,circle,square &lt;li&gt;：列表项 &lt;dl&gt;：自定义列表 &lt;dt&gt;：自定义列表项 &lt;dd&gt;：自定义列表描述 块 HTML块元素 块元素在显示时，通常会以新行开始，比如&lt;h1&gt;,&lt;p&gt;,&lt;ul&gt; HTML内联元素 内联元素通常不会以新行开始，比如&lt;b&gt;,&lt;a&gt;,&lt;img&gt; HTML&lt;div&gt;元素 &lt;div&gt;元素也被称称为块元素，其主要是组合HTML元素的容器 HTML&lt;span&gt;元素 &lt;span&gt;元素是内联元素，可作为文本的容器 使用div元素布局 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;html布局测试&lt;/title&gt; &lt;style type=\"text/css\"&gt; body &#123; margin: 0; &#125; div#page &#123; background-color: gray; width: 100%; height: 950px; &#125; div#head &#123; background-color: red; width: 100%; height: 10%; &#125; div#left &#123; background-color: greenyellow; width: 20%; height: 80%; float: left; &#125; div#middle &#123; background-color: gray; width: 60%; height: 80%; float: left; &#125; div#right &#123; background-color: cornflowerblue; width: 20%; height: 80%; float: left; &#125; div#foot &#123; background-color: blue; width: 100%; height: 10%; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"page\"&gt; &lt;div id=\"head\"&gt; head &lt;/div&gt; &lt;div id=\"left\"&gt; main_L &lt;/div&gt; &lt;div id=\"middle\"&gt; main_M &lt;/div&gt; &lt;div id=\"right\"&gt; main_R &lt;/div&gt; &lt;div id=\"foot\"&gt; foot &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 表单 标签 &lt;form&gt;表单，属性值有action，method &lt;input&gt;输入域，属性type的值有：text，password，checkbox，radio(需要和name属性搭配使用),button(需要和value属性搭配使用),submit(需要和value属性搭配使用) &lt;textarea&gt;文本域，属性有cols,rows &lt;label&gt;控制标签 &lt;fieldset&gt;定义域 &lt;legend&gt;域的标题 &lt;select&gt;选择列表 &lt;optgroup&gt;选项组 &lt;option&gt;下拉列表中的选项,需要被&lt;select&gt;包围 &lt;button&gt;按钮 框架 框架标签&lt;frame? 框架集标签&lt;frameset&gt; 常用标签 noresize:固定框架大小 cols:列 rows:行 内联框架&lt;iframe&gt;,属性src指名引用的框架路径，属性frameborder指名是否需要边框 实体 HTML中预留字符串必须被替换成字符实体，如&lt;（小于号），&gt;（大于号） 常用的字符实体 空格：&amp;nbsp 小于号：&amp;lt 大于号：&amp;gt 和号：&amp;amp 引号：&amp;quot 撇号：&amp;apos 分：&amp;cent 镑：&amp;pound 元：&amp;yen 欧元：&amp;euro 小节：&amp;sect 版权：&amp;copy 注册商标：&amp;reg 商标：&amp;trade 乘号：&amp;times 除号：&amp;divide HTML5 Web Storage Web Storage功能就是在Web上存储数据的功能，这里的储存是针对客户端本地而言的，具体分为两种： sessionStorage：将数据保存在session对象中，session是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据 localStorage：将数据保存在客户端本地的硬件设备中，即使浏览器被关闭了，该数据任然存在，下一次打开浏览器访问网站时仍然可以继续使用 sessionStorage1234567891011function saveStorage(id)&#123; var target = document.getElementById(id); var str = target.value; sessionStorage.setItem(\"message\",str);&#125;function loadStorage(id)&#123; var target = document.getElementById(id); var msg = sessionStorage.getItem(\"message\"); target.innerHTML = msg;&#125; localStorage1234567891011function saveStorage(id)&#123; var target = document.getElementById(id); var str = target.value; localStorage.setItem(\"message\",str);&#125;function loadStorage(id)&#123; var target = document.getElementById(id); var msg = localStorage.getItem(\"message\"); target.innerHTML = msg;&#125; HTML5 本地数据库 HTML5中内置了两种本地数据库，一种为SQLite，一种为indexedDB","tags":[{"name":"HTML","slug":"HTML","permalink":"https://suda-morris.github.io/tags/HTML/"}]},{"title":"W5500 Introduction","date":"2015-08-17T01:50:00.000Z","path":"2015/08/17/w5500/","text":"W5500网络模块简介 公司：Wiznet 使用硬件逻辑门电路实现TCP/IP协议栈的传输层及网络层（如：TCP，UDP，ICMP，IPv4，ARP，IGMP，PPPoE等协议），并集成了数据链路层，物理层(10BaseT/100BaseTX)，以及32K字节片上RAM作为数据收发缓存，使得上位机主控芯片只需承担TCP/IP应用层控制信息的处理任务，大大节省了上位机对于数据复制、协议处理和中断处理等方面的工作量，提升了系统利用率及可靠性 操作过程中，用户可以近似将W5500作为MCU的一个外设RAM来使用，非常简易。W5500对外接口通常为通用的80MHz高速SPI W5500支持同时的8个socket，方便和不同的IP和设备进行通讯；为了减小系统能耗，W5500提供了网络环形模式(WOL)以及掉电模式供客户选择使用；W5500是非可攻击性的硬件网络引擎，可以防止类似于洪流，诈骗式以及注入式网络攻击，提高了网络安全 支自动协商(10/100-Based全双工/半双工) 3.3V工作电压，I/O信号口5V耐压 W5500 不支持Auto-MDI-X，也就是不支持交叉直连自动切换，对于某些比较老的设备，可能需要特定的交叉线或者直连线。比如模块连模块，需要使用交叉线，模块连路由器或者交换机需要使用直连线。 W5500不支持自动极性变换功能，因此用户需要使用直连线与交换机或者路由器连接，使用交叉线与终端设备(如服务器，工作站或者其他W5500)相连接。然而用户可以使用任何一种类型的网线与具有自动极性变换的其他设备相连。 W5500以太网芯片的内核由传输层的TCP、UDP、ICMP、IGMP等协议、网络层的IP、ARP、PPPoE等协议以及链路层的MAC构成，再加上物理层的PHY和外围的寄存器、内存、SPI接口组成了这一整套硬件化的以太网解决方案 SPI时钟设定值速率为80MHz，但是高速信号在受电磁串扰和长信号线的影响下可能会失真，实测具有稳定波形的始终速率为33.3MHz W5500初始化主要使用的几个文件 W5500_conf.c-&gt;主要配置W5500的MAC、IP地址，W5500基本的数据读写过程，复位设置函数等 Socket.c-&gt;主要介绍了W5500的SOCKET相关配置函数，比如SOCKET的打开、关闭以及接收数据、发送数据等等 Utility.c-&gt;主要介绍了基本的延时函数，还有数据格式转化函数 w5500.c-&gt;主要介绍W5500的寄存器读写过程 W5500的Socket初始化 W5500的操作需要设置一下寄存器的参数： 模式寄存器(MR) 中断屏蔽寄存器(IMR) 重发时间寄存器(RTR) 重发计数寄存器(RCR) 设置网络信息，下面的寄存器是关于网络的基本设置，需要根据网络环境来进行设置 网关地址寄存器(GAR) 本机物理地址寄存器(SHAR) 子网掩码寄存器(SUBR) 本机IP地址寄存器(SIPR) 设置端口存储信息，这一步设置端口TX/RX存储信息，每个端口的基地址和屏蔽地址在这里确定并保存。 W5500有一个通用寄存器，8个Socket寄存器区，以及对应每个Socket的收发缓存区。每一个Socket的发送缓存区都在一个16KB的物理接收内存中，初始化分配为2KB。无论给每个Socket分配多达的收发缓存，都必须在16为的偏移地址范围内(0x0000~0xFFFF).16KB的发送内存初始化被分配为每个SOcket 2KB发送缓存区(2KB*8=16KB)。 初始化分配的2KB Socket发送缓存，可以通过使用Socket发送缓存大小寄存器(Sn_TXBUF_SIZE)重新分配，一旦所有的Socket发送缓存大小寄存器(Sn_TXBUF_SIZE)配置完成，16KB的发送内存就会按照配置分配给每个Socket的发送缓存，并按照从Socket0到7顺序分配。16KB物理内存的地址是可以自增的，但是为了避免数据传输错误，需要避免发送缓存大小寄存器(Sn_TXBUF_SIZE)的和超过16 16KB的发送内存中分配了对应Socket n的发送缓存区，用于为来自主机传输的数据做缓存。Socket n发送缓存区的16位偏移地址支持64KB的寻址范围(从0x0000到0xFFFF) SPI工作协议 SPI协议定义了四种工作模式(模式0，1，2，3)。每种模式的区别是根据SCLK的极性及相位不同定义的。SPI的模式0和模式3唯一不同的就是在非活动状态下，SCLK信号的极性，SPI模式0在时钟空闲状态时钟极性为低电平。SPI的模式0和3，数据都是在SCLK的上升沿锁存，在下降沿输出。W5500支持SPI模式0以及模式3，MISO和MOSI信号无论是接收或者发送，均遵从从最高标志位(MSB)到最低标志位(LSB)的传输序列。 W5500与外设主机的通讯受SPI数据帧控制，W5500的帧分为3段：地址段，控制段，数据段 地址段为W5500寄存器或者TX/RX内存指定的16位的偏移地址。 控制段指定了地址段设定的偏移区域的归属，读写访问模式以及SPI工作模式(可变长度模式/固定长度模式) 数据段可以设定为任意长度(N字节)或者是固定长度：1字节，2字节或4字节；如果SPI工作模式设置为可变数据长度模式(VDM),SPI的SCSn信号需要由外部主机通过SPI帧控制。 在可变长度模式下，SCSn控制SPI帧的开始和停止： SCSn信号拉低，即代表W5500的SPI帧开始(地址段) SCSn信号拉低，即代表W5500的SPI帧结束(数据段的随机N字节数据结尾) W5500的SPI数据帧包括了16为地址段的偏移地址，8为控制段和N字节数据段。8为控制段可以通过修改区域选择位(BSB[4:0]),读写访问模式位(RWB)以及SPI工作模式位(OM[1:0])来重新定义。区域选择位选择了归属于偏移地址的区域 W5500支持数据的连续读写。其流程为数据从(2/4/N字节连续数据的)偏移地址的基址开始传输，偏移地址会自增寻址(加1)传输接下来的数据 SPI数据帧控制段对应位的说明： 区域选择位BSB[4:0]-&gt; 【00000】= 通用寄存器；【00001】= Socket0寄存器；【00010】=Socket0发送缓存；【00011】=Socket0接收缓存；【00101】=Socket1寄存器；【00110】=Socket1发送缓存；【00111】=Socket1接收缓存；【01001】= Socket2寄存器；【01010】=Socket2发送缓存；【01011】=Socket2接收缓存；【10101】=Socket3寄存器；【01110】=Socket3发送缓存；【01111】=Socket3接收缓存；【10001】= Socket4寄存器；【10010】=Socket4发送缓存；【10011】=Socket4接收缓存；【10101】=Socket5寄存器；【10110】=Socket5发送缓存；【10111】=Socket5接收缓存；【11001】= Socket6寄存器；【11010】=Socket6发送缓存；【11011】=Socket6接收缓存；【11101】=Socket7寄存器；【11110】=Socket7发送缓存；【11111】=Socket7接收缓存； 读写访问模式位RWB-&gt; 【0】=读；【1】=写 工作模式位OM[1:0]-&gt; 【00】=可变数据长度模式，N字节数据段(1≤N)；【01】=固定数据长度模式，1字节数据长度(N=1)；【10】=固定数据长度模式，2字节数据长度(N=2)；【11】=固定数据长度模式，4字节数据长度(N=4)； W5500有一个通用寄存器，8个Socket寄存器，以及对应每个Socket的收发缓存区。每个区域均通过SPI数据帧的区域选择位BSB[4:0]来选取。 SPI模式0/3 SPI数据帧 物理层 由计算机和网络介质之间的实际界面组成，可定义电器信号、符号、线的状态和时钟要求、数据编码和数据传输用的连接器。如最常用的RS-232规范、10BASE-T的曼彻斯特编码以及RJ-45就属于这一层。 数据链路层 数据链路层通过物理网络链路提供可靠的数据传输。不同的数据链路层定义了不同的网络和协议特征，其中包括物理编址、网络拓扑结构、错误校验、帧序列以及流控 以太网协议规定，一组电信号构成一个数据包，叫做“帧”，每一帧分成三个部分：以太网首部、数据及以太网尾部。 以太网首部包含数据帧的一些说明，比如发送者、接收者、数据类型等等；数据部分则是数据的具体内容；以太网尾部则是CRC校验码 以太网首部的长度固定为14字节。数据的长度最短为46字节，最长为1500字节。以太网尾部的长度固定为4字节。因此，整个数据帧最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送 数据链路层实际上由两个独立的部分组成：介质存取控制(MAC)和逻辑链路控制(LLC)。MAC描述在共享介质环境中如何进行站的调度、发生和接收数据。MAC确保信息跨链路的可靠传输，对数据传输进行同步，识别错误和控制数据流向。一般来讲，MAC只在共享介质环境中才是重要的，只有在共享介质环境中多个节点才能连接到同一传输介质上。 一块网卡如何知道另一块网卡的MAC地址?ARP协议(网络层)可以解决这个问题。以太网数据帧必须知道接收方的MAC地址然后才能发送。有了数据帧的定义，网卡的MAC地址，广播的发送方式，数据链路层就可以在多台计算机之间传送数据了 网络层 网络层负责在源和终点之间建立连接。它一般包括网络寻址，还可能包括流量控制、错误检查等。相同MAC标准的不同网段之间的数据传输一般只涉及到数据链路层，而不同的MAC标准之间的数据传输都涉及到网络层。IP路由器工作在网络层，因为可以实现多种网络间的互联。 IP数据包分为“标头”和“数据”两个部分。标头部分主要包括版本、长度、IP地址等细心，数据部分则是IP数据报的具体内容。IP数据报的标头部分长度为20到60字节，整个数据报的总长度最大为65535字节，因此理论上，一个数据报的数据部分最长为65515字节。以太网数据帧的数据部分最长只有1500字节，因此如果IP数据报超过了1500字节，它就要分割成几个以太网数据帧分开发送了。 传输层 传输层向高层提供可靠的端到端的网络数据流服务。传输层的功能一般包括流控、多路传输、虚电路管路以及差错校验和恢复。流控管理设备之间的数据传输，确保传输设备不发送比接受设备处理能力大的数据；多路传输使得多个应用程序的数据可以传输到物理链路上；虚电路由传输层建立、维护和终止；差错校验包括为检测传输错误而建立的各种不同结构；而差错回复包括所采取的行动，以便解决发生的任何错误。 必须要在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，UDP数据段也是有“标头”和“数据”两部分组成 标头部分主要定义了发出端口和接收端口，“数据”部分就是具体的内容，然后把整个UDP数据段放入IP数据报的“数据”部分，而IP数据报又是放在以太网数据帧之中的。 UDP数据段非常简单，标头部分一共只有8个字节，总长度不超过65535字节，正好放进一个IP数据报 为了提高网络可靠性，诞生了TCP协议，这个协议非常复杂，但可以近似认为，他就是有确认机制的UDP协议，没发出一个数据都要求确认。如果有一个数据缺失，就收不到确认，发送方就知道有必要重发这个数据了 TCP数据段没有长度限制，理论上可以无限长，但是为了保证网络的效率。通常TCP数据段的长度不会超过IP数据报的长度，以确保单个TCP数据段不必再分割。 应用层 应用层是最接近终端用户的第一层，这就意味着应用层与用户之间是通过应用软件直接相互作用。应用层并非由计算机上云sing的实际应用软件组成，而是由向应用程序提供访问网络资源的API组成。 寄存器W5500通用寄存器 W5500通用寄存器 ###Socket寄存器 Socket寄存器 通用寄存器区配置了W5500的基本信息，如IP以及MAC地址 W5500支持8个Socket作为通讯信道，每一个Socket通过Socket n寄存器控制。Socket n寄存器可以通过SPI数据帧中的区域选择寄存器BSB[4:0]来选定对应的寄存器n。 TCP/IP协议族 TCP/IP协议族 TCP协议 TCP协议通过三个报文段完成连接的建立，这个过程称为三次握手。TCP连接建立过程： 第一次握手：建立连接时，客户端发送SYN包(seq=j)到服务器，并进入SYN_SEND状态，等待服务器确认 第二次握手：服务器收到SYN包，必须确认客户的SYN(ack=j+1),同时自己也发送一个SYN包(seq=k),即SYN+ACK包，此时服务器进入SYN_RECV状态 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1),此包发送完毕，客户端和服务器进入ESTABLISH状态，完成三次握手 终止一个TCP连接需要四次挥手，这是由TCP的半关闭(half-close)造成的 第一次挥手：主动方发出设置了FIN位的报文，表示主动终止从本地到远端的单向链接；此时主动方进入FIN_WAIT1状态，意思是它在等待远端的FIN报文 第二次挥手：远端收到FIN后，会立即发送ACK；主动方收到ACK后，进入FIN_WAIT2状态，所以FIN_WAIT1状态持续的时间非常短；此时远端进入CLOSE-WAIT状态，一条单向链接终止了，但另一条还没有，处于HALF-CLOSE连接状态 第三次挥手：当远端进行了必要的数据发送后，它发送FIN，表示它出发的单向连接也要关闭，同时它进入LAST_ACK状态 第四次挥手：主动方收到FIN后，回应一个ACK；远端就此进入CLOSED状态，连接关闭；主动方进入TIME WAIT状态，确保最后一个ACK没有丢失，防止新连接占用刚刚关闭的主动方的地址端口，使得网络中流浪的老连接的返祖被误认为新连接的分组 TCP三次握手/四次挥手 当W5500初始化完成后，程序进入主循环，此时读取Socket的状态值，并选择进入哪种模式。当Socket处于关闭状态时，在进行通信之前，我们先将该Socket初始化，这个Socket作为服务器端，端口号要固定为侦听的端口。当socket将处于初始化完成状态，即SOCK_INIT状态，此时，作为TCP服务器就要执行listen()函数来侦听端口。由于W5500内嵌了TCP/IP协议，连接过程是不需要单片机干预的。如果连接过程中出错造成超时，该Socket将会被关闭，重新进入SOCK_CLOSE状态。待TCP连接的3次握手完成后，socket的状态将会转变为连接建立状态，即代码中定义的SOCK_ESTABLISHED状态。在进入SOCK_ESTABLISHED状态后，便可进行数据收发。数据通信完毕之后执行disconnect()函数，在收到对方FIN数据包之前，该socket将进入SOCK_CLOSE_WAIT状态。 TCPServer流程图 TCPClient流程图 UDP协议 UDP通信流程图 当socket处于关闭状态时，在进行通信之前我们先将该UDP模式的socket端口初始化。当socket将处于初始化完成状态即SOCK_UDP状态，此时就可以通过广播方式发送数据了。 UDP报文 DHCP协议 W5500作为DHCP客户端，路由器作为DHCP服务器端，在DHCP请求的过程中，包括4个主要阶段：发现阶段、提供阶段、选择阶段以及确认阶段 首次W5500客户端发送DHCPDISCOVER消息(IP地址租用申请)，这个消息通过广播方式发出，所有网络中的DHCP服务器都将接收到这个消息。随后，网络中的DHCP服务器会回应一个DHCPOFFER消息(IP地址租用提供)，由于这个时候客户端还没有网络地址，所以DHCPOFFER也是通过广播的方式发送出去的。然后，向该服务器发送DHCPREQUEST消息。在DHCPREQUEST消息中将包含客户端申请的IP地址。最后，DHCP服务器将会送DHCPACK的相应消息来通知客户端可以使用该IP地址，该确认里面包含了分配的IP地址和该地址的一个稳定期限的租约(默认是8天)，并同时更新DHCP数据库 DHCP初始化完成以后，通过获取DHCP_SOCKET的状态来获取动态IP地址。第一个状态DHCP_RET_NONE就是获取不成功，第二个状态DHCP_RET_TIMEOUT是获取IP地址超时，都不符合条件。第三个状态DHCP_RET_UPDATE就是获取动态IP地址成功，此时将得到的IP地址通过SPI写入W5500的寄存器。如果是DHCP_RET_CONFLICT冲突状态，就要返回DHCP服务重新获取 DHCP报文格式 报文格式解析： OP：若是client送给server的封包，设为1，反之为2 HTYPE：硬件类别，10MB以太网为1，100MB以太网为2 HLEN：硬件地址长度，Ethernet为6 HOPS：若封包需要经过router传送，每站加1，若在同一网段内，为0 TRANSACTION ID：DHCP REQUEST时产生的数值，以作为DHCPREPLY时的依据 SECONDS：Client端启动时间(秒) FLAGS：从0到15共16bits，最左1bit为1时表示server将以广播方式传送封包给client，其余尚未使用 ciaddr：yhaoshiclient端想继续使用之前取得的IP地址，则列于这里 yiaddr：从server送回client的DHCP OFFER与DHCPACK封包中，此栏填写分配给client的IP地址 siaddr：若client需要透过网络开机，从server送出的DHCP OFFER、DHCPACK、DHCPNACK封包中，此栏填写开机程序代码所在server的地址 giaddr：若需跨网域进行DHCP发放，此栏为relay agent的地址，否则为0 chaddr：client的硬件地址 sname：sever的名称字符串，以0x00结尾 file：若client需要透过网络开机，此栏将指出开机程序名称，稍后以TFTP传送 options：允许厂商定义选项，提供更多的设定信息，其长度可变，同时可携带多个选项，每一个选项的第一个字节为信息代码，其后一个自己为该项数据长度，最后为项目内容 DNS协议 客户端初始化完毕之后，如果DNS运行标志位是1或者DNS发送次数超过3次就直接返回。如果不是上面的情况，并且DNS Server的IP不是0.0.0.0时，进入switch函数。当处于DNS域名解析成功状态时，DNS_OK置1，发送请求报文次数置0。当DNS解析域名失败时，标志位置0，请求报文次数加1，然后跳出循环。 DNS报文格式： DNS报文格式 标识：DNS报文的ID，对于相关联的请求报文和应答报文，这个字段是相同的 标志： 标志字段 QR：查询/响应的标志位，1为响应，0为查询 opcode：定义查询或响应的类型(若为0则表示是标准的，若为1则是反向的，若为2则是服务器状态请求) AA：授权回答的标志位，该位在相应报文中有效，1表示名字服务器是权限服务器 TC：截断标志位，1表示响应以超过512字节并已经被截断 RD：只能在响应报文中置1，表示可以得到递归响应 zero：0，保留字段 rcode：返回码，表示响应的差错状态，0表示无差错，1表示格式差错，2表示问题在域名服务器上，3表示域参照问题，4表示查询类型不支持，5表示在管理上被禁止 问题数、资源记录数、授权资源记录数和额外资源记录数，这四个字段都是两字节，分别对应下面的查询问题、回答、授权和额外信息部分的数量。一般问题数都为1，DNS查询报文中，资源记录数、授权资源记录数和额外资源记录数都为0. 查询问题部分的格式： 查询问题格式 查询名部分长度不定，一般为要查询的域名，有时候也有IP的时候，即反向查询。此部分由一个或者多个标识符序列组成，每个标识符以首字节数的计数值来说明该标识符长度，每个名字以0结束。技术字节数必须在0~63之间 查询类型： 1：IPv4地址 2：名字服务器 5：规范名称 6：开始授权，标记一个区的开始 11：熟知服务，定义主机提供的网络服务 12：指针，把IP地址转化为域名 13：主机信息，给出主机使用的硬件和操作系统的表述 15：邮件交换，把邮件改变路由送到邮件服务器 28：IPv6地址 252：传送整个区的请求 255：对所有记录的请求 查询类：通常为1，指Internet数据 回答字段，授权字段和附加信息字段均采用资源记录的相同格式： 资源记录格式 域名字段(不定长或者2字节)：记录资源数据对应的名字，它的格式和查询名字段格式相同。当报文中域名重复出现时，就需要使用2字节的偏移指针来替换。 类型、类：含义与查询问题部分的类型和类相同 生存时间：该字段表示资源记录的生命周期，一般用于当地址解析程序取出资源记录后决定保存以及使用缓存数据的时间 资源数据长度：表示资源数据的长度，以字节为单位，如果资源数据为IP则为0004 资源数据：该字段是可变长字段，表示按查询段要求返回的相关资源记录的数据 SMTP协议 邮件发送过程示意图 SMTP在TCP协议25号端口监听连续请求。SMTP连接和发送过程： 建立TCP连接 客户端发送HELO命令以标识发件人自己的身份，然后客户端发送MAIL命令；服务器端正希望以OK作为相应，表明准备接收 客户端发送RCPT命令，以表示该电子邮件的计划接收人，可以有多个RCPT行；服务器端则表示是否愿意为收件人接收邮件 协商结束，发送邮件，用命令DATA发送 以“.”号表示结束并将内容一起发出去，结束此次发送，用QUIT命令退出 ICMP协议 ICMP是Internet控制报文协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。我们在网络中经常会使用到ICMP协议，比如我们经常使用的用于检查网络通不通的Ping命令，这个ping的过程实际上就是ICMP协议工作的过程。Ping命令利用ICMP回射请求报文和回射应答报文来测试目标系统是否可达。 执行ping后，首先向目标服务器发出回送请求报文。计算机送出的回送请求到达目标服务器后，服务器回答这一请求，向送信方发送回送请求。这个ICMP回送回答报文在IP层来看，与被送来的回送请求报文基本上一样。不同的只是，源和目标IP地址字段被交换了，类型字段里填入了表示回送回答的0，这两点，也就是，从送信方式来看，自己送出的ICMP报文从目标服务器哪里像鹦鹉学舌那样原样返回了 Http协议 HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。 HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。 请求报文格式如下：请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体 应答报文格式如下：状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体 请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF 请求方法有多种： GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 状态行格式如下：HTTP-Version Status-Code Reason-Phrase CRLF 其中Status-Code标识服务器发回的响应状态代码；Reason-Phrase标识状态代码的文本描述 状态码有三位数字组成，第一个数字定义了响应的类别，且有5种可能取值： 1xx：指示信息，标识请求已接收，继续处理 2xx：成功，标识请求已被成功接收、理解、接受 3xx：重定向，要完成请求必须进行更进一步的操作 4xx：客户端错误，请求有语法错误或请求无法实现 5xx：服务器端错误，服务器位能实现合法的请求 常见状态码、状态描述、说明 200 OK 客户端请求成功 400 Bad Request 客户端请求有语法错误，不能被服务器理解 401 Unauthorized 请求未经授权，这个状态码必须和WW-Authenticate报文域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务 404 Not Found 请求资源不存在 500 Internal Server Error 服务器发生不可预期的错误 503 Server Unavaliable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。 Cache-Control用于指定缓存指令，缓存指令是单向的，而且是独立的。 请求时的缓存指令包括：no-cache(用于指示请求或响应消息不能缓存)、no-store、max-age、max-stale、min-fresh、only-if-cached 响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage Date普通报头域表示消息产生的日期和时间 Connection普通报头域允许发送指定连接的选项，例如指定连接是连续或者指定“close”选项，通知服务器，在响应完成后，关闭连接。在http1.1中，client和server都是默认对方支持长链接的， 如果client使用http1.1协议，但又不希望使用长链接，则需要在header中指明connection的值为close；如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close。不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp链接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp链接了。 请求报头允许客户端向服务器传递请求的附加信息以及客户端自身的信息，常用的请求报头： Accept：用于指定客户端接收哪些类型的信息，Accept:image/gif表明客户端希望接收GIF图像格式的资源；Accept:text/html表明客户端希望接收html文本 Accept-Charset：用于指定客户端接受的字符集，如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受 Accept-Encoding：指定可接受的内容编码 Accept-Language：指定一种自然语言 Authorization：用于证明客户端有权查看某个资源，当浏览器访问一个页面时，如果收到服务器的响应代码为401，可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证 Host:发送请求是，该报头域是必须的，主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回 User-Agent：该请求报头域允许客户端将它的操作系统、浏览器和其他属性告诉服务器，不过，这个报头域不是必须的，如果我们自己编写一个浏览器，不适用User-Agent请求报头域，那么服务器端就无法得知我们的信息了 请求报头举例： 123456789GET /form.html HTTP/1.1 (CRLF)Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)Accept-Language:zh-cn (CRLF)Accept-Encoding:gzip,deflate (CRLF)If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)If-None-Match:W/\"80b1a4c018f3c41:8317\" (CRLF)User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)Host:www.guet.edu.cn (CRLF)Connection:Keep-Alive (CRLF) 响应报头允许服务器传递不能放在状态行中的附件响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息；常用的响应报头： Location用于重定向接收者到一个新的位置，Location响应报头域常用在更换域名的时候 Server包含了服务器用来处理请求的软件信息，与User-Agent请求报头域是相对应的 WWW-Authenticate响应报头域西粗被包含在401响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时候，服务端响应报头就包含该报头域 实体报头。请求和响应消息都可以传送一个实体，一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文和请求所标识的资源的元信息。常用的实体报头： Content-Encoding：被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzip Content-Language：实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读者。eg：Content-Language:da Content-Length：实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示 Content-Type：实体报头域用语指明发送给接收者的实体正文的媒体类型 Last-Modified：实体报头域用于指示资源的最后修改日期和时间 Expires：实体报头域给出响应过期的日期和时间。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0 HTTP协议通常是承载于TCP洗衣之上的，有时也承载于TLS或SSL协议层之上，这时称之为HTTPS协议。默认HTTP的端口号为80，HTTPS的端口号为443 HTTP请求报文 HTTP响应报文 GET与POST方法有以下区别： Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，要提交的数据位于信息头后面的实体中。 在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交 GET方式提交的数据最多只能有1024字节，而POST则没有此限制 NetBIOS NetBIOS实现过程 NetBIOS协议是一种在局域网上的程序可以使用的应用程序编程接口，为v横须提供了请求低级服务的统一的命令集，作用是为了给局域网提供网络以及其他特殊功能，几乎所有的局域网都是在NetBIOS协议的基础上工作的。NetBIOS协议，简单来说就是通过访问设备名称就可以实现对IP地址的访问。 在Windows操作系统中，默认情况下在安装TCP/IP协议后会自动安装NetBIOS协议。 ping主机名的第一个数据包就是NBNS(NetBIOS Name Server)协议包，它是TCP/IP上的NetBIOS协议族的一部分，它在基于NetBIOS名称访问的网络上提供主机名和地址映射方法。NBNS是动态DNS的一种。Microsoft的NBNS实现称为WINS。NetBIOS的报文类型较多，结构复杂，在不同的网络化境和不同的用途中会使用不同的报文，可用端口进行区分。如图所示NetBIOS协议架构 NetBIOS协议架构 NetBIOS数据报有很多不同格式，主要取决于服务和信息类型，以及用以传送NetBIOS数据报的传输协议。NetBIOS协议架构包含三种基本服务：NAME、SESSION和DATAGRAM，其中NAME所用协议就是NBNS协议 WINS协议使用的报文即为NetBIOS的名字报文，其总体格式如下图所示 NetBIOS名字报文格式 事物ID：请求方为每次名字服务请求所设定的ID值，响应方在相应的响应报文中要填入这个事物ID值 操作代码：指示报文的类型,最高位为0表示数据包为Reauest请求，最高位为1表示数据包为Response应答，其余4个比特均为0 操作标志：操作标志位，最低位为1表示广播或者多播，最低位为0表示单播，其他位均为0 结果代码：在相应报文中指示请求的结果，一般为0 问题记录个数：请求查询问题的个数，对于Request数据包，该值为1，对于Response数据包，该值为0 回答记录个数：对于Response数据包有用，Response数据包中响应问题的个数，一般为1 权威记录个数：在权威记录部分的记录数量，用不到的时候为0 附加记录个数：在附加记录部分数量，用不到的时候为0 报文的前12字节总称NetBIOS名字报文的首部，通过首部可以判断是否为名字查询的报文。NetBIOS名字报文中最常见的是携带问题记录的报文，问题记录的格式是：问题名称(若干字节) 问题类型(2字节) 问题类别(2字节)。通过携带问题记录的报文，我们可以得到要查询的名字字符，如果和本机名相符，就发送报文响应，相应中带有IP地址，发送广播的主机就会得到该IP地址 NETBIOS会话报文具有通用的4字节首部和与类型相关的报文内容：类型(1字节) 标志(1字节) 长度(2字节) 内容(若干字节) 类型：指名NetBIOS会话报文的类型，可用的值有： 0x00:会话消息 0x81:会话请求 0x82:正面会话响应 0x83:负面会话响应 0x84:重定向会话响应 0x85:会话保活 标志：0~6位保留未用，第7位作为扩展的长度位，使NetBIOS会话报文的内容部分最多可以达到128K字节 长度：NetBIOS会话报文的内容部分的长度，不包括首部的4字节 NBNS 计算机1向计算机2的137端口发送一个NODE STATUS REQUEST请求数据包，计算机2收到该数据包后，向计算机1返回一个NODE STATUS RESPONSE响应数据包，该数据包中包含计算机2的MAC地址、机器地址、所属的工作组等信息 NODE STATUS REQUEST数据包由12字节的HEADER域和38字节的QUESTION ENTRIES域两个部分组成，HEADER域分为8个字段： NetBIOS HEADER QUESTION ENTRIES域组成 QUESTION ENTRIES 其中： QUESTION_NAME为要查询的远程计算机的名称，长度为34字节。NBNS规定，计算机NetBIOS的名称不超过16字节，且最后一个字节必须为0x0； QUESTION_TYPE对于REQUEST数据包取值为0x0021 QUESTION_CLASS取值为0x0001 当某台机器的137端口收到NODE STATUS REQUEST请求数据包之后，由该机器的NETBIOS服务随即生成并返回一个NODE STATUS RESPONSE响应数据包。该响应数据包由HEADER域和RESOURCE RECORD域两部分组成。RESOURCE RECORD域组成如图所示： RESOURCE RECORD RP_NAME：34字节，与Request数据包的QUESTION_NAME格式定义相同 RP_TYPE：与Request数据包中的QUESTION_TYPE字段相同 RP_CLASS：与前面Request数据包的QUESTION_CLASS字段取值相同 TTL：4字节，取值为0x00000000 RDLENGTH:表示从NUM_NAMES字段开始到整个RESOURCE RECORD结束共有多少个字节 NUM_NAMES：表示紧随其后的NODE_NAME ARRAY数组的元素个数，数组的每个元素具有NODE_NAME结构，如图所示为NODE_NAME结构： NODE_NAME NETBIOS FORMAT NAME表示远程主机的机器名或者组名，具体依赖NAME_FLAG字段的取值； NAME_FLAGs：当最高位为1时，NETBIOS FORMAT NAME字段中存储的是Group NetBIOS名称，即工作组名，当最高位为0时，NETBIOS FORMAT NAMR字段中存储的是机器名 STATICS：包含的字段非常多，开始6字节是远程主机的MAC地址 SNTP协议 SNTP是简单网络时间协议，是用来使设备时间同步化的一种协议，在一些应用场合里，时间同步时十分重要的，贴别是随着设备运行时间增长，时间误差就越来越大，因为设备中晶振自身会产生误差，那么SNTP协议就可以解决这个问题。 报文格式： SNTP报文格式 LI: 跳跃指示器 VN：版本号 Mode：模式 0——预留 1——对称行为 3——客户机 4——服务器 5——广播 6——NTP控制信息 Stratum：对本地时钟级别的整体识别 Poll：有符号整数表示连续信息间的最大间隔 Precision：有符号整数表示本地时钟精确度 Root Delay：有符号固定点序号表示主要参考源的总延迟，很短时间内的位15到16间的分段点 Root Dispersion：无符号固定点序号表示相对主要参考源的正常差错，很短时间内的位15到16间的分段点 Reference Identifier：识别特殊参考源 Originate Timestamp：这是向服务器请求分离客户机的时间，采用64位时标格式 Receive Timestamp：这是向服务器请求到达客户机的时间，采用64位时标格式 Transmit Timestamp：这是客户机答复分离服务器的时间，采用64位时标格式 Authenticator：当实现了NTP认证模式主要标识符和信息数字域就包括已定义的信息认证代码信息 原理图： SNTP原理示意图 TFTP协议 TFTP是TCP/IP协议族中的而一个用来在客户机和服务器之间进行简单文件传输的协议，基于UDP协议实现，端口号为69. TFTP是专为小文件喜欢书设计的，提供不复杂、开销小的文件传输服务，缺乏标准FTP协议的许多特征。 TFTP只能从远程服务器上读、写文件或者读写文件传送给远程服务器。它不能列出目录并且当前不提供用户认证 TFTP有3中传输模式： netASCII模式即8位网络ASCII码 octet即八位组模式 邮件模式，这种模式现在已经废弃不用了 TFTP数据包结构 TFTP报文格式 操作码 1=RRQ，读请求，由客户端使用，用来建立一条从服务器读数据的连接 2=WRQ，写请求，由客户端使用，用来建立一条把数据写到服务器的连接，它的格式与RRQ相同 3=data 4=ACK 5-error Filename（文件名字段）说明客户要读或写的位于服务器上的文件，文件名是NETASCII码字符，以0结束。 Mode（模式字段）是一个ASCII码串netASCII或octet，同样以0字节结束。netASCII表示数据是以成行的ASCII码字符组成，以两个字节一回车字符后跟换行符。OCTET模式用于传输文件，这种文件在源机上以8位格式存储。在使用MAIL模式时，用户可以在FILE处使用接收人的地址，这个地址可以是用户名或@主机的形式，如果是后一种形式，允许主机使用电子邮件传输此文件。如果使用MAIL类型，包必须以WRQ开始，否则它与NETASCII完全一样 DATA数据包还包括一个数据块号和数据，数据块号域从1开始编码，每个数据块加1，这样接收方可以确定这个包是新数据还是已经接收过的数据。数据域从0字节到512字节。如果数据域是512字节，则它不是最后一个包，如果小于512字节则表示这个包是最后一个包。如果最后一个包正好512字节，则再发送一个0字节的包用于表示结束 ACK包用于确认数据包以手法哦。当接收方收到一个数据包后，回享发送方发送一个ACK包，而发行方则会在收到一个ACK包后继续发送下一个包。若发送完未能收到ACK包，则会使用超时机制，重新发送刚才的数据包。除了ACK和用于中断的包外，其他的包均需得到确认。发出新的数据包等于确认上次的包。WRQ和DATA包由ACK或ERROR数据包确认，而RRQ数据包由DATA或ERROR数据包确认 ERROR数据包可以被其他任何类型的包确认，错误码指定错误的类型，它用于服务器不能处理读请求或者写请求的情况。在文件传输过程中的读和写差错也会导致传送这种报文，接着停止传输。差错编号字段给出一个数字的差错码，跟着是一个ASCII表示的差错报文字段，可能包含额外的操作系统说明 1：文件未找到 2：访问非法 3：磁盘满或超过分配的配额 4：非法的TFTP操作 5：位置的传输ID 6：文件已经存在 7：没有类似的用户 通信流程：任何一个传输进程都以WRQ或者RRQ开始，收到一个确定应答并建立一个连接。创建连接时候，通信双方随机选择一个TID，因为是随机选择，因此两次选择同一个ID的可能性就很小了。每个包包括两个TID，发送者ID和接收者ID。这些ID用于在UDP通信时选择端口，在第一次请求的时候它会将请求发到TID 69，也就是服务器的69端口上，应答时，服务器使用一个选择好的TID作为源TID，并用上一个包中的TID作为目的ID进行发送。这两个被选择的ID在随后的通信中会被一直使用。连接成功后文件就以固定的512字节块的长度进行发送。每个数据包都包含一个数据块，块号从1开始而且是连续的。因此对于写入请求的确定是一个比较特殊的情况，因此它的包的包号是0.再发送下一个包之前，数据块必须得到确认响应包的确认。如果一个数据包的大小小于512字节，则表明传输结束。如果包在网络中丢失，接收端就会在超市以后重新传输最后一个未被确认的数据包，这就是导致丢失包的发送者重新发送丢失包。通信的双方都是数据的发出者与接收者，一方传输数据接收应答，另一方发出应答接收数据。发送者需要保留一个包在手头用于重新发送，由LOCk确认响应保证所有过去的包都已收到。大部分的错误会导致连接中断，错误由一个错误的数据包引起。这个包不会被确认，也不会被重新发送，因此另一方无法接收到。如果错误包丢失，则使用超时机制。错误主要由下面三种情况引起的：不能满足请求，收到的数据包内容错误，对需要资源的访问丢失。TFTP只有在一种情况下不中断连接，这种情况是源端口号不正确，在这种情况下，指示错误的包会被发送到源机。这个协议限制很多，这都是为了实现起来比较方便而进行的。 TFTP通信流程 TFTP的工作过程很想停止等待协议，发送完一个文件块后就等待对方的确认，确认时应指名所确认的块号。发送完数据后在规定的时间内收不到确认就要重发数据PDU（协议数据单元），发送确认PDU的一方若在规定时间内收不到下一个文件块，也要重发确认PDU。这样保证文件传送不致因某一个数据报的丢失而告失败 FTP协议 FTP（File Transfer Protocol，文件传输协议），用于Internet上的控制文件的双向传输 FTP协议使用TCP端口中的20和21这两个端口，其中20用于传输数据，21用于传输控制信息。但是是否使用20作为传输数据的端口与FTP使用的传输模式相关，如果采用主动模式，那么数据传输端口就是20；如果采用被动模式，则具体最终使用哪个端口要服务器和客户端协商决定 FTP支持两种模式，一种方式叫做Standard（也就是PORT方式，主动方式），一种是Passive（也就是PASV，被动方式）。Standard模式，FTP的客户端发送PORT命令到FTP服务器，Psaaive模式下FTP的客户端发送PASV命令到FTP Server Port FTP客户端首先和FTP服务器的TCP 21端口建立连接，通过这个通道发送命令，客户端需要接收数据的时候在这个通道上发送PORT命令。PORT命令包含了客户端用什么端口接收数据。在传送数据的时候，服务端通过自己的TCP 20端口连接至客户端的指定端口发送数据。FTP server必须和客户端建立一个新的连接用来传送数据 Passive 在建立控制通道的时候和Standard模式类似，但建立连接以后发送的不是Port命令，而是Pasv命令。FTP服务器收到Pasv命令后，随机打开一个高端端口（端口号大于1024）并且通知客户端在这个端口上传送数据的请求，客户端连接FTP服务器此端口，然后FTP服务器将通过这个端口进行数据的传送，这个时候FTP server不再需要建立一个新的和客户端之间的连接 很多防火墙在设置的时候是不允许接收外部发起的连接的，所以许多位于防火墙后或内网的FTP服务器不支持PASV模式，因为客户端无法穿过防火墙打开FTP服务器的高端端口；而许多内网的客户端不能用PORT模式登陆FTP服务器，因为服务器的TCP 20无法和内部网络的客户端建立一个新的连接，造成无法工作 传输方式： ASCII传输 假定用户正在拷贝的文件包含简单的ASCII码文本，如果在远程机器上运行的是不同的操作系统，当文件传输时ftp通常会自动地调整文件的内容以便于把文件解释成另外那台计算机存储文本文件的格式。但是常常有这样的情况，用户正在传输的文件包含的不是文本文件，他们可能是程序、数据库，字处理文件或者压缩文件。在拷贝任何非文本文件之前，用binary命令告诉ftp逐字拷贝，不要对这些文件进行处理，即使用二进制传输方式 二进制传输 在二进制传输中，保存文件的位序，以便原始和拷贝的是逐位一一对应的。计时目的机器上包含位序列的文件时没有意义的。如果在ASCII方式下传输二进制文件，即使不需要也仍会转译。这会使传输稍微变慢，也会损坏数据，是文件变得不能使用。（在大多数计算机上，ASCII方式一般假设每一字符的第一有效位无意义，因为ASCII字符组合不使用它。） FTP连接 一般来讲，控制连接一直保持到客户-服务器连接的全过程，但数据连接可以根据需要随时开启和结束。而通用的传输方式是流方式，并且文件结尾是以关闭数据连接为标志。这意味着对每一个文件传输或目录列表来说都要建立一个全新的数据连接 一个典型的主动方式的过程： 客户端打开一个随机的端口（端口号大于1024，这里记为x），同时一个FTP进程连接至服务器的21号命令端口。此时，源端口为客户端随机端口x，远程端口为服务器21.正是由于客户端发出命令要求建立数据连接，所以数据连接是在客户的控制下建立的 客户通常在客户端主机上为所在的数据连接端选择一个临时端口号。客户从该端口发布一个被动的打开 客户使用PORT命令从控制连接上把端口号法相服务器 服务器在控制连接上接收端口号，并向客户端主机上的端口发布一个主动的打开。服务器的数据连接端一直使用端口20 命令处理 接入命令：USER、PASS、ACCT、REIN、QUIT、ABOR 文件管理命令：CWD、CDUP、DELE、LIST、NLIST、MKD、PWD、RMD、RNFR、RNTO和SMNT 数据格式化命令：TYPE、STUR、MODE 端口定义命令：PORT、PASV 文件传送命令：RETR、STOR、APPE、STOU、ALLO、REST、STAT 杂项命令：HELP、NOOP、SITE、SYST 每个FTP命令至少产生一个响应，响应有两个部分：三位数字的树以及紧随后面的正文，数字部分定义代码，正文部分定义所需要的参数和额外的解释。第一位数字定义命令的状态，第二位数字定义命令的意义，第三位数字提供附加信息 当数据通过数据流传输时，控制流处于空闲状态。而当控制流空闲很长时间后，客户端的防火墙会将其会话置为超时，这样当大量数据通过防火墙时，会产生一些问题。此时，虽然文件可以成功传输，但因为控制会话会被防火墙断开，传输会产生一些错误 主动模式 客户端打开一个随机的端口（端口号大于1024，这里称x），同时一个FTP进程连接至服务器的21号命令端口，此时，源端口为随机端口x，在客户端，远程端口为21，在服务器 客户端开始监听端口(x+1),同时向服务器发送一个端口命令（通过服务器的21号命令端口），此命令告诉服务器客户端正在监听的端口号并且已准备好从此端口号接收数据。这个端口号就是我们所知的数据端口 服务器打开20号源端口并且建立和客户端数据端口的链接。此时源端口为20，远程数据端口为（x+1） 客户端通过本地的数据端口建立一个和服务器20号端口的链接，然后向服务器发送一个应答，告诉服务器它已经建立好了一个连接 被动模式 在被动方式FTP中，命令链接和数据连接都是由客户端发起，这样就可以解决从服务器到客户端的数据端口的入向链接被防火墙过滤掉的问题 当开启一个FTP连接时，客户端打开两个任意的非特权本地端口（N&gt;1024和N+1）。第一个端口连接服务器的21端口，但与主动方式的FTP不同，客户端不会提交PORT命令并允许服务器来回连它的数据端口，而是提交PASV命令。这样做的结果是服务器会开启一个任意的非特权端口（P&gt;1024），并发送PORT命令给客户端。然后客户端发起从本地端口N+1到服务器端口P的连接用来传送数据 对于服务器端的防火墙来说，必须允许下面的通讯才能支持被动方式的FTP： 从任何大于1024的端口到服务器的21端口（客户端的初始化连接） 服务器的21端口到任何大于1024的端口（服务器响应到客户端的控制端口的连接） 从任何大于1024端口到服务器的大于1024端口（客户端初始化数据连接到服务器指定的任意端口） 服务器的大于1024端口到远程的大于1024的端口（服务器发送ACK响应和数据到客户端的数据端口） suda-morris","tags":[{"name":"W5500","slug":"W5500","permalink":"https://suda-morris.github.io/tags/W5500/"}]},{"title":"Linux Kernel Introduction","date":"2015-07-20T15:30:54.000Z","path":"2015/07/20/linux-kernel/","text":"内核make流程 make %config和make menuconfig的目的是为了生成.config文件，而Kconfig作为生成make menuconfig等图形配置界面工具而存在 .config 文件中决定了内核中的哪些代码被编译进内核，哪些代码被当做模块编译 make根据.config中的描述，通过解析Makefile文件来进行编译，最终生成zImage文件 流程中设计的文件与命令，再加上Linux内核的scripts目录构成了内核的Kbuild机制，内核通过这种方式，最终编译得到内核镜像文件zImage KBuild机制实现原理 从编译过程来看，每一个被编译的目录下都会生成一个build-in.o文件，他们都由自己目录下的源代码编译生成，所有目录下的build-in.o文件最终链接生成vmlinux文件，最后由内核压缩程序加工vmlinux生成内核压缩镜像文件zImage 总原理来看，Kbuild机制只会把obj-y的值编译进内核。每个Makefile文件中都有这个变量，只不过obj-后面一半都跟着一个变量，这个变量的值来自于.config。 待编译目录下的Makefile，如有Kbuild，则Kbuild优先，唯一使用Kbuild而不是Makefile的就是顶层目录 Kconfig语法 config 为menu或者choice中的一个选项条目 config后面常跟一个变量名，比如ARM，那么在.config中将以CONFIG_ARM=y或n的形式出现 下一行写该变量的取值类型,可以是bool,tristate,string,hex,int default为变量缺省值，可以被用户设置值覆盖 prompt后边是出现在配置菜单中的对应于一个配置选项的文字，没有prompt条目，将使得用户不能在配置界面中显示并配置该配置选项 depends on var表示该变量必须在var被设置的情况下才能进行设置，否则取值为n，即使default为y select var表示它将影响到变量var，使得var至少应该配置为y或者m help中的文字将作为配置界面中的帮助信息 menu 在menu和endmenu中间可配置若干config条目 choice 在choice和endchoice之间可定义若干config条目。choice中的config条目只能有2种类型：bool或者tristate，且不能同时有这两种变量。对于bool型变量只能在多个选择中选择1个为y；对于tristate型变量，要么将多个设置为m，要么仅将1个设为y，其余为n。 comment 用于定于帮助信息，将出现在配置界面的第一行，并且还会出现在配置文件.config中作为注释 source 由于内核源代码中大多数目录下都有各自的Kconfig文件，因此需要一种手段将所有的Kconfig文件组织为一个整体。这就是source的功能，它用于引入另一个Kconfig文件，有点类似于C语言中的#include Makefile文件精解12345678910#如果CONFIG_ATL1=y，将递归进入本目录的子目录atl1，并根据该子目录下的Makefile文件的内容决定该子目录如何继续拧编译，否则将不进入本目录的子目录atl1进行编译obj-$(CONFIG_ATL1) += atl1/#如果.config中变量CONFIG_GIANFAR=y，那么将变异本目录下的gianfar.c,gianfar_ethtool.c,gianfar_mii.c,gianfar)sysfa.c文件并将其功能集成进zImage；如果.config文件中变量CONFIG_GIANFAR=m，那么将编译本目录下的gianfar.c,gianfar_ethtool.c,gianfar_mii.c,gianfar_sysfs.c文件生成模块gianfar.ko；否则将编译gianfar.c,gianfar_ethtool.cgianfar_mii.c,gianfar_sysfa.cobj-$(CONFIG_GIANFAR) += gianfar_driver.ogianfar_driver-objs := gianfar.o\\ gianfar_ethtool.o\\ gianfar_mii.o\\ gianfar_sysfs.o zImage文件生成过程 内核代码首先被编译生成vmlinux，放在Linux源码的顶层目录下 这个vmlinux可执行文件又通过arm-linux-objcopy命令转化为二进制代码文件Image（放在arch/arm/boot目录下），其实这个Image文件才是真是的内核代码文件，因为这个文件会比较大，所以内核会对它做压缩处理 为了最大化减小Image的体积，内核调用gzip工具吧Image压缩成piggy.gz文件 为了让内核具有自引导功能，在arch/arm/boot/compressed目录下有head.o,misc.o两个文件构成解压和自引导代码，而让真实的piggy.gz文件也参与编译，最终生成了梁歪一个vmlinux文件，放在arch/arm/boot/compressed目录下，并最终调用arm-linux-objcopy生成二进制文件zImage。 综上，zImage文件由arch/arm/boot/compressed目录下的head.S和misc.c文件（自解压程序）+内核真实代码文件组成 Linux内核体系结构 内核和用户空间的应用程序使用不同的保护地址空间。每个用户空间的进程都使用自己的虚拟地址空间，内核则占用单独的地址空间，一般情况下，应用程序无法直接访问内核空间地址。因此，应用程序想访问内核必须通过某种特殊的方式从用户空间切换到内核空间。这个特殊的方法称为：系统调用 考虑到频繁的系统调用会影响操作系统的性能（切换开销、硬件损耗等），标准C库GNU C Library（glibc）提供了新的连接内核的接口，这些接口同样通过系统调用访问内核，不过通常都带有缓冲区，将数次操作合并为一次，以有效减少系统调用的次数 综上，Linux内核可以分为3层： 最上面一层是系统调用接口，它实现了一些基本功能，如read和write。 系统调用接口之下是体系架构无关的内核，这部分内核对于Linux支持的所有处理器体系结构是通用的。 其下是体系架构相关的部分，通常称为BSP。 内核配置过程 运行make menuconfig时，配置工具首先分析与体系结构对应的arch//Kconfig文件，arch//Kconfig文件除本身包含一些与体系结构相关的配置项和配置菜单以外，还通过source语句引入下一层的Kconfig文件。 内核头文件命名规则 #include &lt;asm/xxx.h&gt;：CPU相关的头文件 #include &lt;linux/xxx.h&gt;：平台无关的头文件 #include &lt;plat/xxx.h&gt;：芯片公司相关的头文件 #include &lt;mach/xxx.h&gt;：开发板相关的头文件 内核组件 Linux内核主要由系统调用（SCI），进程管理（PM），内存管理（MM），虚拟文件系统（VFS），网络协议栈（NET），CPU体系结构和设备驱动（DD）等7个组件组成 SCI层提供了某些机制执行从用户空间到内核的函数调用。这些接口依赖于体系结构。 进程管理的重点是进程的执行。在内核中这些进程称为线程，代表了单独的处理器虚拟化（线程代码、数据、堆栈和CPU寄存器）。在用户空间，通常使用进程这个术语，不过Linux实现并没有区分这两个概念（进程和线程）。内核通过SCI提供了一个应用程序编程接口来创建一个新进程（fork、exec、kill、exit），并在它们之间进行通信和同步 内核管理的另外一个重要资源是内存，为了提高效率，内存按照内存页的方式进行管理，页大通常是4KB。Linux内存管理主要负责内存的分配和释放，以及物理地址到虚拟地址的映射等 虚拟文件系统是Linux内核中非常有用的一个组件，因为它为文件系统提供了一个通用的接口抽象。VFS在SCI和内核支持的文件系统之间提供了一个交换层。在VFS上面，是对诸如open、close、read和write之类的系统调用函数的一个通用抽象。在VFS下面是对文件系统的抽象，它定义了上层函数的实现方式。文件系统层之下是缓冲区缓存，它为文件系统层提供了一个通用函数集，这个缓存层通过将数据保留一段时间，优化对物理设备的访问。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。 网络协议栈在设计上采用分层思想，从上到下分为系统调用接口、协议无关接口层、网络协议层、设备无关接口层和设备驱动层。其中协议无关层就是socket层，提供了一组通用函数来支持各种不同协议。 字符设备驱动 设备号 内核使用dev_t来描述设备号，其实质是unsigned int32位整数，其中高12位是主设备号，低20位是次设备号 int register_chrdev_region(dev_t from,unsigned count,const char* name);调用该函数向内核注册设备号 设备信息的描述 cdev123456789struct cdev&#123; struct kobject kobj; struct module *owner; const struct file_operations *ops; struct list_head list; dev_t dev; unsigned int count;&#125; 设备行为的描述 file_operations12345678910struct file_operations&#123; struct module *owner; ... ssize_t (*read)(struct file*,char __user*,size_t,loff_t*); ssize_t (*write)(struct file*,const char __user*,size_t loff_t*); int (*open)(struct inode*,struct file*); int (*release)(struct inode*,struct file*); ...&#125; 相关的注册函数 int cdev_add(struct cdev*p,dev_t dev,unsigned count);","tags":[{"name":"Linux","slug":"Linux","permalink":"https://suda-morris.github.io/tags/Linux/"}]},{"title":"Review in C++ Language","date":"2015-07-20T01:42:00.000Z","path":"2015/07/20/review-in-cpp/","text":"流 标准C++中，iostream中常见的操作算子(manipulator):flush,endl,oct(后面跟的数据解析成八进制)，hex(后面跟的数解析成十六进制)，dec(后面跟的数解析成十进制)，boolalpha(后面跟的数据解析成布尔类型，并用true和false来显示)，showpos(后面跟的数据显示正负号)，fixed(后面跟的数不要四舍五入),noshowpos(后面跟的数如果是正数就显示+号),showpoint(后面跟的数据显示小数点)，scientific(后面跟的数据以科学计数法的形式表示);在Qt中附加的一些操作算子：forcesign(后面的数据显示正负号),forcepoint(后面的数据显示小数点),noforcesign(后面的数据如果是正数就不显示+号) 标准C++的iostream中，getline(cin,your_string)语句能够从标准输入流中提取一行字符串 在Qt中很容易用与iostream对应的同一个名称定义QTextStream，由于控制台输入和输出主要用在调试过程，所以Qt提供了一个全局函数qDebug(),用它可以方便地将消息发送到控制台，且具有灵活的接口 流被用来读取/写入文件、连接网络和处理字符串，它有一个有用的特性是易于从混合数据类型中得到字符串。 STL中的字符串流：std::ostringstream,常用来定义一个string_buffer; STL中的文件流std::ofstream,用来定义一个文件流管道如ofstream outf后绑定一个文件：outf.open(“file path”) STL中的输入文件流std::ifstream,打开文件instream inf;inf.open(“file path”),判断是否读到了文件末尾inf.eof(),读取一行数据getline(inf,newstr) STL中的stringstream对应于Qt里面的QString，STL中的fstream对应于Qt里面的QFile，STL中的iostream对应于Qt中的QTextStream 运算符new和delete new运算符从堆(heap)中分配内存空间，并且返回指向新分配的对象的指针，如果由于某种原因无法完成内存分配，就会抛出一个异常 delete运算符的作用是释放动态分配的内存并将其返回给堆。delete操作只能用于由new运算符返回的指针或者空指针。 智能指针 智能指针是一个对象，它用来保存和管理指向堆对象的指针，其行为与常规的指针非常类似，只是它会在合适的时刻自动删除堆对象。这个类在Qt中对应的是QPointer，在标准库中是std::auto_ptr,在Boost中是shared_ptr 引用 在C++中，引用提供了一种给左值赋予一个别名的机制，对于避免费事或者不必要的复制引用是非常有用的，例如向函数传送一个非常大的对象作为参数。引用必须在声明时进行初始化且其初始化器也必须是一个左值,例如：int n;int&amp; rn=n;引用变量rn是实际变量n的别名 一种好的编程实践是：对于不需要通过函数来进行变化的指针和引用参数，应使用const来保护它们。只读引用参数的能力在于：对按引用传递参数提供了高效性，而对按值传递参数提供了安全性 类的友元 友元机制允许非成员函数访问一个类的私有数据，关键字friend可以放在类的生命或者函数声明之前，友元声明位于类定义之内 通常而言，为了达到下面两个目的才会使用友元函数： 为了使用工厂方法，此时需要对某个类强制实施某些创建规则 为了使用全局运算符函数，比如operator&lt;&lt;()和operator&gt;&gt;()，此时不希望将运算符作为某个类的成员函数，或者没有写入类定义的权利 运算符重载 C++使用关键字operator为运算符赋予新的含义 例如重载&lt;&lt;运算符：friend ostream&amp; operator&lt;&lt;(ostream&amp; out,const Complex&amp; c); define与inline的区别 对#define宏的替换过程是由预处理器处理的，预处理器本质上是一个文本编辑器。对inline函数的替换过程是由编译器处理的，它会执行更智能的操作，进行正确的类型检查 inline函数必须在调用之前定义 在一个源代码模块中只能有一次inline定义 带变长实参表的函数 在C和C++中，可以定义其参数表以省略号结尾的函数。省略号使调用者能够制定参数的数量以及类型。 为了定义使用省略号的函数，需要包含cstdarg库 1234567891011double mean(int n, ...)&#123; va_list ap; double sum(0); int count(n); va_start(ap,n); /*ap执行第一个未命名实参*/ for(int i=0;i&lt;count;i++)&#123; sum += va_arg(ap,double); &#125; va_end(ap); /*返回之前清除栈*/ return sum/count;&#125; 预处理宏主要应用场合 使用#ifndef/#define/#endif将头文件包裹起来，以避免多次包含某个头文件 使用#ifdef/#else/#endif对某些代码部分进行条件编译 FILE宏和LINE宏用于调试并给出框架信息 C++中的多态性 C++源于C语言，它的编译器也试图在编译时绑定函数调用，这主要是基于性能方面的考虑。编译器无法仅凭集成关系和基类指针就确定它正在操作何种对象。如果没有运行时检查，就无法保证运行时调用正确的函数。C++要求使用一个特殊的关键字来允许运行时通过指针和引用进行函数调用的绑定，这个关键字就是virtual，它能够使得程序具有多态性。 由于this是在执行它的构造函数时被初始化的，在执行它的析构函数的时候被销毁，因此不要指望在这两种条件下能够执行正确的运行时绑定。当在构造函数或者析构函数里面调用任何this方法时，将由编译时绑定决定应该调用哪一个方法，就好像不存在virtual关键字一样。 一般而言，如果类中包含一个或者多个virtual函数，则也应包含一个虚析构函数。这是因为，当对对台对象集合进行操作时，通常是通过基类指针删除这些对象，这会导致对析构函数的间接调用，如果析构函数不为virtual类型，在编译时绑定将决定应该调用哪一个析构函数，从而可能导致派生对象的不完整析构 静态成员函数不能使虚函数；内敛函数不能是虚函数；构造函数不能是虚函数 虚函数实现原理 父类中如果有虚函数存在，编译器就会为该对象创建一个虚函数表，里面存放自己的虚函数的指针。 子类继承父类，编译器也会为子类创建一个不同的虚函数表，存放子类自己的虚函数指针 拥有虚函数表的类都会另外创建一个指向该表的指针 所以当父类指针指向子类对象，调用虚函数的时候就会根据子类对象的虚函数表调用得到子类的虚函数，而不是父类的虚函数 如果没有在子类中定义与父类同名的虚函数，那么就会在子类的虚函数表中就会写上父类的相应的虚函数的函数入口地址；如果在子类中也定义了同名的虚函数，那么在虚函数表中用子类的虚函数的函数地址覆盖掉父类的相应的虚函数的函数地址 每个类只有一份虚函数表，所有该类的对象共用同一张虚函数表 只有函数声明没有函数定义的虚函数也是纯虚函数 纯virtual函数的声明 virtual returnType functionName(parameterList)=0; 抽象基类中至少要有一个virtual函数 抽象基类中不能有public的构造函数 抽象基类的任何具体派生类都必须重写并定义全部的纯virtual基类函数，话句话说，任何没有重写并定义全部纯virtual基类函数的派生类都是抽象类 重载，隐藏与重写 当函数foo在同一个作用域内存在两个或者多个版本(具有不同的签名)时，就称foo函数被重载了 当基类中的一个virtual函数在培生累中也存在，并且他们具有相同的签名和返回类型时，就称派生类中的版本“重写”了基类中的版本 派生类中的成员函数，会隐藏基类中与之同名的全部函数，如果出现这种情况，则： 只有派生类函数可以被直接调用 类作用域解析运算符::西部用来显式地调用基类函数 有三种特殊的成员函数从来不会被继承，编译器会为没有定义它们的类自动生成这三种函数 拷贝构造函数：类名（const 类名&amp; 变量名） 复制赋值运算符 析构函数 构造函数 如果一个类没有构造函数，那么编译器就会自动产生一个默认的public构造函数，而这个构造函数会调用它的每一个基类的默认构造函数。如果某个类有一些构造函数但是没有默认构造函数，那么它就不会进行默认的初始化工作，这种情况下，任何派生类构造函数都必须在其初始化列表中明确地指名应该调用哪一个基类构造函数 类的前置声明 类的前置声明将它的名称声明成一个有效的类名称，但不给出类的定义。这会使得类名称能够被用作指针和引用的类型，在遇到类的定义之前，不会将这些指针和引用进行解引操作。 如果可以使用前置声明，就不要使用#include指令 范型与模板 1.模板为C++编译器提供了一个途径，能够为带有参数化类型和相同行为的类和函数生成多个版本。模板使用关键字template以及用尖括号&lt;&gt;包围的模板参数进行区分。与函数参数不同，模板参数不仅可以传递变量和值，还可以传递类型表达式。例如：template Buffer{T v[max];} 每当编译器看到一个特定参数类型的组合首次用于一个模板函数时，就称此模板进行了实例化。 类模板主要用来生成数据的通用容器，其参数能够指名容器中的内容。所有的Qt容器类以及标准模板库(STL)中的所有容器类都是参数化的。 所有模板的定义(类和函数)都必须出现在头文件中，这是因为编译器需要用这些定义来根据模板声明生成代码 其他 C++中使用struct的大多数情形是需要将数据项分组在一起，但是不需要成员函数 const成员函数中不允许对数据成员进行修改，如果修改，编译器将报错，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改了数据成员，或者调用了其它非const成员函数，编译器将指出错误。注意可以在const成员函数里面更改可变成员(mutable member)的值，而常规的数据成员的值不能改变 类内定义的成员函数编译器会优先编译成内联(inline)函数 初始化列表优先于构造函数执行.初始化列表只能用于构造函数,初始化列表可以同时初始化多个数据成员 const数据成员的初始化必须写在初始化列表中 M_PI来自于&lt;math.h&gt;,它位于cstdlib库中 foreach()宏需要赋值它所遍历的容器，这就要求使用foreach必须要有拷贝构造函数 C++类型可以分成两类：值类型和对象类型，值类型的有Anything*，int，char，QString，QDate和QVariant。带有共有默认构造函数、拷贝构造函数和复制赋值运算符的任何类型都是值类型 C++对于没有数据成员的类在实例化的时候会分配1个内存单元(1Byte)，用于标记该对象的存在 含有纯虚函数的类叫做抽象类,抽象类无法实例化对象","tags":[{"name":"CPP","slug":"CPP","permalink":"https://suda-morris.github.io/tags/CPP/"}]},{"title":"QT4 Basic","date":"2015-07-19T12:52:44.000Z","path":"2015/07/19/qt4/","text":"Qt核心模块Qt是一个大库，由数个较小的库或者模块组成，其中最为常见的有如下这些，除了core和gui，其余模块都需要在qmake的工程文件中启用： core：包括QObject，QThread，QFile，Qvariant等等 gui：所有从QWidget派生的类外加一些相关的类 xml：用于解析和序列化XML sql：用于与SQL数据库通信 phonon：用于播放多媒体文件 webkit：用于使用一种嵌入式web浏览器，QtWebkit 工程文件.pro 对于Qt程序，程序不必编写Makefile文件，Qt提供了一个qmake工具，它会根据工程文件来产生对应的Makefile文件。亦可以用qmake -project命令产生一个简单的工程文件，当执行这个命令的时候，qmake会将当前工作目录下的全部源文件(.cpp)作为SOURCES列出来，而将该目录下的全部头文件(.h)作为HEADERS列出来。最终生成的可执行文件的名称由TARGET变量指定，其默认为工程的名称 TEMPLATE=app，表明qmake应该以一个适合建立这个应用的模板化的Makefile开始，如果这个工程文件用于建立库，则应当使用语句TEMPLATE=lib，以表明应使用Makefile库模板。第三种可能是源代码文件分布在多个子目录下，而每一个子目录下的文件都具有自己的工程文件，这种情况下，位于父目录的工程文件中应该包含语句TMPLATE=subdirs，这会导致在父目录和每一个子目录下都生成Malefile 添加库：LIBS += -Lpathtolibs CONFIG += console表示是控制台程序 当编写并测试完库之后，在编译链接过程结束后它将被安装到由qmake变量DESTDIR指定的目录下。例如，dataobjects库的工程文件包含如下相关的行： TEMPLATE = lib DESTDIR = pathto_install_libs 对于库模板，qmake将产生一个包含install目标的Makefile，这样，在成功编译链接之后执行命令make install将会把这个库复制到某个特定的位置 Qt中获取命令行参数 QCoreApplication app(argc,argv); QStringList arglist = app.arguments(); arglist.size等于命令行参数的个数 Qt中的字符串 const char*，主要用于与C语言库的接口 来自C++标准库的string，任何地方都可以使用这种类型 QString，优于STL中的字符串类型，有着更加丰富的API而且更加容易使用。 在Qt中使用类似于iostream中的cin，cout： #include &lt;QString> #include &lt;QTextStream> QTextStream cout(stdout) QTextStream cin(stdin) cin.readLine() sizeof(QString)=4,sizeof(QChar)=2,sizeof(QDate)=4,sizeof(qint32)=4,sizeof(qint64)=8;QString是一个使用动态内存的复杂类，因此必须调用length()来获得字符串中QChar的数量。由于QChar的大小为char的两倍，所以在计算内存中QString中实际大小时需要将长度乘以2，在运行时，QString能够与具有同一个值的另一个字符串共享内存 去掉最大、最小、关闭按钮 setWindowFlags(windowFlags()|Qt::FramelessWindowHint|Qt::WindowTitleHint); 使用中文 下载qpf格式的font_wenquanyi字体，将下载的字库文件复制到qt安装目录的lib/fonts子目录下 12345678910\\#include &lt;QTextCodec&gt; QApplication a(argc, argv); QTextCodec::setCodecForLocale(QTextCodec::codecForName(&quot;UTF-8&quot;)); //中文支持 QTextCodec::setCodecForTr(QTextCodec::codecForName(&quot;UTF-8&quot;)); //支持Tr中文 QTextCodec::setCodecForCStrings(QTextCodec::codecForName(&quot;UTF-8&quot;)); //支持中文文件名显示 QFont font; font.setPointSize(160); //实际上是16的字号，但设成16却不行 font.setFamily((&quot;wenquanyi&quot;)); font.setBold(false); a.setFont(font); 隐藏鼠标箭头 对于整个程序: QApplication::setOverrideCursor(Qt::BlankCursor); 对单个控件：lable-&gt;setCursor(Qt::BlankCursor);//隐藏鼠标 label-&gt;setCursor(Qt::ArrowCursor);//显示正常鼠标 QStringList与迭代 QStringList实际上就是一个QList,此外，QStringList还具有一些特别针对字符串的方便函数，例如indexOf(),join()和replaceInStrings()。利用split()函数和join()函数，在列表与字符串之间进行转换相当简单 QStringList对象可以调用方法takeFirst()来依次获得列表中的字符串对象12345678910111213141516171819202122232425262728QString winter = \"December,January,February\";QString spring = \"March,April,May\";QString summer = \"June,July,August\";QString fall = \"September,October,November\";QStringList list;list &lt;&lt; winter;list += spring;list.append(summer);list &lt;&lt; fall;QString allmonths = list.join(\",\"); /*从列表到字符串，以逗号为分隔符*/QStringList list2 = allmonths.split(\",\"); /*从字符串到列表，以逗号为分隔符*/foreach(const QString &amp;str,list)&#123; /*Qt foreach循环*/ //TODO&#125;for(QStringList::iterator it = list.begin(); it != list.end(); ++it)&#123; QString current = *it; //TODO&#125;QListIterator&lt;QString&gt; itr(list2);while(itr.hasNext())&#123; QString current = itr.next(); //TODO&#125; QDir，QFileInfo和QDirIterator利用QDir类和QFileInfo类获取目录的内容列表以及关于每一个项的信息12345678910111213141516171819void recurseAddDir(QDir d,bool recursive=true,bool symlinks=false)&#123; d.setSorting(QDir::Name); QDir::Filters df = QDir::Files | QDir::NoDotAndDotDot; if(recursive) df |= QDir::Dirs; if(not symlinks) df |= QDir::NoSymLinks; QStringList qsl = d.entryList(df,QDir::Name|QDir::DirsFirst); foreach(const QString &amp;entry,qsl)&#123; QFileInfo finfo(d,entry); if(finfo.isDir())&#123; QDir sd(finfo.absoluteFilePath()); recurseAddDir(sd); &#125;else&#123; if(finfo.completeSuffix()==\"mp3\")&#123; addMp3File(finfo.absoluteFilePath()); &#125; &#125; &#125;&#125; 使用QDirIterator实现相同功能123456QDir dir = QDir::current();QDirIterator qdi(dir.absolutePath(), QStringList() &lt;&lt; \"*.mp3\", QDir::NoSymLinks | QDir::Files, QDirIterator::Subdirectories);while(qdi.hasNext)&#123; addMp3File(qdi.next()); //TODO&#125; QDate static QDate currentDate = QDate::currentDate(); Qt中字符串的数据流操作1234567QString Student::toString() const&#123; QString retval; QTextStream os(&amp;retval); os &lt;&lt; \"name:\" &lt;&lt; m_Name &lt;&lt; \";ID:\" &lt;&lt; m_StudentID; return retval;&#125;` qDeleteAll(container)只对包含指针的容器有意义，该函数将释放所有对象，但并不删除容器中的指针；删除容器中的指针需要调用容器的clear()函数 容器（Qt容器被定义成模板类） QList是用数组实现的，数组的两端都有预分配的空间。它针对按索引的随机访问以及少于1000项的列表进行了优化。对于prepend()和append()这样的操作，它有很好的性能表现 QStringList是派生自QList的一个便利类 QLinkedList针对迭代器的顺序访问以及快速、常量时间的列表插入操作进行了优化，但排序和搜索比较缓慢。它提供多个便利函数来处理那些经常用到的操作QVector以连续的内存位置保存数据，并针对按索引的随机访问进行了优化。通常而言，QVector对象都是用其初始大小进行构造的，在其两端都不存在预先自动分配的内存空间，所以中间掺入、末端插入以及前端插入都是耗时的 QStack是派生自QVector的public类，所以QVector类的public接口可以用于QStack对象。不过，push(),pop()以及top()函数采用的是后入先出(LIFO)的语法 QMap&lt;Key,T&gt;是一个有序的关联容器，它保存的是键/值对，其作用是根据键来快速找到对应的值。它也被设计成支持适量的快速插入操作和删除操作。它将键有序排列，以便能够快速搜索和快速缩小搜索范围，采用的是一个跳跃列表字典，这个字典在概率上是平衡的并且高效的利用了内存。键的类型必须是operator&lt;()和operator==() QHash&lt;Key,T&gt;也是一个关联容器，它使用哈希表来进行键的查找。它提供快速的查找(键精确匹配)和插入操作，但其搜索速度较慢，且没有排序功能。键的类型必须是operator==() QMultiMap&lt;Key,T&gt;是QMap的一个子类，而QMultiHash&lt;Key,T&gt;是QHash的一个子类。这两个类是的一个键可以与多个值关联 QCache&lt;Key,T&gt;是一个关联容器，它对最近使用过的项提供最快速的访问，并会根据几个开销函数的结果自动移除哪些不常用的项 QSet用QHash保存T类型的值，QHash中的键位于T中，而其中的哑值与每一个键相关联。这种安排可优化查找和插入操作。QSet中的几个函数用于常规的集合操作。它的默认构造函数会创建一个空集合 用于模板容器类的类型参数T，或者用于关联容器的键类型都必须为可赋值数据类型，即值类型。这意味着T必须具有public类型的默认构造函数、拷贝构造函数和赋值运算符。基本类例如int，double，char和指针都是可赋值的，有些Qt类型是可赋值的，例如QString，QDate，QTime。QObject以及派生自QObject的类型都是不可赋值的，如果需要使用某种不可赋值类型的对象，则可以定义一个指针容器，例如QList&lt;QFile*&gt; QFile12345QFile outf((\"filename\");outf.open(QIODevice::WriteOnly);QTextStream outstr(&amp;outf);outstr &lt;&lt; \"content\";outf.close(); 序列化器模式：QTextStream和QDataStream 序列化器是一种只负责读取或者写入对象的对象，Qt的QTextStream序列化器用于读写人可读的文件，而QDataStream序列化器用于读写结构化的二进制数据。这些类都是用序列化器模式实现的 利用QDataStream就可以序列化和解序列化QVariant支持的全部类型，包括QList，QMap，QVector以及其他类型。 1234567891011121314151617QFile textFile(\"playlist1.tsv\");QFile binaryFile(\"playlist1.bin\");QTextStream textStream；QDataStream dataStream；if(textFile.open(QIODevice::ReadOnly))&#123; textStream.setDevice(&amp;textFile);&#125;if(binaryFile.open(QIODevice::WriteOnly))&#123; dataStream.setDevice(&amp;binaryFile);&#125;QList&lt;MetaDataValue&gt; values;while(!textStream.atEnd())&#123; MetaDataValue mdv; textStream &gt;&gt; mdv; values &lt;&lt; mdv; dataStream &lt;&lt; mdv;&#125; QObject QObject是Qt库中许多重要的类的基类，如QEvent，QApplication，QLayout和QWidget。 QObject使基于事件的编程成为了可能，其中用到了QApplication和Qt的事件循环 QObject没有公有的拷贝构造函数或复制赋值运算符。QObject类定义的结尾处有一个宏Q_DISABLE_COPY(QObject)，它显示地确保任何QObject都不能被复制。QObject不是设计用于复制的，QObject会用来代表具有唯一身份的对象。这种不带拷贝构造函数策略的一个直接后果就是永远无法通过值传递方式向函数传递OBject。 QObject及其派生类的单参数构造函数应当予以显式声明explicit，以免意外的隐式转换的发生。 每个QObject都可以有（至多）一个父QObject，且可以拥有任意数量的子QObject。 每个QObject都将指向各个子对象的指针存放在一个QObjectList中，在调用QObject的析构函数时会自动销毁该对象的子对象 通常而言，没有父对象的QObject应当在程序栈区(stack)中进行定义，而那些有父对象的QObject则应当在堆区(heap)动态创建出来，这样可有助于确保发生正确的析构操作。 QObject有一个成员函数，可以返回一个指向主对象中全部子对象的指针列表：const QObjeectList&amp; QObject::children() const QObject还提供了两个名称为findChildren()的重载(递归)每个都会返回一个满足特定条件的子对象列表：QList parentObj.findChildren(const QString&amp; name=QString()) const 该函数返回一个类型为T的子对象列表，其对象名与name相等。如果name是空字符串，那么将会起到一个类过滤器的作用，返回结果是一个QList，其中包含指向全部子对象的指针，而这些子对象都可以通过类型转换变成类型T的对象 1234QList&lt;Customer*&gt; custlist = parent.findChildren&lt;Customer*&gt;();foreach (const Customer* current,custlist)&#123; qDebug() &lt;&lt; current-&gt;toString();&#125; QEvent QEvent类封装了底层事件的概念。QEvent类是若干特定事件类的基类，例如QActionEvent,QFileOpenEvent,QHoverEvent,QInputEvent,QMouseEvent等。QEvent对象可以由窗口系统创建以响应用户的动作(例如，QMouseEvent)或按照指定的时间间隔(QTimerEvent)完成创建，也可以由应用程序显式地创建。成员type()会返回一个美剧，其中含有近百个特定的值，以区分不同种类的各式事件(例如,关闭、DragEnter、DragMove、放下、输入、GrabMouse、HoverEnter、KeyPress、MouseButtonDblClick、MouseMove、Resize) 一个典型的Qt程序会创建对象，连接各个对象，然后再告诉应用程序开始发送exec()，在运行时，应用程序就进入了事件循环，各个对象之间可以通过各种方式相互发送消息。 只有在事件循环，特别是QApplication::exec()进入的事件循环中，信号才能发送到槽上。这是因为信号和槽在其外表之下是使用事件循环来传递消息的。 QObject支持一些普通C++对象通常没有的特性：信号和槽，元对象、元属性、元方法，qobject_cast 元对象编辑器，即moc，会针对每个使用Q_OBJECT宏的QObject派生类生成额外的函数，生成的代码可以在名称为moc_filename.cpp的文件中找到。 信号和槽 信号是在类定义中给出的类似于void函数声明的一种消息。它有参数列表却没有函数体。信号时一个类的接口的一部分，它看起来想函数，但不用同样的方式进行调用—它被此类的对象发射 槽通常是一个void成员函数，它可以像普通的成员函数一样进行调用，或者可以由QMetaObject系统进行间接调用 连接语句的语法：bool QObject::connect(senderQObjectPtr,SIGNAL(signalName(argumentList)),receiverQObjectPtr,SLOT(slotName(argumentList))optionalConnectionType);optionalConnectionType让你可以明确说明，你是否希望从发射点处同步(阻塞)或者非同步(排队)地调用目标槽 如果有多个信号连接到同一个槽上且需要知道是那哟个QPbject发射的信号，则可以在该槽中调用sender(),它会返回一个指向那个对象的指针 堆还是栈 一般情况下，没有父对象的QObject应当在栈上创建，或者定义成另一个类的子对象。有父对象的QObject不应该在栈上创建，因为那样的话，它有可能会被删除两次。不推荐直接删除QObject，在带有事件循环的程序中，最好利用QObject::deleteLater()来删除QObject。这样做，可以在应用程序处理事件并在当前槽返回之后就安排该对象的销毁。希望能够在槽内删除信号的sender(),这么做实际上是必须的 QWidget和其余GUI开发中常用的类 QWidget是一个采用了多重继承的类，首先，QWidget是一个QObject，因此它可以有父对象、信号、槽以及可受管理的子对象。同时QWidget也是一个QPaintDevice，这个类是所有可在屏幕上进行绘制的对象的基类 Qt数据类型——QPoint,QSize,QColor,QImage和QPixmap是在处理图形对象时常用到的类型 布局——这些类能够动态地管理Widget的布局，其中有些事常用的特殊布局，包括QHBoxLayout，QVBoxLayout，QGridLayout，QFormLayout等 模型——QAbstractItemModel及其各个派生类，如QAbstractListModel和QAbstractTableModel，外加一些已有的可继承实体类，如QSqlQueryModel和QFileSystemModel，都是Qt模型/视图框架中的一部分，该框架内置将一个模型和其他不同视图相连接的机制，以便对一个组件的修改可以自动变换到其他组件上 控制类——QApplication和QAction两者都是管理GUI应用程序控制流的对象。QItemDelegate用作模型和视图之间的控制器 对话框 QDialog是Qt所有对话框的基类。对话框窗口可以是模态(modal)对话框也可以是非模态(nonmodal)对话框。 当程序调用静态的便利函数”QMessageBox::”或者”QFileDialog::”时，弹出的对话框就是模态对话框。当模态对话框显示在屏幕上时，它会冻结同一应用程序中的其他所有可见窗口的输入功能。用户解除模态对话框后，与应用程序的常规交互才可以继续下去。QDialog::exec()是将模态对话框放到屏幕上的另一种方式。当用户完成了所需的响应后，对话框就可以返回数据，也可以返回对话框代码(QDialog::Accepted或者QDialog::Rejected); 可以像QWidget一样通过show()显示一个QDialog，在此情况下，对话框是非模态的，用户也就可以与应用程序的其他窗口继续交互。 12345QApplication app(argc,argv);QProgressDialog nonModal;nonModal.setWindowTitle(\"Non Modal Parent Dialog\");nonModal.show();nonModal.connect(&amp;nonModal,SIGNAL(finished()),&amp;app,SLOT(quit())); 图标、图像与资源 Qt提供了至少两种方式来获得标准的图标。一种方式来自于桌面样式的QStyle::standardIcon()，另一种则来自插件型图标主题:QIcon::fromTheme() 把所需的二进制数据文件作为资源附加到工程中会让工程更为健壮。源代码无须为资源文件使用一些不可移植的路径名。要引用一个存储成资源的文件，可以使用在.rcc文件中指定的别名并在前面带一个前缀”:/“。于是，每个资源好像位于一个私有虚文件系统中，其根为”:/“。然而，得到这些好处是需要付出代价的，可执行文件会更大，程序也会需要更多的内存 有3个Qt类可以简化处理图片： QImage——用于离屏操作，输入输出操作，并可直接访问像素 QPixmap——用于在屏幕上进行绘制并优化，仅用在主线程中 QIcon——用于视频内存的缓冲且经常用到，但仅用在主线程中 QPicture——存储绘制的操作而不是实际的位图图片 布局 布局可以将它们的Widgets排列成如下几种形式： 垂直型(QVBoxLayout) 水平型(QHBoxLayout) 网格型(QGridLayout) 窗体型(QFormLayout) 栈型，任何时候都只有一个窗件可见(QStackedLayout) 可以使用addWidget()函数向QLayout添加窗件，当窗件添加到布局中时，它会称为拥有该布局的窗件的子对象。窗件永远不会称为布局的子对象 为了能够顺利地管理其几何形状，每个QLayout对象都必须有一个父对象，这可以是一个QWidget，也可以是一个QLayout。可以在创建布局时通过向构造函数传递一个指向父窗件或者布局的指针来指定其父对象。当然，也可以先创建一个QLayout而不指定QLayout的父对象，这种情况下，可以稍后通过调用QWidget::addLayout()来指定其父对象 布局可以拥有子布局，通过调用addLayout()函数，可以将一个布局添加为另外一个布局的子布局。如果布局的父对象是一个窗件，那么该窗件将再也无法称为另外一个布局的父对象 不使用Qt设计师时，可以使用QLayout类的API来直接指定各个窗件之间的分割、伸展和支撑 addSpacing(int size)会向布局的末尾添加固定数量的像素 addStretch(int stretch = 0)会添加数目不定的像素。此函数由一个最小的数目开始，然后逐渐扩展到使用所有的可用空间。如果在同一个布局中进行多次扩展，可以用此作为一个增长因子 addStrut(int size)讲给处置方向施加一个最小的数值(也就是，QVBoxLayout的宽度或者QHBoxLayout的高度) QTimer QTimer对象是一个倒数计时器，以毫秒级时间间隔启动，当其到达零时会发出一个timeout()信号.QTimer可用来以规则的间隔来发射信号，或者如果singleShot属性已设置成true，则在给定的时间间隔后仅发射一次信号。QTimer有一个静态函数singleShot()，可以在给定的时间间隔后调用一次槽。如果倒数间隔设置成0，QTimer会在事件队列中的全部事件处理完后就立刻发出timeout()信号 1QTimer::singleShot(m_expInterval,this,SLOT(timerDisplayRandStr())); 绘制事件和画图 一个Widget应当在其paintEvent()方法中执行适当的绘制操作。这是QWidget中唯一可以创建QPainter painter(this)的地方。有下面几个原因使得QPaintEvent可以被发送到QWidget上。 窗件是隐藏的，然后又显露了出来 窗件改变了大小或者进行了重新排布 调用了update()或者repaint()。repaint()在paintEvent()得到调用后才会返回。update()在QPaintEvent被放进事件队列后会立即返回123456void LifeWidget::paintEvent(QPaintEvent* evt)&#123; QPainter painter(this); if(!m_image.isNull())&#123; painter.drawImage(QPoint(0,0),m_image); &#125;&#125; QMainWindow12345678910class MyMainWindow:public QMainWindow&#123; Q_OBJECTpublic: explicit MyMainWindow(QWidget* parent=0); void closeEvent(QCloseEvent* event);protected slots: virtual void newFile(); virtual void open(); virtual bool save();&#125; QAction QAction从QObject派生而来，是用于用户选定动作的一个基类。它提供了丰富的接口，它还可以用于许多种动作中。QWidget接口使得每个窗件都可以维护一个QList&lt;QAction*&gt;。所有QWidget都可以拥有QAction，一些窗件借助上下文提供了QAction的清单，其他借助菜单栏。 QMenu是一个能够给QAction集合提供特殊视图的QWidget。QMenuBar是菜单的一个集合，常见于QMainWindow中。 每次调用QMenu::addAction(text,target,slot,shortcut)函数，都会窗件一个未命名的QAction，并且会将其添加到这个QMenu上。然后会调用它的积累函数，QWidget::addAction(QAction*),这样把新建的QAction添加到用于上下文菜单的QMenu的QAction清单中。 QSettings QSettings会管理键/值对的永久映射关系，它是一个QObject，并且会使用一些与QObject相似的属性接口——setValue()和value()——来设置和获取它的值。这个类可以用来存储任何需要在多次执行之间进行记忆的数据 QSettings需要一个组织名和一个应用程序名，但当使用默认的构造函数时，QSettings会从QApplication中获得这些值。每个名称组合都会定义一个唯一的永久映射，这使得不会与其他命名的Qt应用程序产生冲突 允许多个实例共享相同状态的类，可以看成是Monodtate模式的一种实现。拥有相同组织/应用程序名称的两个QSettings实例，可以访问同一个永久映射数据。这简化了应用程序从不同源文件访问公共设置值的过程。QSettings是Monostate模式的一种实现 剪切板 每个Qt应用程序都可以使用qApp-&gt;clipboard()访问系统的剪贴板。剪贴板会保存带类型的数据(文本，图片，URL或者自定义数据)。要往剪贴板中放置数据，可以创建一个QMimeData，以一定的方式对数据进行编码，并且调用QClipBoard-&gt;setMimeData()。 1connect(qApp-&gt;clipboard(),SIGNAL(changed(QClipboard::Mode)),this,SLOT(clipboardChanged(QClipboard::Mode))); QImage QImage在像素处理上得到了优化，QPixmap使用了视频存储器，它也是需要在屏幕上显示图片的多种窗件要用到的类。可以吧QImage转换成QPixmap并将其在QLabel进行显示12345678910111213int h(m_Image.height()),w(m_Image.width());int r,g,b;QRgb oldpix,newpix;for(int y=0;y&lt;h;y++)&#123; for(int x=0;x&lt;w;x++)&#123; oldpix=m_Image.pixel(x,y); r=qRed(oldpix)*radj; g=qGreen(oldpix)*gadj; b=qBlue(oldpix)*badj; newpix=qRgb(r,g,b); m_Image.setPix(x,y,newpix); &#125;&#125; 模板类 因为每个Q_OBJECT都需要通过moc为其生成代码，而且moc并未智能到知道如何生成模板类的特化，孤儿不允许使一个已经标记为Q_OBJECT的类再次成为模板类 ##qSort qSort()函数是一个使用堆分类算法进行实现的范型方法。qSort()可以应用到任何Qt容器，只要容器内的对象拥有公共接口operator&lt;()和operator==()。基本数据类型的容器也可以使用此函数进行排序 反射与元对象 所谓反射，就是指对象成员的自我检查，使用反射编程，就可以编写出通用的操作，可对具有各种不同结构的类进行操作。使用通用的值存储器QVariant，就可以按照一种统一的方式来对基本类型和其他普通类型进行操作 所谓元对象就是描述另一个对象结构的对象。QMetaObject是元对象模式的一个Qt实现，它提供了一个QObject对象所拥有的属性和方法的信息。元对象模式有时也称为反射模式 一个拥有元对象的类就可以支持反射。这是一个许多面向对象语言都具有的性质。虽然C++中不存在反射，但Qt的元对象编译器(moc)可以为QObject生成支持这种机制的代码 只要满足一定条件(每个类都必须在头文件中定义，并且列举在工程文件的HEADERS中，同时此类的定义中还必须包括Q_OBJECT宏)，每个派生自QObject的类都会拥有一个有moc为其生成的QMetaObject。QObject拥有有个成员函数，它能够返回指向对象的QMetaObject的指针，这个函数原型是：QMetaObject* QObject：：metaObject() const[virtual] 可以使用QMetaObject的下面这些方法来获取一个QObject的信息： className(),它会将类的名称以const char*格式返回 superClass(),如果存在基类的QMetaObject，则返回其指针，如果不存在返回0 mathodCount(),返回类的成员函数的个数 信号和槽机制同样需要依赖与QMetaObject 通过使用QMetaObject和QMetaProperty就可以编写足够通用的代码来处理所有具有自我描述能力的类 除了C++的RTTI运算符dynamic_cast和typeid之外，Qt还提供了两种运行时的类型识别机制： qobject_cast QObject::inherits() qobject_cast是一个ANSI风格的类型转换运算符：DestType qobject_cast&lt;DestType&gt; (QObject* qoptr),如果转换失败返回NULL。qobject_cast实际是一个向下转换运算符，类似于dynamic_cast。拥有指向派生类的基类指针时，向下转换允许调用在基类接口中不存在的派生类方法。 访问数据成员的方式： 直接访问，通过经典的gettet/settet，速度快，更为有效 间接访问，通过QObject/QMetaObject接口，可让代码复用性更好 使用Q_PROPERTY宏来描述QObject的属性：Q_PROPERTY(type name READ getFunction [WRITE setFunction] [RESET resetFunction] [NOTIFY notifySignal] [DESIGNABLE bool] [SCRIPTABLE bool] [STORED bool]),例如： customer-props.h1234567891011121314151617181920212223242526272829class Customer:public QObject&#123; Q_OBJECT //moc预处理类需要的宏 Q_PROPERTY(QString id READ getId WRITE setId NOTIFY valueChanged); Q_PROPERTY(QString name READ getName WRITE setName NOTIFY valueChanged); Q_PROPERTY(QString address READ getAddress WRITE setAddress NOTIFY addressChanged); Q_PROPERTY(QString phone READ getPhone WRITE setPhone NOTIFY phoneChanged); Q_PROPERTY(QDate dateEstablished READ getDateEstablished); //只读属性 Q_PROPERTY(CustomerType type READ getType WRITE setType NOTIFY valueChanged);public: enum CustomerType&#123; Corporate,Individual,Educational,Government &#125;; //枚举类型定义必须与Q_ENUMS宏的定义出现在同一类定义中 Q_ENUMS(CustomerType); //特殊的宏可以实现生成字符串到枚举之间的转换功能；必须在同一个类中 explicit Customer(const QString name = QString(),QObject* parent = 0);//之所以声明为explicit，是因为不希望从QString转换到Customer时出现意外 QString getId const&#123; return m_id; &#125; void setType(CustomerType newType); void setType(QString newType);signals: void addressChanged(QString newAddress); void valueChanged(QString propertyName,QVariant newValue,QVariant oldValue=QVariant()); void phoneChanged(QString newPhone); void typeChanged(CustomerType type);private: QString m_id,m_name,m_address,m_phone; QDate m_date; CustomerType m_type;&#125; customer-props.cpp12345678910111213141516171819202122232425262728293031323334Customer::Customer(const QString name,QObject* parent):QObject(parent)&#123; setObjectName(name);&#125;void Customer::setId(const QString&amp; newId)&#123; if(newId != m_id)&#123; QString oldId = m_id; m_id = newId; emit valueChanged(\"id\",newId,oldId); &#125;&#125;void Customer::setType(CustomerType theType)&#123; if(m_type != theType)&#123; CustomerType oldType = m_type; m_type = theType; emit valueChanged(\"type\",theType,oldType); &#125;&#125;void Customer::setType(QString newType)&#123; static const QMetaObject* meta = metaObject(); static int propindex = meta-&gt;indexOfProperty(\"type\"); static const QMetaProperty mp = meta-&gt;property(propindex); QMetaEnum menum = mp.enumerator(); const char* ntyp = newType.toAscii().data(); CustomerType theType = static_cast&lt;CustomerType&gt;(menum.keyToValue(ntyp)); if(theType != m_type)&#123; CustomerType oldType = m_type; m_type = theType; emit valueChanged(\"type\",theType,oldType); &#125;&#125;QString Customer::getTypeString() const&#123; return property(\"type\").toString();&#125; 可以通多下面的函数来获得任意属性的值：QVariant QObject::property(QString propertyName);QVariant是一个联合体的封装，其中包含了所有基本类型和所允许的全部Q_PROPERTY类型。QVariant有一个toString()函数能够为它支持的许多类型返回其QString表示。QVariant对象可以通过QMetaProperty::read()或者QObject::property()获得同一类的所有对象会共享同一个metaObject，因而会有相同元属性组1234567891011121314151617QString objTOString(const QObject* obj)&#123; QStringList result; const QMetaObject* meta = obj-&gt;metaObject(); result += QString(\"class %1:public %2 &#123;\").arg(meta-&gt;className()).arg(meta-&gt;superClass()-&gt;className()); for(int i=0;i&lt;meta-&gt;propertyCount();++i)&#123; const QMetaProperty qmp=meta-&gt;property(i); QVariant value = obj-&gt;property(qmp.name()); if(value.canConvert(QVariant::String))&#123; result += QString(\"%1 %2=%3;\") .arg(qmp.typeName()) .arg(qmp.name()) .arg(value.toString()); &#125; &#125; result += \"&#125;;\"; return result.join(\"\\n\");&#125; QMetaType QMetaType是一个用于值类型的辅助类，对于60多种内置类型，QMetaType为每个类型ID关联了一个类型名，从而使构造和析构可以在运行时动态发生。有一个名称为QMetaType::Type的公共枚举，它有所有QVariant兼容类型的值。在QMetaType::Type中的枚举值与QVariant::Type中的枚举值一样通过使用Q_ENUMS宏可以在QVariant系统中加入一些自定义的枚举类型。使用Q_DECLARE_METATYPE(MyType)宏也有可能把自己的值类型加到QMetaType列表中。如果MyType有公共的默认复制构造函数和公共的复制构造函数以及一个公共的析构函数，Q_DECLARE_METATYPE宏使得它可用作QVariant中的自定义类型要注册的元类型必须已经用Q_DECLARE_METATYPE声明过。模板函数qRegisterMetaType()会注册类型T并返回由QMetaType使用的内部ID。这个函数有一个重载版本，qRegisterMetaType(const char* name),它可以让你注册一个名称作为类型T的名称。对于这个函数的调用必须早早地出现在主程序中。 fraction.h12345class Fraction:public QPair&lt;qint32,qint32&gt;&#123;public: Fraction(qint32 n=0,qint32 d=1):QPair&lt;qint32,qint32&gt;(n.d)&#123;&#125;&#125;Q_DECLARE_METATYPE(Fraction); metatype.cpp123456789101112131415161718192021222324252627282930313233int main(int argc,char* argv[])&#123; QApplication app(argc,argv); qRegissterMetaType&lt;Fraction&gt;(\"Fraction\"); Fraction twoThirds(2,3); QVariant var; var.setValue(twoThirds); Q_ASSERT(var.value&lt;Fraction&gt;() == twoThirds); Fraction oneHalf(1,2); Fraction threeQuarters(3,4); QList&lt;Fraction&gt; fractions; fractions&lt;&lt;oneHalf&lt;&lt;twoThirds&lt;&lt;threeQuarters; QFile binaryTestFile(\"testMetaType.bin\"); binaryTestFile.open(QIODevice::WriteOnly); QDataStream dout(&amp;binaryTestFile); dout&lt;&lt;fractions; binaryTestFile.close(); binaryTestFile.open(QIODevice::ReadOnly); QDataStream din(&amp;binaryTestFile); QList&lt;Fraction&gt; frac2; din &gt;&gt; frac2; binaryTestFile.close(); Q_ASSERT(fractions == frac2); creatTest();&#125;void creatTest()&#123; static int fracType = QMetaType::type(\"Fraction\"); void* vp = QMetaType::construct(fracType); Fraction* fp = reinterpret_cast&lt;Fraction*&gt;(vp); fp-&gt;first =1; fp-&gt;second = 2; Q_ASSERT(*fp == Fraction(1,2));&#125; invokeMethod() Qt把信号连接到槽需要一种机制：通过名称以类型安全的方式来间接调用这些槽，当调用槽时，实际是由invokeMethod()完成的。 与QObject::connect()类似，invokeMethod()接受一个可选参数Qt::ConnectionType,该参数可让你来决定是要用同步调用还是要用异步调用。默认情况下是Qt::AutoConnection，表示发射者和接收者处于同一线程中时会同步执行一个槽 要通过invokeMethod()向函数传递类型参数，可以用Q_ARG宏创建一些值，这样会返回一个QGenericArgument，它封装了单个参数的类型和值信息 12345void AutoSaver::saveIfNecessary()&#123; if(!QMetaObject::invokeMethod(parent(),\"save\"))&#123; qWarning()&lt;&lt;\"AutoSaver:error invoking save() on parent\"; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435QByteArray buffer=...;const bool b = QMetaObject::invokeMethod(m_thread,\"caculateSpectrum\",Qt::AutoConnection,Q_ARG(QByteArray,buffer),Q_ARG(int,format.frequency()),Q_ARG(int,bytesPerSample));``` ## MVC设计模式&gt; 1. MVC由三类对象组成。模型是应用程序对象，视图是它的屏幕展示，控制器定义了用户界面对用户输入的反应行为。&gt; 2. 在Qt中，不同的控制器类的基类是QAbstractItemDelegate。那些连接信号与槽的connect语句也可以认为是控制器代码&gt; 3. Qt中包含有一个模型/视图框架，用于维护数据的组织管理和向用户的呈现方式之间的分离。三个最常用的视图类(列表、树和表格)都是默认提供的。另外，它还提供了抽象的和具体的数据模型，这些数据模型可被扩展和自定义以保存不同类型的数据。&gt; 4. 视图是获取、修改和呈现数据的对象。QAbstractItemModel定义了视图(还有委托)访问数据的一个标准接口。模型中存储供显示和操作的具体数据。通过信号和槽，他们将数据的变化通知给所有相关联的视图。每个视图对象都有一个指向模型对象的指针，视图对象会频繁访问模型的方法以获取或设置数据，或者做各种其他操作。&gt; 5. 模型中每个数据项都用一个模型索引来表示。模型索引为视图和委托提供了在不知道其底层数据结构的情况下间接访问模型中数据项的方法。QModeIndex对象由模型创建，可以被模型、视图或委托代码用于定位数据模型中特定项。QModeIndex对象具有很短的生命周期，可能在刚刚创建后就变成无效的状态，因此它们应该被立即使用而后丢弃&gt; 6. 如果使用一个在若干指令操作前已经存在的QModeIndex，那么应该先调用QModelIndex::isValid（）。QPersistentModelIndex对象具有更长的生命周期，但是在使用前任然应该先调用isValid()来进行检查## 智能指针&gt; 1. 一个重写了指针解引用操作operator*()和operator-&gt;()的类被称为智能指针。&gt; 2. QScopedPointer是一个在指针作用域结束后自动删除所引用对象的智能指针。它类似于std::auto_ptr。复制QScopedPointer是毫无意义的，因为它会导致所引用的对象重复删除&gt; 3. QSharedPointer是一个自动删除它所引用的对象的智能指针，但是它允许被复制，而且QSharedPointer会保持一个引用计数。共享的堆对象只有在最后一个指向它的只能指针销毁时才会被删除。## 输入掩码&gt; 1.所谓的输入掩码，是一种控制用户在输入窗件中可键入的内容的主动模式。它有助于防止输入某些类型的不正确的数据。每个QLineEdit都有一个QString属性用来存储掩码字符。输入掩码可以指定在键入QLineEdit的字符串中那个位置处的何种字符是允许的。该字符串由一些特殊的、预定义的掩码字符和一些占据输入字符串相应位置的普通字符构成&gt; 掩码字符： * A:ASCII字母型字符——大写或者小写 * N:ASCII字母数字型字符——大写或者小写 * X:任意的ASCII字符 * D:ASCII非零数字 * 9:ASCII数字 * H:十六进制数字 * B:二进制数字 * &gt;:随后的字母字符是大写 * &lt;:随后的字母字符是小写 * ！:结束大小写转换 * \\:转义字符```CQLineEdit* m_StringEntry;m_StringEntry-&gt;setInputMask(m_InputMask-&gt;text()); QRegExp 正则表达式是验证输入、从输入中提取数据以及对输入进行搜索和替换的强大工具。Qt提供了QRegExp类，它实现了Perl风格的扩展正则表达式语言的大部分功能 特殊字符： ‘.’可以与任意字符相匹配，称之为元字符 ‘\\n’匹配换行符 ‘\\f’匹配换页符 ‘\\t’匹配制表符 ‘\\xhhhh’匹配一个Unicode字符，其对应的码值是范围为0x0000到0xFFFF之间的一个十六进制数hhhh 量词——说明前面的字符(或字符组)在匹配的表达式中可出现次数的修饰符 ‘+’ 出现1次或者更多次 ‘?’ 出现0次或者1次 ‘*’ 出现0次或者更多次 {i,j} 出现至少i次但不超过j次 字符集——在匹配表达式指定位置允许出现的字符集合 ‘\\s’ 匹配任何空白符 ‘\\S’ 匹配任何非空白符 ‘\\d’ 匹配任何数字字符：从’0’到’9’ ‘\\D’ 匹配任何非数字字符 ‘\\w’ 匹配任何“单词”字符，也就是任意的字母、数字或者下划线 ‘\\W’ 匹配任意的非单词字符 字符集也可以使用方括号指定: [AEIOU]匹配这五个字符中的任意一个 [a-g]短线使此集合可匹配从’a’到’g’的字符 [^xyz]匹配任何除这三字符以外的字符 分组和捕获字符——(圆括号)是可以用来把字符划分成组的特殊字符。字符组可以是后向引用的。也就是说，如果存在一个匹配，那么分组了的值将可以通过各种方法来捕获和访问。为了简便起见，一般规定在一个正则表达式中最多可以引用9个分组，即使用\\1到\\9这样的修饰符。此外还有一个QRegExp成员函数cap(int nth),它返回第那个分组(基于QString的形式返回) 锚点字符——去顶尝试进行匹配操作的边界 脱字符(^),如果它是正则表达式中的第一个字符，则说明匹配过程从字符串的开头处开始 美元符($),如果它是正则表达式的最后一个字符，则表明匹配过程指导字符串的结尾才结束 此外，还有单词边界(\\b)断言或者非单词边界(\\B),有助于我们关注正则表达式本身 Qt环境变量的获取与设置 QProcess::environment()函数和setEnvironment()函数 QProcess和进程控制 QProcess是一个能够非常方便而且跨平台的用于启动和控制其他进程的类。它从QPbject派生而来，可充分利用信号和槽来简化和其他Qt类的交互 一个QProcess可以使用start()函数来启动另外一个进程，新进程将会成为一个子进程并且在父进程终止时而随之终止 Qt的线程模型允许线程的优先次序和控制。QThread是一个低级类，适合用于显式的构建长期运行的线程 QtConcurrent是一个命名空间，提供了用于编写并发软件的更高层次的类和算法。该命名空间有一个重要的类，QThreadPool，这是一个管理线程池的类。每个Qt应用程序都有一个QThreadPool::globalInstance()函数，它带有一个推荐的最大线程数，在大多数系统上，处理核的数量就是该值的默认值 借助QtConcurrent中函数式的map/filter/reduce算法，通过将进程分布在由线程池管理的多个线程上，可编写一个能够自动利用系统多核的程序。另外，在命令模式和利用QtConcurrent::run()工作时可把QRunnable用作基类。在这些情况下，无须显示地创建线程或者直接管理他们，只需简单把工作片段描述为具有正确接口的对象即可","tags":[{"name":"Qt4","slug":"Qt4","permalink":"https://suda-morris.github.io/tags/Qt4/"}]},{"title":"POE Introduction","date":"2015-07-06T12:16:00.000Z","path":"2015/07/06/poe-introduction/","text":"什么是POE 以太网供电（Power over Ethernet，简称PoE）也称为PoE供电，是一种可以在以太网路中透过双绞线来传输电力与资料到装置上的技术。以太网供电技术的出发点是让IP电话、WLAN接入点、网络摄像头等小型网络设备，可以直接从以太网线（4对双绞线中空闲的2对来传输）获得电力，无需单独铺设电力线，以简化系统布线，降低网络基础设施的建设成本。 使用POE的注意事项 使用POE需要留意以下三点： 如上图所示，不是所有的以太网交换机都支持PoE供电功能，供电模块内置或外置，一般价格比普通交换贵一些。 要求终端也支持PoE受电功能。 通过网线供电，功率本身是有一定限制的，留意查看不同设备的使用说明和功率要求。 典型的系统 一个典型的以太网供电系统。在配线柜里保留以太网交换机设备，用一个带电源供电集线器(Midspan HUB)给局域网的双绞线提供电源。在双绞线的末端，该电源用来驱动电话、无线接入点、相机和其他设备。为避免断电，可以选用一个UPS。 原理 标准的五类网线有四对双绞线,但是在10M BASE-T和100M BASE-T中只用到其中的两对。IEEE80 2.3af允许两种用法: 应用空闲脚供电时,4、5脚连接为正极,7、8脚连接为负极。 应用数据脚供电时,将DC电源加在传输变压器的中点,不影响数据的传输。在这种方式下线对1、2和线对3、6可以为任意极性。 IEEE802.3af标准不允许同时应用以上两种情况。电源提供设备PSE只能提供一种用法,但是电源应用设备PD必须能够同时适应两种情况。该标准规定供电电源通常是48V、13W的。PD设备提供48V到低电压的转换是较容易的,但同时应有1500V的绝缘安全电压。 POE典型组网图 参数 一个完整的POE系统包括供电端设备(PSE, Power Sourcing Equipment)和受电端设备(PD, Powered Device)两部分。PSE设备是为以太网客户端设备供电的设备,同时也是整个POE以太网供电过程的管理者。而PD设备是接受供电的PSE负载,即POE系统的客户端设备,如IP电话、网络安全摄像机、AP及掌上电脑( PDA)或移动电话充电器等许多其他以太网设备（实际上,任何功率不超过13W的设备都可以从RJ45插座获取相应的电力）。 POE标准供电系统的主要供电特性参数为： 电压在44～57V之间,典型值为48V。 允许最大电流为550mA,最大启动电流为500mA。 典型工作电流为10～350mA,超载检测电流为350～500mA。 在空载条件下,最大需要电流为5mA。 为PD设备提供3.84～12.95W三个等级的电功率请求,最大不超过13W。（注意PD分级0和分级4没有显示出来而且不应采用。） 2009年10月30日 IEEE出了一个最新的802.3at标准，其中规定了POE可以提供更高的功率，超过了13W，可以达到30W,分三个等级(7W,15.4W,30W) 一般设备上会标明：15.4W/802.3af,30W/802.3at 工作过程 检测 一开始,PSE设备在端口输出很小的电压,直到其检测到线缆终端的连接为一个支持IEEE 802.3af标准的受电端设备。检测电源输出线对之间的阻容值来判断PD是否存在 PD端设备分类 当检测到受电端设备PD之后,PSE设备可能会为PD设备进行分类,并且评估此PD设备所需的功率损耗。 开始供电 在一个可配置时间(一般小于15μs)的启动期内,PSE设备开始从低电压向PD设备供电,直至提供48V的直流电源。 供电 为PD设备提供稳定可靠48V的直流电,满足PD设备不越过 30W的功率消耗。 断电 若PD设备从网络上断开时,PSE就会快速地(一般在300～400ms之内)停止为PD设备供电,并重复检测过程以检测线缆的终端是否连接PD设备。 HY931147C网络接口(RJ45，集成网络变压器，POE电源信号分离) 内部结构图 两个二极管桥确保1236和4578都能用来供电，同时也能确保12作为正或者36作为正互相兼容 POE电源工作回路 IEEE 802.3af：15.4W供电功率，在100米最大电缆损耗条件下可传送13W的功率 IEEE 802.3at：30W供电功率，在100米最大电缆损耗条件下可输送25.5W的功率 POE电源工作回路 POE等级界限（按终端设备划分） Class1：可向PD输送3.84W的最大功率 CLass2：可向PD输送6.49W的最大功率 Class3：可向PD输送13.0W的最大功率 Class4：可向PD输送25.5W的最大功率 POE工作原理 检测 处理PSE的使用以确保远端是PD所期望的功率 避免损坏那些不兼容POE标准的老式设备 低电压、低电流限制探测功能电路寻找25K特征电阻 分级 用于确定PD所需功率的任选过程 可对电源管理有所帮助 中间电压/电流限制探测功能电路寻找四个电流吸收器之一 仅在成功的检测之后进行 电源维护 确保在PD断连时将高压电源拿掉 过流 在链路操作的不同阶段所提供的保护有所不同 防止不良事件的发生 确保在发生PD或电缆布线系统问题时将电源拿掉 POE周期图 线性稳压器 优点 低输出纹波和噪声，无EMI问题 低成本 简单，所需的外部组件极少，易于配置和设计 面对大的负载阶跃，可在Vout上实现快速瞬态响应 易于实现短路保护 缺点 低效率 热问题 Vout必须低于Vin 工作原理 线性稳压器和输出阻抗一起形成了一个分压网络 线型稳压器的作用就像受控的可变电阻器，其可根据输出负载自我调节以保持一个稳定的输出 压降电压：为使线性稳压器处在稳压器的指定工作范围之内，VIN与VOUT之间可接受的最小压差 线型稳压器中的元件可以是双极型晶体管或MOSFET。不同的配置将产生不同的压降电压 双极型线型稳压器具有较高的压降电压，并能支持较高的输入电压且拥有更好的瞬态响应 MOSFET LDO能支持非常低的压降、低静态电流、改善的噪声性能和低电源抑制 静态电流：由稳压器所消耗且不流向输出负载的电流 该规格指标对于需要时钟保持运行的应用（如基带、实时时钟）很重要 电源抑制比（PSRR）：已调输出电压纹波与输入电压纹波之比 该规格指标对于具有高噪声限值要求的应用（如低噪声放大器、音频、RF和无线等）很重要 基带噪声：某个特定频率范围内的总噪声能量 该规格指标对于具有高噪声限值要求的应用（如PLL、TXCO、RF和无线等）很重要 LDO的选择 开关稳压器 优点 高效率 优良的热性能 高功率密度 允许宽输入电压范围 Vout可以低于或高于Vin 可利用变压器提供隔离 可利用变压器提供多个输出 缺点 开关操作会产生较高的输出纹波和噪声 缓慢的瞬态响应（响应带宽约为开关频率的1/10） 高复杂性 工作原理 电感负责储存能量及向输出负载释放能量 电感根据开关管的开通从输入端获得能量 三种基本的直流开关变换器拓扑（公式推导基于电感的平均电压为0，D为PWM占空比） 基本拓扑 同步与非同步 同步与非同步 隔离式与非隔离式 隔离式变换器在输入和输出之间没有电流回路，原副边不同地 变压器通过磁场将能量从初级耦合至次级 隔离式变换器通常在需要提供初级至次级不同地，高可靠性、防雷、耐高压等，如隔离的医疗电源 并非标准负载点电源（POL）解决方案所常用 不仅要电气隔离，还要信号隔离，所以反馈回路需要使用光耦 隔离开关电源 电荷泵稳压器 电荷泵稳压器是一种只通过电容器的交替式充电和放点来传送功率的开关稳压器 它适合于具有低负载电流及中等输入-输出电压差的应用 开关操作会产生较高的输出纹波和噪声，输出电流能力受限于电容器 倍压电路 倍压电路 变换器控制系统 由于在电路中实现了闭环控制系统，因此变换器能够在不同的条件下提供一个恒定的电压输出 控制系统工作原理 UVLO(低电压锁定)欠压关断模式可保证IC在供电电压不足的时候不至于损坏，一个低电压锁定（UVLO）电路可确保IC在电池电压未达到安全操作电压前不会激活，UVLO的功能会展示滞后现象，以确保在电源供应上的噪音不会不慎导致系统故障。为了更稳定的工作，某些DC/DC转换器具有UVLO功能，电源开启后，UVLO功能使内部电路处于待机状态，直到DC/DC转换器的输入电压达到UVLO电压，以此来减少消费电流并避免误操作 TPS54160（1.5A,60V,降压DC/DC转换器） 支持3.5V~60V的输入电压范围 内部高端MOSFET的导通电阻200mΩ。（low side一般指MOSFET接地，其驱动信号是基于地信号的，在驱动电路中不需要加电压抬升电路；如果是high side即常说的高端驱动，其驱动信号是浮动的，需要加电压抬升电路） 低负载的转换效率也很高，因为设计了独特的Pulse Skipping Eco-mode 可调节的UVLO电压和滞后时间 116uA的静态工作电流 1.3uA的关断电流 100KHz~2.5MHz的开关频率 与外部时钟同步 内部有0.8V的参考电压 欠压（UV）输出保护内部默认设置为2.5V，但是可以通过EN引脚来提高 输出电压启动坡度可以通过SS（slow start）引脚来控制 简化的原理图 在BOOT引脚和PH（内部高端MOEFET的源极）引脚之间需要一个自举电容，当其上的电压少于器件的最低要求，输出将会被关闭，直到自举电容被刷新 COMP是误差放大器的输出，并且会输入到内部的电流比较器中。这个引脚需要连接频率补偿元件 EN脚电压低于1.2后会使芯片不工作，悬空可以工作（芯片内部该引脚上拉到电流源）。要求电压范围不超过5V PWRGD开漏输出，如果芯片过压、关断、跌落，该引脚会输出低电平 RT(Resistor Timing)/CLK内部的放大器会使该引脚维持在一个固定的电压值，该引脚通过一个连接到地的电阻来设置开关频率 SS/TR该引脚到地的电容可以设置输出电压的抬升时间，降低启动过程中的浪涌电流 VSENSE反馈电压不能超过3V 电流模式控制可以降低输出电容，简化频率补偿 内部结构图 输出电压调节 调节输出电压 如果Vin电压小于2.5V，那么TPS54160将不工作，如果需要更高的UVLO电压，可以如图所示 提高UVLO 开关频率由以下公式确定 开关频率确定公式 PCB Layout要领 Vin需要使用低等效串联电阻(ESR)的陶瓷电容旁路，可以选择X5R或者X7R的陶瓷电容 减小由旁路电容的连线，Vin引脚和续流二极管的正极所构成的回路 power pad连接到GND，并且通过多个过孔连接至地平面 续流二极管的阴极和输出电感需要靠近PH引脚 Rt电阻离RT/CLK引脚的距离越近越好 Layout举例 开尔文连接开尔文连接是一种用于模拟信号远传的连接方法，其特点是不在驱动器的输出端直接连接反馈到反相端，而是从负载端将反馈接到驱动器的反相端的而一种连接方法，其目的是减小线路电阻引起的误差","tags":[{"name":"POE","slug":"POE","permalink":"https://suda-morris.github.io/tags/POE/"}]},{"title":"Review in C Language","date":"2015-06-27T07:17:00.000Z","path":"2015/06/27/review-in-c/","text":"ifdef和if defined的差别注意两者都有个define的作用，区别在于使用方式上。前者的通常用法是:只能在两者中选择是否有定义123456789#ifdef XXX ....#else ....#endif 对于后者，常用法是：可以在多个中选择是否有定义12345678910111213#if defined xxx1 ....#elif defined xxx2 ....#elif defined xxx3 ....#endif 字节对齐1234567891011/** * @def RT_ALIGN(size, align) * Return the most contiguous size aligned at specified width. RT_ALIGN(13, 4) would return 16. */#define RT_ALIGN(size, align) (((size) + (align) - 1) &amp; ~((align) - 1))/** * @def RT_ALIGN_DOWN(size, align) * Return the down number of aligned at specified width. RT_ALIGN_DOWN(13, 4) would return 12. */#define RT_ALIGN_DOWN(size, align) ((size) &amp; ~((align) - 1)) 小细节 C++并不支持void*隐式转换为其他类型的指针，但是C语言允许 变量命名，所有字符都使用小写，含义多的可以用_进行辅助 全局变量能少用就少用，必须要用的情况下，可以考虑添加前缀g_ 不要将_作为宏的开头或者结尾 要使用#if而不是#ifdef，可以使用define（）来替代#ifdef的功能123#if !define(USERS_DEFINE) #define USERS_DEFINE ... #endif volatile关键字一旦使用了，就是告诉编译器，即使这个变量没有被使用或修改其他内存单元，它的值也可能发生变化。通俗地讲，告诉编译器，不要把你的那一套优化策略用在我的身上 两种不太常见的格式：%[]和%* %[]用于限制读取类型，常见于字符串的过滤。 1234//假设输入：22 hello,string to me!scanf(\"%d %[a-z]\", &amp;tmp, str);//22 helloscanf(\"%d %[^i]\", &amp;tmp, str);//22 hello,strscanf(\"%d %[^,]\", &amp;tmp, str);//22 hello %*是忽略第一个输入，也可以理解为文件宽度(域宽) 12//假设输入：22 33scanf(\"%*d %d\", &amp;tmp);//读到33 12char str[10] = \"dir\";printf(\"%*s%s\",4 ,\"\" , str);//输出: dir,前面有四个空白占位 select机制 select()的机制中提供一fd_set的数据结构，实际上是一long类型的数组， 每一个数组元素都能与一打开的文件句柄（不管是Socket句柄，还是其他文件或命名管道或设备句柄）建立联系，建立联系的工作由程序员完成，当调用select()时，由内核根据IO状态修改fd_set的内容，由此来通知执行了select()的进程哪一Socket或文件可读或可写。 程序去select的时候，如果没有数据输入，程序会一直等待，直到有数据为止，也就是程序中无需循环和sleep 使用Select就可以完成非阻塞（所谓非阻塞方式non-block，就是进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生，则返回一个代码来告知事件未发生，而进程或线程继续执行，所以效率较高）方式工作的程序，它能够监视我们需要监视的文件描述符的变化情况——读写或是异常。 返回值：准备就绪的描述符数，若超时则返回0，若出错则返回-1。 suda-morris","tags":[{"name":"C","slug":"C","permalink":"https://suda-morris.github.io/tags/C/"}]},{"title":"Embedded Linux","date":"2015-06-08T14:30:05.000Z","path":"2015/06/08/embedded-linux/","text":"需要知道的知识点 ext4文件系统是Linux在PC机上最常用的磁盘文件系统，在嵌入式设备上则常用jffs2文件系统和yaffs2文件系统 在Linux操作系统中。对于SCSI磁盘。用sd*来表示，第一个磁盘x为a，第二个磁盘x为b，以此类推。磁盘上的第1个分区编号为1，第2个分区编号为2，以此类推。 swap分区用于Linux在运行期间的虚拟内存使用，其作用类似Windows中的交换文件pagefile.sys ARM core的CPU在复位时通常都从0地址取它的第一条指令 开发环境搭建 所使用的虚拟机是VirtualBox4.3.12，安装的虚拟机是UbuntuMate14.04 使用的开发板是友善出品的Tiny6410 虚拟机网络设置成桥接模式(笔记本的以太网卡，切勿错选成无线网卡) 虚拟机ip地址：192.168.1.88，网关192.168.1.1 系统烧写 Uboot中开发板的IP地址:192.168.1.230,网关192.168.1.1 开发板设置从SD卡启动，需要确保有一张烧写好UBoot的SD卡或者SDHC卡，Linux中的烧写方法： 1234567891011#!/bin/sh#for SDHC Card,total sectors=15523840#dd iflag=dsync oflag=dsync if=u-boot-sd.bin of=/dev/sdb bs=512 count=16 seek=15522798#dd iflag=dsync oflag=dsync if=u-boot-sd.bin of=/dev/sdb bs=512 count=512 seek=15522030#for SD Card,total sectors=1961984dd iflag=dsync oflag=dsync if=u-boot-sd.bin of=/dev/sdb bs=512 count=16 seek=1961966dd iflag=dsync oflag=dsync if=u-boot-sd.bin of=/dev/sdb bs=512 count=512 seek=1961198sync#BL1:total sectors - 2 - 1024(if your SD Card Size &gt; 2G) -16#BL2:total sectors - 2 - 1024(if your SD Card Size &gt; 2G) -16 - 512 - 256 进入Uboot后，测试能否ping通虚拟主机：ping 192.168.1.88。在这之前可以先看看开发板的IP地址是否与虚拟主机在一个网段内，使用UBoot下的命令：pri 使用nfs命令获取虚拟主机上的uboot二进制文件供烧写(次UBoot是用来从NandFlash启动的，不能错选从SD卡启动的UBoot),成功以后会提示用户该文件的大小，这里记为filesize(切记要使用十六进制表示的数字) nfs 50000000 192.168.1.88:/embeded/KDM/images/v1/u-boot.bin 烧写uboot至NandFlash中 nand write.i 50000000 0 $(filesize) 从0地址开始烧写UBoot 使用nfs命令获取虚拟主机上的kernel文件，成功以后会提示用户该文件的大小，这里记为filesize((切记要使用十六进制表示的数字)) nfs 50000000 192.168.1.88:/embeded/KDM/images/v1/Image 烧写kernel到NandFlash中 nand write.i 50000000 80000 $(filesize) 使用nfs命令获取虚拟主机上的根文件系统文件，成功以后会提示用户该文件的大小，这里记为filesize((切记要使用十六进制表示的数字)) nfs 50000000 192.168.1.88:/embeded/KDM/images/v1/yaff2.img 烧写根文件系统到NandFlash中 nand write.yaffs 50000000 580000 $(filesize) 根据需要修改启动参数并保存,例如 setenv bootargs root=/dev/mtdblock2 console=ttySAC0,115200 saveenv 测试图形界面程序 图形界面工具使用的触摸屏校准程序为tslib源码附带的校准程序ts_calibrate,所以如果触摸屏没有校准，可以在Linux系统启动后运行/usr/local/bin/ts_calibrate程序对触摸屏进行校准(通过删除/etc/pointercal文件，可以使得图形界面工具自动调用ts_calibrate程序)，校准完毕会在etc目录下生成pointercal标准文件，供触摸屏库程序转换成符合屏幕的坐标，从而达到校准目的。 交叉编译器 arm-linux-gcc是一个“集合命令”，它包含了4个步骤：预处理，汇编，编译和链接，通过链接阶段便生成ELF格式的可执行文件。4个步骤对应执行的程序为arm-linux-cpp，arm-linux-as，ccl，arm-linux-ld。前三个步骤对应的命令行选项为：-E,-S，-c，如果没有任何参数，则代表经过这4个步骤产生可执行文件。 ELF文件的not stripped属性告诉我们在编译的时候产生的编译阶段需要的符号没有被删除 通常被编译出的程序都会使用到系统的动态库，而这些基本的动态库大部分也都是glibc库中的。例如open,read,write,select,ioctl等应用程序中的函数都是libc.so动态库中提供的，而glibc还提供了libm.so(数学库)，libcrypt.so(安全库)，libld.so(加载库)等。其中libld.so作为加载库负责在应用程序运行时，加载程序所使用到的动态库文件。在我们移植系统的过程中，这些最基本的动态库也需要被移植到根文件系统中去，这样才能保证程序被正常启动。 arm-linux-strip test可以删除可执行文件中不需要的编译符号和段描述信息 arm-linux-objcopy -O binary -S test test.bin 通常被用来将生成的ELF格式的文件转化为只含有二进制指令和程序数据的文件test.bin.也只有这样的二进制指令文件才能直接被硬件执行。 arm-linux-dump -D test &gt; test.dis则是反编译，将ELF格式的可执行文件反编译成汇编信息文件test.dis，有助于代码的查看和调试 arm-linux-readelf -a test | grep ‘Shared’用来获取ELF的头信息，grep ‘Shared’是获取头信息中test可执行文件调用到的动态文件 arm-linux-gcc 针对arm11的设置： –with-cpu=arm1176jzf-s –with-tune=arm1176jzf-s –with-float=softfp bootloader 目标机上的Bootloader通过串口与主机之间进行文件传输，传输协议通常是xmodem/ymodem/zmodem协议中的一种，但是，串口传输速度有限，因此通过以太网连接并借助tftp或者nfs协议来下载文件是个更好的选择 bootloader的stage1通常包括的步骤： 硬件设备初始化 屏蔽所有中断 设置CPU的速度和时钟频率 RAM初始化 关闭CPU内部指令/数据cache 为加载Bootloader的stage2准备RAM空间 复制bootloader的stage2到RAM空间 设置好堆栈指针sp 跳转到stage2的C入口点（修改PC寄存器为核实的地址来实现） bootloader的stage2通常包括的步骤： 初始化本阶段要使用到的硬件设备 至少一个串口用来和终端用户进行I/O输出信息 检测系统内存映射 将kernel镜像和根文件系统镜像从Flash上读到RAM空间中(需要编写Nand Flash裸驱动) 为内核设置启动参数 linux2.4以后的内核都期望以标记列表的形式来传递启动参数，启动参数标记列表以标记ATAG_CORE尅是，以标记ATAG_NONE结束 每个标记由标识被传递参数的tag_header结构以及随后的参数值数据结构来组成，数据结构tag和tag_header定义在Linux内核源码的include/asm/setup.h头文件中 在嵌入式Linux系统中，通常需要由Bootloader设置的常见启动参数有：ATAG_CORE,ATAG_MEN,ATAG_CMDLINE 调用内核，跳转到内核第一条指令处，跳转时要满足下列条件 CPU寄存器的设置 R0=0 R1=机器类型ID，关于Machine Type Number可以参见linux/arch/arm/tools/mach-types R2=启动参数标记列表在RAM中的起始基地址 CPU模式 必须禁止中断(IRQs和FIQs) CPU必须处于SVC模式 Cache和MMU的设置 MMU必须关闭 指令Cache可以打开亦可以关闭 数据Cache必须关闭 U-boot目录结构 与处理器体系结构或者开发板硬件直接相关 通用的函数或者驱动程序 U-Boot的应用程序、工具或者文档 Uboot常用命令 使用命令时，可以使用其开头的若干个字母代替它 当运行一个命令之后，如果它是可重复执行的（代码中使用U_BOOT_CMD定义这个命令时，第三个参数是1），若想再次运行可以直接输入回车 Uboot接受的数据都是16进制，输入时可以省略前缀0x 运行help命令可以看到所有命令的作用，如果要查看某个命令的使用方法，运行help 命令名。可以使用?来代替help Uboot支持串口下载，网络下载，USB下载，相关命令有：loadb,loads,loadx,loady;tftpboot,nfs;usbslave。使用方法： loadx [off] [baud];off表示文件下载后存放的内存地址，baud表示使用的波特率，如果off参数省略，存放的位置为配置文件中定义的宏CFG_LOAD_ADDR tftpboot [loadAddress] [bootfilename]; loadAddress表示文件下载后存放的内存地址，bootfilename表示要下载的文件名称。loadAddress省略，存放的位置为配置文件中定义的宏CFG_LOAD_ADDR。如果bootfilename省略，则使用单板的IP地址构造一个文件名 nfs [loadAddress] [host ip addr:bootfilename];host ip addr表示服务器的IP地址 usbslave [wait] [loadAddress]；在PC端使用dnw工具发送文件，U-boot通过USB Device接口接收文件。wait可以取值1或0，表示是否等得数据传输完成，当wait取0时，在后台进行下载，这时在Uboot仍可执行其他操作。下载文件成功后，Uboot会自动创建或者更新环境变量filezise，它表示下载的文件长度，可以在后续命令中使用$(filesize)来引用它 常用的内存操作命令有：查看内存命令md，修改内存命令mm,填充内存命令mw,复制命令cp。这些命令都可以带上后缀”.b”,”.w”,”.l”表示以字节、字、双字为单位进行操作。 md[.b,.w,.l] address [count],表示以字节、字、双字（默认是双字）为单位，显示从地址address开始的内存数据，显示的数据个数为count mm[.b,.w,.l] address,表示以字节、字或双字为单位，从地址address开始修改内存数据，执行mm命令后，输入新数据后回车，地址会自动增加，Ctrl+C退出 mw[.b,.w,.l] address value [count],表示以字节、字或双字为单位，往开始地址为address的内存中填充count个数据，数据值为value。 cp[.b,.w,.l] source target count,表示以字节、字或双字为单位，从原地址source的内存复制count个数据到目的地址target的内存 nm[.b,.w,.l] address，修改内存值,以一种交互式的方式，按q退出 常用的Nand Flash操作命令只有一个，它根据不同的参数进行不同的操作 nand info，查看Nand Flash信息 nand device [dev]显示或者设置当前使用的Nand Flash nand bad显示Nand Flash的坏块 nand scrub彻底擦除整块Nand Flash中的数据，包括OOB。可以擦除软件坏块标志 nand erase [clean] [off size],擦除Nand Flash，加上clean时表示在每个块的第一个扇区的OOB区加写入清除标记；off、size表示要擦除的开始偏移地址和长度，如果省略off和size表示要擦除整个Nand Flash nand read[.jffs2] addr off size,从Nand Flash偏移地址off处读出size个字节的数据，存放到开始地址为addr的内存中。是否加后缀.jffs的差别只是读操作时ECC校验方法不同 nand write[.jffs2] addr off size,把开始地址为addr的内存中的size个字节数据，写到Nand Flash的偏移地址off处。是否加后缀.jffs的差别只是读操作时ECC校验方法不同 nand read.yaffs addr off size，从Nand Flash偏移地址off处读出size个字节的数据（包括OOB区域），存放到开始地址为addr的内存中 nand write.yaffs addr off size，把开始地址为addr的内存中的size个字节数据(只要有要写入OOB区域的数据)，写到Nand Flash的偏移地址off处 nand dump off，将Nand Flash偏移地址off的一个山区的数据打印出来，包括OOB数据 环境变量命令(下面的命令只是在内存中进行，最后需要使用saveenv命令将更改后的所有环境变量写入Flash中) printenv命令打印全部环境变量，“printenv name1 name2 …”打印名字为name1,name2……的环境变量 setenv name value设置名字为name的环境变量的值为value setenv name删除名字为name的环境变量 启动命令,不带参数的boot,bootd命令都是执行环境变量bootcmd所指定的命令。bootm命令专门用于启动在内存中的用u-boot的mkimage工具处理过的内核镜像 “bootm [addr [arg …]]”命令启动存放在地址addr处的Uboot格式的映像文件（使用Uboot目录tools下的mkimage工具制作得到），[arg …]表示参数，如果addr参数省略，映像文件所在地址为配置文件中定义的宏CFG_LOAD_ADDR go addr [arg …]与bootm命令类似，启动存放在地址addr处的二进制文件，[arg …]表示参数 nboot [[[loadAddr] dev] offset]命令将Nand Flash设备dev上偏移地址off处的映像文件复制到内存loadAddr处，然后，如果环境变量autostart的值为yes，就启动这个映像，如果loadAddr参数省略，存放地址为配置文件中定义的宏CFG_LOAD_ADDR。如果dev参数省略，则它的取值为环境变量bootdevice的值，如果offset参数省略，则默认为0 根文件系统 所有的Linux发行版在对根文件系统布局上都遵循FHS标准的建议规定。该标准规定了根目录下各个子目录的名称及其存放的内容： /bin：必备的用户命令，例如ls,cp等 /sbin:必备的系统管理员命令，例如ifconfig，reboot /dev:设备文件，例如mtdblock0，tty1等 /etc:系统配置文件，包括启动文件，例如inittab /lib:必要的链接库，例如C链接库、内核模块 /home:普通用户主目录 /root:root用户主目录 /usr/bin:非必备的用户程序，例如find、du等 /usr/sbin:非必备的管理员程序，例如chroot，inetd等 /usr/lib：库文件 /var:守护进程和工具程序所存放的可变，例如日志文件 /proc:用来提供内核和进程信息的虚拟文件系统，有内核自动生成目录下的内容 /sys:用来提供内核与设备信息的虚拟文件系统，由内核自动生成目录下的内容 /mnt:文件系统挂载点，用于临时安装文件系统 /tmp:临时性的文件，重启后将自动清除 编译安装busybox： 下载源码包，解压缩后进入文件夹根目录 make defconfig make menuconfig Busybox Settings:选择动态链接C库，指定交叉编译器的prefix为arm-linux-，为各命令安装为指向busybox的软连接，指定busybox的安装位置，选择支持Tab completion和Username completion Applets：基本保持默认设置 make -j4 make install busybox只用到了2个库，通用C库(libc)、数学库(libm),每个库有4个文件，四个文件中，.a文件是静态库文件，另外三个是：实际的共享链接库（libLIBRARY_NAME-GLIBC_VERSION.so），主修订版本的符号链接，指向实际的共享链接库(libLIBRARY_NAME.so.MAJOR_REVISION_VERSION,一旦程序连接了特定的链接库，将会参用该符号链接)，与版本无关的符号链接，指向主修订版本的符号链接(libLIBRARY_NAME.so,是为编译程序时提供一个通用条目) 当使用gcc hello.c -o hello -lm编译程序的时候，gcc会根据-lm的提示，加头(lib)添尾(.so)得到libm.so，从而沿着与版本无关的符号链接(libm.so-&gt;libm.so.6)找到libm.so.6并记录在案(hello的ELF头中)，表示hello需要使用libm.so.6这个库文件所代表的数学库中的库函数。而当hello被执行的时候，动态链接库加载器会从hello的ELF头中找到libm.so.6这个记录，然后沿着主修订版本的符号链接(libm.so.6-&gt;libm-2.3.6.so)找到实际的共享链接库libm-2.3.6.so从而将其与hello做动态链接。可见与版本无关的符号链接是供编译器使用的，主修订版本的符号链接是供动态链接库加载器使用的，而实际的共享链接库则是供应用程序使用的 init进程的主配置文件inittab用于决定init进程要启动哪些子进程，以及如何启动这些子进程。busybox的inittab文件的语法、语义和传统的SYSV的inittab有所不同 inittab文件中每个条目用来定义需要init启动的子进程，并确定它的启动方式，格式为:::,例如：ttySAC0：：ask-first:-/bin/sh 表示子进程要使用的控制台，若省略则使用与init进程一样的控制台 表示运行级别，busybox init程序这个字段没有意义 表示init进程如何空着这个子进程 sysinit：以该方式启动的子进程最先被init启动，该子进程只会被启动一次，如该子进程结束，init将不会重新启动它 wait：系统执行完sysinit条目后才启动该子进程，该子进程只执行一次，init进程必须等待该子进程结束后才能继续执行启动其他子进程的动作 once:系统执行完wait条目后才启动该子进程，该子进程只执行一次，init进程不必等待该子进程的结束就可以执行启动其他子进程的动作 respawn：系统执行完once条目后才能启动该子进程，init进程会持续监测该子进程的状态，若发现该子进程退出，会重新启动它 askfirst：系统启动完respawn条目后才能启动该子进程，与respawn类似，不过init进程先输出“Please press Enter to active this console”，等用户输入回车后才启动子进程 shutdown：当系统关机时启动该子进程 restart：Busybox中配置了CONFIG_FEATURE_USE_INITAB，并且init进程接收到SIGUP信号时执行，先重新读取、解析/etc/inittab文件，再执行restart程序 ctrlaltdel：按下Ctrl+Alt+Del键时启动该子进程，不过在串口控制台中无法输入它 表示进程对应的二进制文件，如果前面有-号，表示该程序是“可以与用户进行交互的” 手工构建/dev目录：新建dev文件夹，在里面sudo mknod console c 5 1,它表示穿件console字符设备文件，主设备号是5，次设备号是1 构建/dev目录的方法是使用udev(user dev),mdev是busybox中对udev的简化实现，其工作原理是：操作系统启动的时候会将识别到的所有设备的信息自动导出到/sys目录，在此基础上，用户态的应用程序mdev -s就可以扫描/sys/class和/sys/block中所有的类设备目录，如果在目录中含有名为“dev”的文件，且文件中包含的是设备号，则mdev就利用这些信息为这个设备在/dev下创建设备节点文件 Linux系统下实现热插拔的机制：当有热插拔事件产生时，内核就会调用位于/sbin目录下的mdev。这时mdev通过环境变量中的ACTION和DEVPATH(这两个变量是系统自带的)来确定此次热插拔事件的动作以及影响了/dev中的哪个目录。接着会看看这个目录中是否有“dev”的属性文件，如果有就利用这些信息为这个设备在/dev下创建或删除设备节点文件。我们需要告知操作系统，当它发现热插拔事件时应调用mdev，而不是别的程序。 嵌入式Linux对文件系统的要求： 要求文件系统在频繁的文件操作下能够保持较高的读写性能，要求低碎片化 Linux下的日志文件系统(XFS,ReiserFS,Ext3等)能保持数据的完整性，但消耗过多的系统资源的弱点使之不能成为嵌入式系统中的主流应用。并且这些都是专门为硬盘类的存储设备进行了优化，对于Flash这类的存储介质并不适用 嵌入式文件系统的载体是以Flash为主的存储介质，Flash的擦除次数是有限的，所以为了延长Flash的使用寿命，应该尽量减少对Flash的读写操作，并尽量使对Flash的写入操作均匀分布在整个Flash上 在内核的配置菜单中可以看到块设备中有哟个ramdisk选项，并可以设置它的大小，默认的大小为4096KB，在配置内核的时候用户也可以指定ramdisk的大小。ramdisk是基于ram的块设备，所以它占据了一块固定内存的大小，并且需要使用mke2fs格式化以及相对应的文件系统的驱动程序去读取设备上的内容。由于ramdisk在很多场合并不太实用，在Linux的2.4版本开始支持了ramfs文件系统，它是一个简单的基于Linux的。可以动态分配大小的内存文件系统，它属于内核虚拟文件系统层(VFS)，与ramdisk相比，并不是基于虚拟在内存中的其他文件系统，例如ext2文件系统。使用方法： mkdir /mnt/ramfs mount -t ramfs none /mnt/ramfs(缺省大小，被限制最大maxsize为内存总和/2) mount -t ramfs none /mnt/ramfs -o maxsize=1000(创建最大大小为1M的ramfs文件系统) tmpfs文件系统既可以使用内存也可以使用磁盘来作为存储介质，并且它的大小和ramfs一样，可以动态分配。它主要用于减少对闪存不必要的写操作这唯一目的。因为tmpfs驻留在RAM中，所以写/读/擦除的操作发生在RAM中而不是在闪存中。因此，当将日志消息写入挂载为tmpfs文件系统的目录时，是将其写入RAM而不是闪存中，在重新引导时不会保留它们。它的原理是： 在Linux内核中有虚拟内存的概念，而虚拟内存是由物理内存RAM和交换分区swap组成，这些虚拟内存资源又是由Linux内核中的虚拟内存子系统管理。tmpfs会向虚拟内存子系统申请页来存储文件，但它不知道虚拟内存子系统分配给自己的页是在物理内存还是属于交换分区 tmpfs文件系统在内核中的打开方式为： 在内核中选择“File systems–Pseudo filesystems–Virtual memory filesystem support”一项来支持对tmpfs虚拟文件系统的管理 在启动时，经常可以看到启动脚本中有以下内容： mount none /dev -t tmpfs 这也是由于Linux系统的设备可以热插拔的原因 ramfs实现机制是将cache在物理内存的文件占用的page不标记为可释放，这样虚拟内存管理系统就不会将这些page释放或者交换到swap，从而实现文件总在物理内存中。tmpfs也是存放于内存中，但它可以被VM交换到swap，它其实是ramfs的一个变体 jffs文件系统被用到NorFlash和小于64MB的NandFlash闪存中 yaffs文件系统在mount的时候需要很少的内存（如果是小页–512B/Page,每1MB NandFlash大约需要4KB内存；大页需要大概1KB RAM/1 MB NandFlash） yaffs文件系统的基本单位是Chunk，相当于页。Chunk中的资料包括两部分：一部分是资料区，占用Flash的一页；另一部分是文件信息以及冗余资料区，占用Flash页的OOB区。其冗余资料主要是ECC校验资料，对于小页的Flash，每页都有6位元祖的ECC资料，对于大页的Flash，每页有24位元祖的ECC资料 yaffs文件系统的第一个块用于存放整个文件系统的信息，所以真实的数据应该从第二个块开始。 ubifs在设计与性能上均较yaffs2、jffs2更适合MLC NandFlash。例如：ubifs支持write-back，其写入的资料会被cache，直到有必要写入时才写到Flash，大大降低分散小区块数量并提高I/O效率。 交叉编译移植所要修改的环境变量 CC编译器，系统默认gcc，需要修改为arm-linux-gcc AR库工具，用以创建和修改库，需要修改为arm-linux-ar LD链接器，系统默认为ld，需要修改为arm-linux-ld RANLIB随机库创建器，系统默认为ranlib，需要修改为arm-linux-ranlib AS汇编器，系统默认为as，需要修改为arm-linux-as NM库查看工具，系统默认为nm，需要修改为arm-linux-nm 新建用户与用户组 在/etc/passwd中第一行新增：root:x:0:0:Root,,,:/root:/bin/sh passwd root,设置root用户密码 chown root:root /bin/busybox,改变busybox的属主，否则将来u+s后第一个用户进程init的权限将不是root的权限 chmod u+s /bin/busybox，这使得普通用户能使用passwd修改自己的密码，同时也使login程序能够正常工作 adduser morris -h /home/morris -s /bin/sh -G morris adduser ftp -h /var/ftp -s /bin/sh -G ftp adduser ftpuser -h /sdcard/local -s /bin/sh -G ftp adduser ftproot -h /sdcard/tmp -s /bin/sh -G ftp 移植telnet服务器 如上创建好用户 修改/etc/inittab,使得telnetd开机自动启动： ::once/usr/sbin/telnetd#这里一定要使用once，不能使用respawn，因为telnetd是守护进程，其实现会fork自己后让自己结束 创建并挂载/dev/pts,它将供telnetd服务使用 mkdir /dev/pts mount -t devpts devpts /dev/pts 更改/dev/tty和/dev/console的权限，以使普通用户登录系统时也能读写控制终端 chmod 666 /dev/tty chmod 600 /dev/console 移植ftp服务器 下载vsftpd2.3.5并解压 修改Makefile，指定交叉编译器CC=arm-linux-gcc 修改vsf_findlibs.sh,将所有/lib和/usr/lib前面加上交叉编译器的库目录地址，比如/embeded/crosstool/arm-wenris-linux-gnueabi/sysroot make -j4,将生成的vsftp复制到开发板根文件系统相应目录/usr/sbin 复制vsftpd依赖的动态库文件到开发板根文件系统相应目录 将模板配置文件vsftpd.conf复制到开发板/etc目录，修改该配置文件，使有效配置如下： 123456789101112131415anonymous_enable=NOlocal_enable=YESwrite_enable=YESanon_upload_enable=NOanon_mkdir_write_enable=NOdirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_file=/var/log/vsftpd.logxferlog_std_format=YESidle_session_timeout=600data_connection_timeout=120nopriv_user=ftpftpd_banner=Welcome to WenRis FTP servicelisten=YES 由于vsftp源代码程序一定要使用一个目录/usr/share/empty,所以必须要预先创建它 修改/etc/inittab,使得vsftpd在开机时候自动启动： ::respawn:/usr/sbin/vsftpd 移植httpd服务器 增加用户www：adduser -S -D -H www 修改/etc/inittab文件，指名httpd的目录和运行账户： ::once:/usr/sbin/httpd -h /www -u www httpd运行时会以普通用户www的身份访问/dev/null设备，因此需要在rcS脚本中修改/dev/null的权限：chmod 666 /dev/null 创建http服务器的主目录和主文件 mkdir /www echo &quot;this is my first web site&quot; &gt; /www/index.html 移植boa网页服务器 获取源码，并解压缩 进入解压后的文件夹 内部的 src文件夹，对源文件进行如下修改：1234567由于arm-linux-gcc 编译器版本过高，对语法的支持有一些改变，所以需要修改compat.h中的 #define TIMEZONE_OFFSET(foo) foo##-&gt;tm_gmtoff为： #define TIMEZONE_OFFSET(foo) foo-&gt;tm_gmtoff不然在编译的时候会提示如下错误： util.c: 100: 1: pasting “t” and “-&gt;” does not give a valid preprocessing token make: [util.o] Error1 123456789101112将boa.c 文件225-227三行的文件注释掉 if (setuid(0) != -1) &#123; DIE(”icky Linux kernel bug!”); &#125;为/* if (setuid(0) != -1) &#123; DIE(”icky Linux kernel bug!”); &#125;*/，否则，但以root权限启动boa服务器的时候，会出现以下错误：boa.c:226 - icky Linux kernel bug!: 然后生成Makefile：./configure 修改生成的Makefile：默认生成的Makefile针对x86平台，我们的目标是针对嵌入式平台，所以需要修改编译器: 123456更改Makefile的31行和32行：CC = gcc CPP = gcc -E更改为CC = arm-linux-gccCPP = arm-linux-gcc -E 在当前目录下编译Boa源文件： make 将生成的boa可执行程序复制到根文件系统的/usr/sbin目录下 将boa.conf文件复制到根文件系统/etc/boa文件夹下面，并且作如下修改： 123456789101112131415161718192021222324252627282930(1) 修改25行的port端口，用来设置服务器监听的端口：# Port: The port Boa runs on. The default port for http servers is 80.# If it is less than 1024, the server must be started as root.Port 80(2) 注释43行的监听IP地址：默认监听该主机上的所有IP地址#Listen 192.68.0.5(3) 修改53、54行的user和Group 启动的UID和GID，使其以root身份启动# User: The name or UID the server should run as.# Group: The group name or GID the server should run as.User rootGroup root(4) 修改116行的DocumentRoot地址，即客户端要显示的HTML页面存放位置# DocumentRoot: The root directory of the HTML documents.# Comment out to disable server non user files.DocumentRoot /usr/local/boa(5) 修改输入网页输入主机IP时要显示的页面：这里设为index.html # DirectoryIndex: Name of the file to use as a pre-written HTML# directory index. Please MAKE AND USE THESE FILES. On the# fly creation of directory indexes can be _slow_.# Comment out to always use DirectoryMakerDirectoryIndex index.html(6) 修改CGI程序存放的位置：以http://IP/cgi-bin/cginame 的方式运行cgi 程序时将在/usr/local/boa/cgi-bin 目录下寻找该程序# ScriptAlias: Maps a virtual path to a directory for serving scripts# Example: ScriptAlias /htbin/ /www/htbin/ScriptAlias /cgi-bin/ /usr/local/boa/cgi-bin/ 创建/var/log/boa/ 目录，这样Boa服务器启动时会在该目录下创建日志文件 将Linux系统上/etc/mime.types 文件复制到根文件系统的/etc 目录下，否则Boa服务器启动不起来 修改/etc/inittab,使得vsftpd在开机时候自动启动： ::once:/usr/sbin/boa 注意事项： 有时候boa服务器并不能随系统启动，运行 /sbin/boa 命令会提示：gethostbyname:: Success，需要如下修改 修改boa.conf 文件将 #ServerName www.your.org.here 改为 ServerName www.your.org.here 移植zlib库 下载zlib库,解压缩 进入终端，声明几个重要的环境变量： 123456export CC=arm-linux-gccexport AR=arm-linux-arexport LD=arm-linux-ldexport RANLIB=arm-linux-ranlibexport STRIP=arm-linux-stripexport CC_FOR_BUILD=gcc ./configure –shared –prefix=$PWD/results make -j4 make install 成功后把lib里面的库文件复制到根文件系统对应目录，并把库文件和头文件复制到交叉编译器的对应文件夹中，注意复制到时候带上参数 -P 移植libxml2库 下载libxml2库，解压缩 进入终端，声明几个重要的环境变量： 123456export CC=arm-linux-gccexport AR=arm-linux-arexport LD=arm-linux-ldexport RANLIB=arm-linux-ranlibexport STRIP=arm-linux-stripexport CC_FOR_BUILD=gcc ./configure –prefix=$PWD/results –host=arm-linux –target=arm-linux make &amp;&amp; make install 将生成的lib和include移植到交叉编译器，将bin文件，lib文件移植到开发板根文件系统中的bin目录和lib目录中 移植SQLite数据库 获取源码,并解压缩 配置并进行交叉编译和安装 ./configure --enable-shared --prefix=/work/rootfs/sqlite/result --host=arm-linux make -j4 &amp;&amp; make install 最终在result文件夹下面会得到四个文件夹:bin include lib share 将bin文件夹下的程序放到根文件系统的usr/bin 目录下 将lib文件夹下的动态库及其一个软连接复制到根文件系统的lib目录下，并将lib文件下的所有的动态链接库文件复制到交叉编译器的链接lib文件夹下 将include文件夹下的头文件复制到交叉编译器的头文件路径中 移植PHP5.4.42 下载php源代码，解压缩 执行如下配置选项,配置之前需要先交叉编译好zlib，libxml2，sqlite3，iconv的库文件，然后在下面的脚本中指名其路径 1234567891011121314151617181920212223242526./configure --prefix=/opt/php-arm \\--with-config-file-path=/opt/php-arm/etc \\--host=arm-linux \\--disable-cli \\--disable-fileinfo \\--disable-debug \\--disable-rpath \\--enable-ftp \\--enable-inline-optimization \\--enable-pdo \\--enable-bcmath \\--enable-calendar --enable-sockets \\--enable-wddx \\--enable-mbstring \\--enable-mbregex \\--enable-sysvsem \\--with-pear \\--with-regex=system \\--with-xmlrpc \\--with-gettext \\--with-sqlite3 \\--with-pdo-sqlite=/embeded/WenRisOS/rootfs/sqlite-3.8.10.2/result \\--with-libxml-dir=/embeded/WenRisOS/rootfs/third-libs/libxml2 \\--with-zlib-dir=/embeded/WenRisOS/rootfs/third-libs/zlib \\--with-iconv-dir=/embeded/WenRisOS/rootfs/third-libs/iconv \\ configure执行完成以后，查看Makefile文件，确保里面的交叉编译器是arm-linux-gcc,重点检查：CC,CPP;检查EXTRA_LIBS是否有-liconv,-lxml2;检查头文件包含路径是否指向交叉编译的include路径(将所有的/usr/include替换掉交叉编译器对应的/usr/include) make &amp;&amp; make install 将prefix所指路径的文件安装到开发板对应的地方(在这里也是开发板的/opt/php-arm文件下) 在开发板/opt/php-arm夹下新建文件夹etc，存放php配置文件php.ini(从源代码中复制一份修改名字即可) 移植嵌入式ssh服务器-dropbear 下载源码包，解压缩 配置： 12345678910\\#!/bin/sh./configure --prefix=$PWD/results \\--host=arm-linux \\--with-zlib=/embeded/WenRisOS/rootfs/third-libs/zlibmake make scpmake installcp scp results/binarm-linux-strip results/bin/* results/sbin/* 将生成的bin，sin放到开发板相应文件夹下 登陆开发板，创建dropbear配置目录，并生成密钥1234mkdir /etc/dropbearcd /etc/dropbeardropbearkey -t rsa -f dropbear_rsa_host_keydropbearkey -t dss -f dropbear_dss_host_key 编译tslib 源码下载地址 解压缩，进入tslib源码文件夹 ./autogen.sh生成configure源代码配置文件 ./configure --host=arm-linux --disable-h3600 --disable-arctic2 --disable-mk712 --disable-collie --disable-corgi --disable-ucb1x00 --with-gnu-ld --prefix=/embeded/tslib_install ac_cv_func_malloc_0_nonnull=yes 这里，–host的含义是你要安装的目标系统，后面的–disable 是因为我们不编译对指定触摸屏的支持，我们选择支持的是Linux的input子系统，–with-gnu-ld是确认使用GNU的LD连接器，因为我们使用的就是GNU的编译器，所以选择这一项。–prefix选项是指定安装的位置。ac_cv_func_malloc_0_nonnull会在./configure执行阶段测试GNU内置的malloc函数的功能是否可用或者说是否兼容 进入安装目录，这里是/embeded/tslib_install,进入etc目录，打开ts.conf进行修改.其中pthres主要用于处理触摸屏的灵敏度，而variance和dejitter分别用于处理触摸屏的滤波和去噪的算法，linear是触摸屏的坐标变换。 module_raw input module pthres pmin=1 module variance delta=30 module dejitter delta=100 module linear Qt移植(Qt支持的嵌入式Linux平台需要有frambuffer支持) 下载软件包，解压缩 进入源代码根文件目录，执行配置命令如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152\\#!/bin/sh./configure -prefix /opt/qt4.8.5-arm \\-opensource \\-confirm-license \\-release \\-shared \\-embedded arm \\ #选择Qt的嵌入式平台为arm平台-xplatform qws/linux-arm-g++ \\-platform qws/linux-x86-g++ \\-depths 4,8,16,18,24,32 \\-optimized-qmake \\-qt-sql-sqlite \\-qt-zlib \\-webkit \\-qt-gfx-transformed \\-qt-libjpeg \\ #使Qt支持jpeg图片显示-qt-libpng \\-qt-libtiff \\-qt-libmng \\-qt-freetype \\-little-endian \\-host-little-endian \\-make libs \\-nomake tools \\-nomake docs \\-make examples \\-make demos \\-qt-kbd-linuxinput \\-no-qt3support \\-no-phonon \\-no-phonon-backend \\-no-gif \\-no-dbus \\-no-rpath \\-qt-mouse-tslib \\ #使Qt支持触摸方式，需要额外指定tslib的路径-qt-mouse-pc \\-no-mouse-linuxtp \\-qt-gfx-linuxfb \\-no-neon \\-no-nis \\-no-cups \\-no-openssl \\-no-fast \\-no-scripttools \\-no-mmx \\-no-3dnow \\-no-sse \\-no-sse2 \\-I /embeded/WenRisOS/rootfs/tslib/target-arm/include \\-L /embeded/WenRisOS/rootfs/tslib/target-arm/lib \\-R /embeded/WenRisOS/rootfs/tslib/target-arm/lib \\-D__ARM_ARCH_5TEJ_ #选择处理器平台 make &amp;&amp; make install 将生成的lib文件和plugins文件部署到根文件系统中，字体保存在lib下的fonts目录下 MP3播放器madplay移植 进入官网下载3个源码包 移植libid3tag库需要依赖zlib库，所以需要先前把zlib的头文件和动态链接库文件保存在交叉编译器的头文件路径和库文件路径下 进入libid3tag源码文件夹，执行配置命令：./configure –prefix=/embeded/WenRisOS/rootfs/madplay/target-arm –host=arm-linux make &amp;&amp; make install，把生成的头文件和库文件放入交叉编译器中 进入libmad源码文件夹，执行配置命令：./configure –prefix=/embeded/WenRisOS/rootfs/madplay/target-arm –host=arm-linux make &amp;&amp; make install,把生成的头文件和库文件放入交叉编译器中 进入madplay源码文件夹，执行配置文件：./configure –prefix=/embeded/WenRisOS/rootfs/madplay/target-arm –host=arm-linux make &amp;&amp; make install gdb/gdbserver gdb和gdbserver可以看作两个不同的命令。gdb放在宿主机上运行，而gdbserver被放在开发板上运行。启动gdbserver运行制定的需要调试的可执行文件，而在宿主机中使用gdb来运行同样的可执行文件，通过串口或者tcp就可以达到远程调试的目的。由于宿主机gdb所运行的程序和gdbserver是一样的，都是arm指令的elf文件，那么作为宿主机gdb工具必须能够明确地知道遵循ABI接口的ARM的ELF文件格式。因此，传统的宿主机自身携带的gdb不能用于调试嵌入式ARM程序，我们需要下载gdb的源代码，增加对ARM的ELF格式的支持才能够调试ARM程序。 编译宿主机上的arm-linux-gdb程序（如果在busybox中添加过了gdb的选项，不必再编译arm-linux-gdb了，已经有了） ./configure –target=arm-linux –enable-werror=no –target指定宿主机调试的目标机类型，在编译的时候会编译出符合arm-linux的调试的gdb工具 –enable-werror的含义是在编译的时候增加-Werror选项，这样会把一些原本的警告信息当做错误。由于gdb的部分代码写的并不规范，所以-Werror会报出一些错误 进入gdb/gdbserver目录下，执行以下命令： ./configure –host=arm-linux –target=arm-linux make arm-linux-strip gdbserver –host指定编译出的工具运行在什么平台 –target为指定的编译器配置目标环境 gdb远程调试命令 Target remote ip：port executable；target命令用于连接一个远程的gdbserver，ip和port为远程主机的ip和端口号，executable为gdbserver需要调试的程序，这个文件在gdb所在的宿主机上不能被strip，否在调试需要的symbols就不存在了 file executable；在gdb调试之前，需要使用file命令获取可执行文件的符号，以获得调试需要的符号列表 show/set sysroot；因为调试的时候需要用到交叉编译器的库文件和工具，所以必须制定，set用于设置sysroot路径，show用于显示gdb内置变量的值 show/set solib-search-path;solib-search-path必须设置，因为远程调试的程序在运行时会调用到动态库，需要把所有的动态库都加载到这个变量中，像LD_LIBRARY_PATH一样 List/l;调试的时候我们可以通过这个命令查看源代码 break/b linenumber/function;设置断点，在运行时会停止在设置的断点处，断点可以设置为代码的行号，也可以在指定的函数处停止 continue/c;继续，使用gdb/gdbserver，没有run这个命令，因为程序实际通过stub在gdbserver所对应的开发板上运行 next/n;执行一条指令，但不会进入函数内部 print/p;打印变量的值 step/s;单步跟踪，如果有函数，会进入函数内部，可以通过finish命令退出函数 quit/q;退出gdb调试环境 步骤演示 开发板执行arm-linux-gdbserver命令，开启调试服务端程序test：arm-linux-gdbserver 192.168.1.230:6410 test;命令的参数类型为: ,ip为开发板的网络地址，端口号由用户指定，代表服务应用程序所使用的网络端口，app为需要调试的应用程序的名字 宿主机把调试文件载入gdb调试器（可执行文件必须要有调试信息，比如编译时候加上-g，Qt下是qmake CONFIG+=debug）：arm-linux-gdb test 向应用程序传递参数，比如：set args -qws 确认参数是否被正学设置：show args 设置交叉编译器动态库文件路径：set sysroot /embeded/wenris-xtools/arm-wenris-linux-gnueabi/sysroot;如果在交叉编译的时候指定–with-sysroot，则可以省略。最后通过show sysroot命令查看是否设置成功 设置程序运行时的动态库：set solib-search-path /work/qt/qt-4.7-arm/lib:/work/qt/tslib_install/lib:/work/qt/tslib_install/lib/ts 链接到gdbserver：target remote 192.168.1.230:6410 执行gdb相关的代码调试命令进行远程调试","tags":[{"name":"Linux","slug":"Linux","permalink":"https://suda-morris.github.io/tags/Linux/"}]},{"title":"GNS3 Install","date":"2015-06-08T03:24:00.000Z","path":"2015/06/08/gns3/","text":"GNS3模拟器安装步骤 下载GNS3，并且安装 下载GNS3 IOU VM虚拟机镜像 下载路由器和交换机的IOS镜像文件(百度搜索并下载) i86bi-linux-l2-ipbasek9-15.1g.bin(交换机) i86bi-linux-l3-adventerprisek9-15.4.1T.bin(路由器) 安装virtualbox 导入步骤2中下载的GNS3虚拟机镜像，设置网卡为hostonly，并启动虚拟机 GNS3是基于linux系统的，root用户登录，密码为cisco，然后查看网卡ip地址ifconfig 在浏览器中输入刚才查找到的IP地址，并指名端口号8000下的upload，例如：http://192.168.172.101:8000/upload 打开GNS3软件，在edit-&gt;Preference-&gt;Server中添加虚拟机的IP地址以及端口(ip地址来自步骤6) 在edit-&gt;Preference-&gt;IOS on UNIX中，指名iourc.txt的路径 在edit-&gt;Preference-&gt;IOU devices中，添加switch和router镜像路径(路径为上传到虚拟机中的具体路径，例如：/home/gns3/GNS3/images/IOU/i86bi-linux-l2-ipbasek9-15.1g.bin) 启动设备 suda-morris","tags":[{"name":"GNS3","slug":"GNS3","permalink":"https://suda-morris.github.io/tags/GNS3/"}]},{"title":"Python Basic","date":"2015-05-28T13:42:00.000Z","path":"2015/05/28/python/","text":"Python中的常量常量定义1234567891011121314class _const(object) class ConstError(TypeError): pass def __setattr__(self,name,value): if self.__dict__.has_key(name): raise self.ConstError,\"Can't rebind const(%s)\" % name self.__dict__[name] = value def __delattr__(self,name): if name in self.__dict__: raise self.ConstError,\"Can't unbind const(%s)\" % name raise NameError, nameimport syssys.modules[__name__] = _const() 把以上代码变成const.py文件放到Python安装目录的Lib文件夹下 引号的使用与区别 单引号与双引号可以交叉使用，即双引号中的单引号维持原样，单引号中的双引号维持原样 三引号里面不能使用单引号和双引号，三引号中的格式维持不变，该回车就回车，该空格就空格 当需要把转义字符原样输出的时候可以使用自然字符串，即在字符串前面加r 子字符串运算方法： 索引运算（从0开始索引） 切片运算（[a:b]是指从第a下标开始到第b-1下标结束，同样第一位下标为0） 列表中的元素是有序的 students=[“小明”,”小华”,”小李”,”小娟”,”小云”]，下标从0开始 元祖里面的内容只能读取，不能修改，列表里面的内容既可以修改，又能读取 students=(“小明”,”小华”,”小李”,”小娟”,”小云”) Python中集合主要有两个功能，一个功能是建立关系，另一个是消除重复元素，集合的格式是：set(元素) 交集：&amp; 并集：| 差集：- 消除重复元素：new=set(a) 字典也叫关联数组，用大括号括起来 k={“name”:”Java”,”IDE”:”Eclipse”} print k[“IDE”] 添加字典里面的项目k[“User”]=”morris” Python中的标识符第一个字符必须只能是字母或者下划线，之后的部分可以使字母，下划线或者数组 在Python中，如果有一些对象需要持久性存储，并且不丢失我们这个对象的类型与数据，我们需要将这些对象进行序列化，序列化之后，需要使用的时候我们再回复为原来的数据。序列化的这种过程我们称之为pickle（腌制） import pickle lista=[“mingyue”,”jishi”,”you”] listb=pickle.dumps(lista)#序列化 listc=pickle.loads(listb)#将对象原样恢复 group1=(“bajiu”,”wen”,”qingtian”) f1=file(‘1.pkl’,’wb’) pickle.dump(group1,f1,True) f1.close() f2=file(‘1.pkl’,’rb’) t=pickle.load(f2) f2.close() Python的行连接符：\\ 数据类型 Python语言的类型有：数字类型，字符串类型，元组类型，列表类型，文件类型，字典类型 数字类型 复数类型的表示：z=a+bj,其中a是实数部分，b是虚数部分，a和b都是浮点类型 字符串类型 假设字符串长度为L，那么字一个字符的序号为0或者-L，最后一字符的序号是L-1或者-1 字符串之间可以通过+或*进行连接，加法操作将两个字符串连接成为一个新的字符串，乘法操作构建一个由其本身字符串重复连接而成的字符串 大多数数据类型都可以通过str()函数转换为字符串 遍历字符串中每个字符：for &lt;var&gt; in &lt;string&gt; 字符串处理方法 元祖类型 元祖是包含多个元素的类型，元素之间用逗号分隔。元祖可以是空的，元祖外侧可以使用括号，也可以不使用 元祖中元素可以是不同类型，元组中各元素存在先后关系，可以通过索引访问元祖中元素，元祖定义后不能修改，也不能删除 列表类型 列表与元祖类似，列表中每个元素可以不一样，访问列表中元素时采用索引形式 列表的大小没有限制，可以随时修改 列表的操作 文件类型 文件的打开模式 文件的打开模式 文件读取 文件读取 文件写入 文件写入 遍历文件的模板 遍历文件的模板 字典 针对非序列集合而提供的一种数据类型 通过任意键值查找集合中信息的过程叫映射，python中通过字典实现映射。字典就是一个键值对的集合 使用大括号创建字典 使用中括号为字典增加一项：dictionaryName[key]=value 访问字典中的值：dictionaryName[key]返回键key对应的value 删除字典中的一项：del dictionaryName[key] 字典的遍历 字典的遍历 判断一个键是否在字典中，可以使用命令in或者not in 字典的标准操作符 字典的标准操作符 字典方法 字典方法 文件拷贝1234567891011121314151617181920def main(): f1 = input(\"Enter a source file name:\").strip() f2 = input(\"Enter a destination file name:\").strip() infile = open(f1, 'r') outfile = open(f2, 'w') count_lines = count_chars = 0 for line in infile: count_lines += 1 count_chars += len(line) outfile.write(line) print(count_lines, \"lines and\", count_chars, \"chars copied\") infile.close() outfile.close()main() 数学库及其应用 数学库及其应用 随机数库及其应用 随机数库及其应用 Python异常处理机制Python使用try…except…else…finally，可使程序不因运行错误而崩溃,异常捕获机制可以捕捉任何类型的错误，比如：输入非数值类型（NameError），输入无效的表达式(SyntaxError)等。只有当try中的语句没有发生异常，else语句才会被执行，finally无论有无异常都会被执行123456789101112try: &lt;body&gt;except &lt;ErrorType1&gt;: &lt;handler1&gt;except &lt;ErrorType2&gt;: &lt;handler2&gt;except: &lt;handler0&gt;else: &lt;process_else&gt;finally: &lt;process_finally&gt; ETC 使用同步赋值语句实现x与y的值交换：x,y=y,x val=pow(2,1000),用一行代码返回val结果的长度值:len(str(val)) 布尔运算符的优先级从高到低依次是：not，and，or 对于数字的零值被认为是false，任何非零值都是true。对序列类型来说，空序列被认为是false，非空序列认为是true 常用编码 ASCII码是标准化字符集，用7个二进制位编码表示128个字符 Unicode跨语言，跨平台，同意且唯一的二进制编码，每个字符两个字节长 UTF8编码，可变长度的Unicode，英文对应1个字节，中文对应3个字节 python中字符串类型未编码，可以用encode()进行编码，decode()进行解码 python中的编解码 turtle库的常用指令 turtle库以屏幕中心为坐标原点 forward（distance）将箭头移到某一指定坐标 left（angle）/right（angle）向左/右旋转一个角度 penup（）提起笔，用于另起一个地方绘制时使用，与pendown()配对使用 goto(x,y) home() circle(radius) speed() 使用turtle库绘制五角星123456789101112import turtlep = turtle.Turtle()p.speed(3)p.pensize(5)p.color(\"black\")p.fillcolor(\"red\")p.begin_fill()for i in range(5): p.forward(200) p.right(144)p.end_fill() 使用turtle库绘制蟒蛇1234567891011121314151617181920import turtledef draw_snake(rad, angle, len, neckrad): for i in range(len): turtle.circle(rad, angle) turtle.circle(-rad, angle) turtle.circle(rad, angle, 2) turtle.fd(rad) turtle.circle(neckrad + 1, 180) turtle.fd(rad * 2 / 3)def main(): turtle.setup(1300, 800, 0, 0) pythonsize = 30 turtle.pensize(pythonsize) turtle.pencolor(\"blue\") turtle.seth(-40) draw_snake(40, 80, 5, pythonsize / 2)main() 使用turtle库绘制树123456789101112131415161718192021222324252627282930313233343536373839404142434445import turtledef tree(plist, l, a, f): \"\"\" plist is a list of pens l is the length od branch a is half of angle between 2 branches f is factor by which branch is shortened from level to level \"\"\" if l &gt; 5: lst = [] for p in plist: p.forward(l) q = p.clone() p.left(a) q.right(a) lst.append(p) lst.append(q) tree(lst, l * f, a, f)def maketree(x, y): p = turtle.Turtle() p.color(\"green\") p.pensize(5) p.hideturtle() # p.speed(5) p.getscreen().tracer(30, 0) # 调整绘画的速率 p.left(90) p.penup() p.goto(x, y) p.pendown() tree([p], 110, 65, 0.707)def main(): turtle.title(\"使用turtle绘制树\") turtle.setup(1200, 800, 0, 0) maketree(-300, -300) maketree(0, 0) maketree(300, -300)main() 数据驱动的动态路径绘制1234567891011121314151617181920212223242526272829303132import turtledef main(): turtle.title(\"数据驱动的动态路径绘制\") turtle.setup(800, 600, 0, 0) pen = turtle.Turtle() pen.color('red') pen.width(5) pen.shape(\"turtle\") pen.speed(5) result = [] file = open(\"a.txt\", 'r') for line in file: result.append(list(map(float, line.split(',')))) print(result) for i in range(len(result)): pen.color((result[i][3], result[i][4], result[i][5])) pen.forward(result[i][0]) if result[i][1]: pen.right(result[i][2]) else: pen.left(result[i][2]) pen.goto(0, 0)if __name__ == '__main__': main() 使用蒙特卡洛方法估计圆周率的值123456789101112131415from random import *from math import *from time import *DARTS = 1000000hits = 0clock()for i in range(1,DARTS): x,y=random(),random() dist = sqrt(x**2+y**2) if(dist &lt;= 1.0): hits = hits+1pi = 4*(hits/DARTS)print(\"Pi的值是:%s\"%pi)print(\"程序运行时间是 %-5.5ss\"%clock()) ##寻找素数1234567for n in range(2,100): for x in range(2,n): if n % x == 0: print(n, \"equals\", x, \"*\", n//x) break; else: print(n, \"is a prime number\") 文件循环123456789101112131415161718def main(): file_name = input(\"What's the file path?\") try: infile = open(file_name, 'r') except FileNotFoundError: print(\"\\nFile not found\") else: msum = 0.0 count = 0 line = infile.readline() while line != \"\": msum += eval(line) count += 1 line = infile.readline() print(\"\\nThe average of the numbers is\", msum / count)main() 图形用户界面 TKinter——Python标准GUI 15中常见的Tk控件 常见的Tk控件 3种布局管理方法 Tkinter三种几何管理方法 控件的共同属性 共同属性 Graphics——基于Tkinter扩展 GraphWin对象常用方法 GraphWin对象常用方法 图形对象通用方法 图形对象通用方法 Point对象方法 Point对象方法 Line对象方法 Line对象方法 Circle对象方法 Circle对象方法 Rectangle对象方法 Rectangle对象方法 Oval对象方法 Oval对象方法 Polygon对象方法 Polygon对象方法 Text对象方法 Text对象方法 Turtle——Python内置的图形库 使用graphics库实现交互式多边形绘制123456789101112131415161718192021222324252627282930from graphics import *def main(): win = GraphWin(\"Draw a polygon\", 300, 300) win.setCoords(0, 0, 300, 300) message = Text(Point(150, 20), \"CLick on five points\") message.draw(win) p1 = win.getMouse() p1.draw(win) p2 = win.getMouse() p2.draw(win) p3 = win.getMouse() p3.draw(win) p4 = win.getMouse() p4.draw(win) p5 = win.getMouse() p5.draw(win) polygon = Polygon(p1, p2, p3, p4, p5) polygon.setFill(\"peachpuff\") polygon.setOutline(\"black\") polygon.draw(win) message.setText(\"Click anywhere to quit.\") win.getMouse()main() 使用TKinter实现简单的聊天界面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from tkinter import *import timedef main(): def send_msg(): strMsg = \"我：\" + time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()) + \"\\n\" txtMsgList.insert(END, strMsg, 'greencolor') txtMsgList.insert(END, txtMsg.get('0.0', END)) txtMsg.delete('0.0', END) def cancelMsg(): txtMsg.delete('0.0', END) def send_msg_event(event): if event.keysym == \"Up\": send_msg() # 创建窗口 t = Tk() t.title(\"与Python聊天中\") # 创建Frame容器 frmLT = Frame(width=500, height=320, bg=\"white\") frmLC = Frame(width=500, height=150, bg=\"white\") frmLB = Frame(width=500, height=30) frmRT = Frame(width=200, height=500) # 创建控件 txtMsgList = Text(frmLT) txtMsgList.tag_configure(\"greencolor\", foreground=\"#008c00\") # 创建tag txtMsg = Text(frmLC) txtMsg.bind(\"&lt;KeyPress-Up&gt;\", send_msg_event) btnSend = Button(frmLB, text='发送', width=8, command=send_msg) btnCancel = Button(frmLB, text='取消', width=8, command=cancelMsg) imgInfo = PhotoImage(file=\"python.gif\") lblImage = Label(frmRT, image=imgInfo) lblImage.image = imgInfo # 窗口布局 frmLT.grid(row=0, column=0, columnspan=2, padx=1, pady=3) frmLC.grid(row=1, column=0, columnspan=2, padx=1, pady=3) frmLB.grid(row=2, column=0, columnspan=2) frmRT.grid(row=0, column=2, rowspan=3, padx=2, pady=3) # 固定大小 frmLT.grid_propagate(0) frmLC.grid_propagate(0) frmLB.grid_propagate(0) frmRT.grid_propagate(0) btnSend.grid(row=2, column=0) btnCancel.grid(row=2, column=1) lblImage.grid() txtMsgList.grid() txtMsg.grid() t.mainloop()main() 使用Turtle库绘制模拟时钟123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105from turtle import *from datetime import *def Skip(step): penup() forward(step) pendown()def mkHand(name, length): # 注册Turtle形状，建立表针Turtle reset() Skip(-length * 0.1) begin_poly() forward(length * 1.1) end_poly() handForm = get_poly() register_shape(name, handForm)def Init(): global secHand, minHand, hurHand, printer mode(\"logo\") # 重置Turtle指向北 # 建立三个表针Turtle并初始化 mkHand(\"secHand\", 125) mkHand(\"minHand\", 130) mkHand(\"hurHand\", 90) secHand = Turtle() secHand.shape(\"secHand\") minHand = Turtle() minHand.shape(\"minHand\") hurHand = Turtle() hurHand.shape(\"hurHand\") for hand in secHand, minHand, hurHand: hand.shapesize(1, 1, 3) hand.speed(0) # 建立输出文字Turtle printer = Turtle() printer.hideturtle() printer.penup()def SetupClock(radius): # 建立表的外框 reset() pensize(7) for i in range(60): Skip(radius) if i % 5 == 0: forward(20) Skip(-radius - 20) else: dot(5) Skip(-radius) right(6)def Week(t): week = [\"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\", \"星期日\"] return week[t.weekday()]def Date(t): y = t.year m = t.month d = t.day return \"%s %d %d\" % (y, m, d)def Tick(): # 绘制表针的动态显示 t = datetime.today() second = t.second + t.microsecond * 0.000001 minute = t.minute + second / 60.0 hour = t.hour + minute / 60.0 secHand.setheading(6 * second) minHand.setheading(6 * minute) hurHand.setheading(30 * hour) tracer(False) printer.forward(65) printer.write(Week(t), align=\"center\", font=(\"Courier\", 14, \"bold\")) printer.back(130) printer.write(Date(t), align=\"center\", font=(\"Courier\", 14, \"bold\")) printer.home() tracer(True) ontimer(Tick, 100) # 100ms后继续调用tickdef main(): tracer(False) Init() SetupClock(160) tracer(True) Tick() mainloop()if __name__ == \"__main__\": main() 使用turtle库绘制雪花图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import turtle as ttimport random as rddef ground(): tt.hideturtle() tt.speed(100) for i in range(400): tt.pensize(rd.randint(5, 10)) x = rd.randint(-400, 350) y = rd.randint(-280, -1) r = -y / 280 g = -y / 280 b = -y / 280 tt.pencolor((r, g, b)) tt.penup() tt.goto(x, y) tt.pendown() tt.forward(rd.randint(40, 100))def snow(): tt.hideturtle() tt.pensize(2) tt.speed(100) for i in range(100): r = rd.random() g = rd.random() b = rd.random() tt.pencolor(r, g, b) tt.penup() tt.setx(rd.randint(-350, 350)) tt.sety(rd.randint(1, 270)) tt.pendown() dens = rd.randint(8, 12) snowsize = rd.randint(10, 14) for j in range(dens): tt.forward(snowsize) tt.backward(snowsize) tt.right(360 / dens)def main(): tt.setup(800, 600, 0, 0) tt.tracer(False) tt.bgcolor(\"black\") snow() ground() tt.tracer(True) tt.mainloop()if __name__ == \"__main__\": main() Python库 Python官网提供的Python库索引 Python库的安装 自定义安装,去国内镜像站下载软件国内pipy镜像站 使用pip工具 pip常用命令 文件安装，通过.whl文件安装 pip inatall xxx.whl pip工具的安装 pip源码下载地址 解压后执行：python setup.py install即可 OS库常用函数 OS库常用函数 OS库常用函数 os.path是处理操作系统的一个字库，os.path常用函数 os.path常用函数 os.walk(path)用于遍历一个目录，返回一个三元组 root,dirs,files = os.walk(path) root是字符串，dirs和files是列表类型，表示root中的所有目录和所有文件 sched库 sched库用来进行任务调度 sched.scheduler()用来创建一个调度任务 当需要对一个任务进行时间调度时，用这个函数scheduler.enter(delay,priority,action,argument=()) delay表示延时多少时间去执行 priority表示优先级 action是具体需要调度的函数 argument表示action函数需要的参数变量 scheduler.run（）运行调度任务中的全部调度事件 scheduler.cancel(event)取消某个调度事件 函数定时执行123456789101112131415import schedimport timedef print_time(msg='default'): print(\"当前时间\", time.time(), msg)s = sched.scheduler(time.time, time.sleep)print(time.time())s.enter(5, 1, print_time, argument=(\"延迟5秒，优先级1\",))s.enter(3, 2, print_time, argument=(\"延迟3秒，优先级2\",))s.enter(3, 1, print_time, argument=(\"延迟3秒，优先级1\",))s.run()print(time.time()) 打印某一个目录下的全部文件1234567import ospath = input(\"请输入一个路径:\")for root, dirs, files in os.walk(path): for name in files: print(os.path.join(root, name)) 打包发布python应用程序（使用py2exe库） 确定python程序可以执行，比如lesson.py 写一个发布脚本setup.py（与lesson.py同目录）,在里面指名需要调用运行的python程序 1234from distutils.core import setupimport py2exesetup(console=['lesson.py']) 在命令行下执行python setup.py py2exe 程序正确执行后会生成dist目录和pycache目录，前者包含了发布的exe程序，后者可以删除 NumPy库 NumPy系统是Python的一种开源的数值计算扩展，能够存储和处理大型矩阵 N维数组对象Array 函数库 实用的线性代数、傅里叶变换和随机数生成函数 NumPy提供了许多高级的数值编程工具 矩阵数据类型 矢量处理 运算库 NumPy的主要对象是同种元素的多维数组 维度叫做轴 轴的个数叫做秩 NumPy的数组类被称为ndarray，通常被称作数组 ndarray主要属性 创建数组 使用array函数，利用常规的Python列表和元祖创造数组，所创建的数组类型由原序列中的元素类型决定，例如：a=array([[1,2],[3,4]],dtype=complex) 使用占位符创建数组，例如函数zeros创建一个全是0的数组，函数ones创建一个全是1的数组，函数empty创建一个内容随机并且依赖于内存状态的数组 利用arrange创建数组：arrange(10,30,5),从10开始，每次加5，直到30(不包括) 打印数组，类似于嵌套列表 数组的算数运算按元素进行，NumPy中的乘法运算符*指示按元素计算 矩阵乘法可以使用dot函数或创建矩阵对象实现 NumPy提供常见的数学函数如sin、cos和exp NumPy对于多维数组的运算，缺省情况下并不使用矩阵运算，对数组进行矩阵运算，可调用相应的函数 NumPy库提供了matrix类，使用matrix类创建的是矩阵对象，他们的加减乘除运算采用矩阵方式计算 创建等比数列：numpy.logspace(1,10,3)表示在1到10中生成3个等比数列 创建结构数组： 声明结构数组类型：person=np.dtype({‘names’:[‘name’,’age’],’formats’:[‘S32’,’i’]}) 创建结构数组：a = np.array([(‘zhang’,12)],dtype=person) 访问结构数组的成员：a[0][&#39;name&#39;] 更高级的运算：NumPy线型代数子库linalg inv函数：计算逆矩阵 solve函数：求解多元一次方程组 Matplotlib库 Matplotlib是一个数据可视化函数库 pyplot子库提供了2D图表制作的基本函数 matplotlib提供的直方图绘制函数为hist() matplotlib的image子库可用来对图像进行操作 imread()函数将图像的各像素点的RGB值存入数组 imshow()函数将存有RGB值的图像数组以图像的方式显示出来 使用Matplotlib库绘制曲线12345678910111213141516import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-np.pi, np.pi, 256, endpoint=True)y = np.sin(x)z = np.cos(x * x)plt.figure(figsize=(8, 4))plt.plot(x, z, \"ro\", label=\"$cos(x^2)$\")plt.plot(x, y, label=\"$sin(x)$\")plt.xlabel(\"Time/s\")plt.ylabel(\"\")plt.legend()plt.title(\"matplotlib\")plt.show() 使用Matplotlib子图的功能1234567891011121314151617181920212223import numpy as npimport matplotlib.pyplot as pltw = np.linspace(0.1, 1000, 1000)p = np.abs(1 / (1 + 0.1j * w))plt.subplot(221)plt.plot(w, p, linewidth=2)plt.ylim(0, 1.5)plt.subplot(222)plt.semilogx(w, p, linewidth=2)plt.ylim(0, 1.5)plt.subplot(223)plt.semilogy(w, p, linewidth=2)plt.ylim(0, 1.5)plt.subplot(224)plt.loglog(w, p, linewidth=2)plt.ylim(0, 1.5)plt.show() wxPython wxPython是wxWidgets在python语言下的封装，wxWidgets是一个跨平台的GUI应用程序接口，使用C++编写 对于Python3，wxPython的下载地址,注意选择对应的python版本号以及电脑的位数 控件的事件 按钮点击 文本域内容的改变 鼠标滑过 鼠标双击 键盘按下 使用wxPython的绝对布局123456789101112131415161718192021222324252627282930313233343536373839# -*-coding:utf8-*-import wx'''堆砌各个控件，基于坐标位置的控件绝对布局'''class Lesson(wx.Frame): def __init__(self): wx.Frame.__init__(self, parent=None, id=-1, title=u'极客学院', size=(600, 600)) panel = wx.Panel(self, -1) self.Centre() button = wx.Button(panel, label=u'我是按钮', pos=(20, 0), size=(100, 100)) statictext = wx.StaticText(panel, -1, u'我是不能编辑的文本框', pos=(20, 100)) text = wx.TextCtrl(panel, -1, u'请在这里输入内容', pos=(200, 210)) password = wx.TextCtrl(panel, -1, u'请在这里输入内容', style=wx.TE_PASSWORD, pos=(200, 250)) mutiText = wx.TextCtrl(panel, -1, u'我是多行\\n文本框', style=wx.TE_MULTILINE, pos=(100, 300)) checkBox1 = wx.CheckBox(panel, -1, u\"我是复选框1\", pos=(150, 20)) checkBox2 = wx.CheckBox(panel, -1, u\"我是复选框2\", pos=(150, 40)) radio1 = wx.RadioButton(panel, -1, u\"我是单选按钮1\", pos=(150, 60), style=wx.RB_GROUP) radio2 = wx.RadioButton(panel, -1, u\"我是单选按钮2\", pos=(150, 80)) radio3 = wx.RadioButton(panel, -1, u\"我是单选按钮3\", pos=(150, 100)) radioList = [u'一组单选按钮之1', u'一组单选按钮之2', u'一组单选按钮之3'] wx.RadioBox(panel, -1, u\"一组单选按钮\", (10, 120), wx.DefaultSize, radioList, 2, wx.RA_SPECIFY_ROWS) jikexueyuan = [u'极', u'客', u'学', u'院', '1', '2', '3', '4', '5', '6'] listBox = wx.ListBox(panel, -1, pos=(300, 20), size=(100, 100), choices=jikexueyuan, style=wx.LB_MULTIPLE) img = wx.Image(r'python.gif', wx.BITMAP_TYPE_ANY).Scale(100, 200) sb1 = wx.StaticBitmap(panel, -1, wx.BitmapFromImage(img), pos=(300, 300))if __name__ == \"__main__\": app = wx.App() frame = Lesson() frame.Show() app.MainLoop() 使用wxPython的相对布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140# -*-coding:utf8-*-import wx'''基于Sizer的控件相对布局'''class Lesson(wx.Frame): def __init__(self): wx.Frame.__init__(self, parent=None, id=-1, title=u'极客学院', size=(600, 600)) self.panel = wx.Panel(self, -1) self.Centre() # 定义我们需要的各个控件 commandStatic = wx.StaticText(self.panel, -1, u'输命令:') writePyStatic = wx.StaticText(self.panel, -1, u'写代码:') commandText = wx.TextCtrl(self.panel, -1, u'') writePyText = wx.TextCtrl(self.panel, -1, u'''#-*-coding:utf-8-*-\\n#在这写Python代码''', style=wx.TE_MULTILINE, size=(300, 200)) send = wx.Button(self.panel, label=u'发送命令') clear = wx.Button(self.panel, label=u'清空命令') screen = wx.Button(self.panel, label=u'查看屏幕') serverList = ['192.168.0.4', '10.19.2.1', '192.168.0.111', '172.26.123.5', '192.168.6.11', '192.99.8.8'] server = wx.ListBox(self.panel, -1, size=(120, 100), choices=serverList, style=wx.LB_SINGLE) img = wx.Image(r'python_logo.gif', wx.BITMAP_TYPE_ANY).Scale(200, 200) screenBox = wx.StaticBitmap(self.panel, -1, wx.BitmapFromImage(img)) # 基于BoxSizer布局 # hBoxAll = wx.BoxSizer(wx.HORIZONTAL) # vBoxControl = wx.BoxSizer(wx.VERTICAL) # hBoxCommand = wx.BoxSizer(wx.HORIZONTAL) # vBoxWrite = wx.BoxSizer(wx.VERTICAL) # hBoxButton = wx.BoxSizer(wx.HORIZONTAL) # # hBoxCommand.Add(commandStatic, proportion=1, flag=wx.ALL | wx.EXPAND, border=5) # hBoxCommand.Add(commandText, proportion=2, flag=wx.ALL | wx.EXPAND, border=5) # # vBoxWrite.Add(writePyStatic, proportion=0, flag=wx.ALL | wx.EXPAND, border=5) # vBoxWrite.Add(writePyText, proportion=0, flag=wx.ALL | wx.EXPAND, border=5) # # vBoxControl.Add(hBoxCommand, proportion=0, flag=wx.ALL, border=5) # vBoxControl.Add(vBoxWrite, proportion=0, flag=wx.ALL, border=5) # # hBoxButton.Add(send, proportion=0, flag=wx.ALL, border=5) # hBoxButton.Add(clear, proportion=0, flag=wx.ALL, border=5) # hBoxButton.Add(screen, proportion=0, flag=wx.ALL, border=5) # # vBoxControl.Add(hBoxButton, proportion=0, flag=wx.ALL, border=5) # # hBoxAll.Add(server, proportion=1, flag=wx.ALL | wx.EXPAND, border=5) # hBoxAll.Add(vBoxControl, proportion=2, flag=wx.ALL | wx.EXPAND, border=5) # hBoxAll.Add(screenBox, proportion=3, flag=wx.ALL | wx.EXPAND, border=5) # # self.panel.SetSizer(hBoxAll) # hBoxAll.Fit(self) # 基于GridSizer布局 # gridSizerAll= wx.GridSizer(rows=3, cols=3, hgap=5, vgap=5) # gridSizerAll.AddMany([(server, 0, wx.EXPAND), (commandStatic, 0, wx.EXPAND), (commandText, 0, wx.EXPAND), # (writePyStatic, 0, wx.EXPAND), (send, 0, wx.EXPAND), (clear, 0, wx.EXPAND), # (writePyText, 0, wx.EXPAND), (screen, 0, wx.EXPAND), (screenBox, 0, wx.EXPAND)]) # self.panel.SetSizer(gridSizerAll) # gridSizerAll.Fit(self) #基于FlexGridSizer布局 # flexGridSizerAll = wx.FlexGridSizer(rows=3, cols=3, hgap=5, vgap=5) # flexGridSizerAll.AddMany([(server, 0, wx.EXPAND), (commandStatic, 0, wx.EXPAND), (commandText, 0, wx.EXPAND), # (writePyStatic, 0, wx.EXPAND), (send, 0, wx.EXPAND), (clear, 0, wx.EXPAND), # (writePyText, 0, wx.EXPAND), (screen, 0, wx.EXPAND), (screenBox, 0, wx.EXPAND)]) # self.panel.SetSizer(flexGridSizerAll) # # flexGridSizerAll.AddGrowableCol(2, 1) # flexGridSizerAll.AddGrowableRow(2, 1) # # flexGridSizerAll.Fit(self) #基于GirdBagSizer布局 gridBagSizerAll = wx.GridBagSizer(hgap=5, vgap=5) gridBagSizerAll.Add(server, pos=(0, 0), flag=wx.ALL | wx.EXPAND, span=(7, 2), border=5) gridBagSizerAll.Add(commandStatic, pos=(0, 2), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, border=5) gridBagSizerAll.Add(commandText, pos=(0, 3), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, span=(1, 2), border=5) gridBagSizerAll.Add(writePyStatic, pos=(1, 2), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, span=(1, 3), border=5) gridBagSizerAll.Add(writePyText, pos=(2, 2), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, span=(4, 3), border=5) gridBagSizerAll.Add(send, pos=(6, 2), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, span=(1, 1), border=5) gridBagSizerAll.Add(clear, pos=(6, 3), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, span=(1, 1), border=5) gridBagSizerAll.Add(screen, pos=(6, 4), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, span=(1, 1), border=5) gridBagSizerAll.Add(screenBox, pos=(0, 5), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, span=(7, 2), border=5) self.panel.SetSizer(gridBagSizerAll) self.SetSizeHints(250, 200, 700, 400) # 设定窗口的最大最小值 # gridBagSizerAll.AddGrowableCol(0, 1) # gridBagSizerAll.AddGrowableCol(1, 1) # gridBagSizerAll.AddGrowableCol(2, 1) # gridBagSizerAll.AddGrowableCol(3, 1) # gridBagSizerAll.AddGrowableCol(4, 1) # gridBagSizerAll.AddGrowableCol(5, 1) # gridBagSizerAll.AddGrowableCol(6, 1) # # gridBagSizerAll.AddGrowableRow(0, 1) # gridBagSizerAll.AddGrowableRow(1, 1) # gridBagSizerAll.AddGrowableRow(2, 1) # gridBagSizerAll.AddGrowableRow(3, 1) # gridBagSizerAll.AddGrowableRow(4, 1) # gridBagSizerAll.AddGrowableRow(5, 1) # gridBagSizerAll.AddGrowableRow(6, 1) gridBagSizerAll.Fit(self)if __name__ == \"__main__\": app = wx.App() frame = Lesson() frame.Show() app.MainLoop() wxPython事件编程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119# -*-coding:utf8-*-import timeimport wx'''基于Sizer的控件相对布局'''class Example3(wx.Frame): def __init__(self): wx.Frame.__init__(self, parent=None, id=-1, title=u'极客学院', size=(600, 600)) self.panel = wx.Panel(self, -1) self.Centre() # 定义我们需要的各个控件 commandStatic = wx.StaticText(self.panel, -1, u'输命令:') writePyStatic = wx.StaticText(self.panel, -1, u'写代码:') self.commandText = wx.TextCtrl(self.panel, -1, u'') self.writePyText = wx.TextCtrl(self.panel, -1, u'''#-*-coding:utf-8-*-\\n#在这写Python代码''', style=wx.TE_MULTILINE, size=(300, 200)) self.send = wx.Button(self.panel, label=u'发送命令') self.clear = wx.Button(self.panel, label=u'清空命令') self.screen = wx.Button(self.panel, label=u'查看屏幕') self.serverList = ['192.168.0.4', '10.19.2.1', '192.168.0.111', '172.26.123.5', '192.168.6.11', '192.99.8.8'] self.server = wx.ListBox(self.panel, -1, size=(120, 100), choices=self.serverList, style=wx.LB_SINGLE) img = wx.Image(r'python_logo.gif', wx.BITMAP_TYPE_ANY).Scale(200, 200) self.screenBox = wx.StaticBitmap(self.panel, -1, wx.BitmapFromImage(img)) self.Bind(wx.EVT_BUTTON, self.onSend, self.send) self.Bind(wx.EVT_BUTTON, self.onClear, self.clear) self.Bind(wx.EVT_BUTTON, self.onScreen, self.screen) # 基于GirdBagSizer布局 self.gridBagSizerAll = wx.GridBagSizer(hgap=5, vgap=5) self.gridBagSizerAll.Add(self.server, pos=(0, 0), flag=wx.ALL | wx.EXPAND, span=(7, 2), border=5) self.gridBagSizerAll.Add(commandStatic, pos=(0, 2), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, border=5) self.gridBagSizerAll.Add(self.commandText, pos=(0, 3), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, span=(1, 2), border=5) self.gridBagSizerAll.Add(writePyStatic, pos=(1, 2), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, span=(1, 3), border=5) self.gridBagSizerAll.Add(self.writePyText, pos=(2, 2), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, span=(4, 3), border=5) self.gridBagSizerAll.Add(self.send, pos=(6, 2), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, span=(1, 1), border=5) self.gridBagSizerAll.Add(self.clear, pos=(6, 3), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, span=(1, 1), border=5) self.gridBagSizerAll.Add(self.screen, pos=(6, 4), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, span=(1, 1), border=5) self.gridBagSizerAll.Add(self.screenBox, pos=(0, 5), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, span=(7, 2), border=5) self.panel.SetSizer(self.gridBagSizerAll) # self.SetSizeHints(250, 200, 700, 400) #设定窗口的最大最小值 self.gridBagSizerAll.AddGrowableCol(0, 1) self.gridBagSizerAll.AddGrowableCol(1, 1) self.gridBagSizerAll.AddGrowableCol(2, 1) self.gridBagSizerAll.AddGrowableCol(3, 1) self.gridBagSizerAll.AddGrowableCol(4, 1) self.gridBagSizerAll.AddGrowableCol(5, 1) self.gridBagSizerAll.AddGrowableCol(6, 1) self.gridBagSizerAll.AddGrowableRow(0, 1) self.gridBagSizerAll.AddGrowableRow(1, 1) self.gridBagSizerAll.AddGrowableRow(2, 1) self.gridBagSizerAll.AddGrowableRow(3, 1) self.gridBagSizerAll.AddGrowableRow(4, 1) self.gridBagSizerAll.AddGrowableRow(5, 1) self.gridBagSizerAll.AddGrowableRow(6, 1) self.gridBagSizerAll.Fit(self) def onSend(self, event): time.sleep(0.5) if self.server.GetSelection() != -1: server = self.serverList[self.server.GetSelection()] else: server = u'未选择服务器' command = self.commandText.GetValue() writePy = self.writePyText.GetValue() print(u'选中的服务器是： %s' % server) print(u'执行的内置命令是： %s' % command) print(u'写入的Python代码是:\\n%s' % writePy) def onClear(self, event): self.commandText.Clear() self.writePyText.Clear() self.writePyText.AppendText(u'''#-*-coding:utf-8-*-\\n#在这些Python代码''') def onScreen(self, event): img = wx.Image(r'python.gif', wx.BITMAP_TYPE_ANY).Scale(300, 200) self.screenBox.SetBitmap(wx.BitmapFromImage(img)) self.gridBagSizerAll.Fit(self)if __name__ == \"__main__\": app = wx.App() frame = Example3() frame.Show() app.MainLoop() Python中的多线程编程 thread.start_new_thread(函数名，（参数1，参数2，···）) 或者使用Threading模块创建线程 scipy库 解非线性方程组 scipy.optimize子库中的fsolve函数：fsolve(函数, 初始解, 雅可比矩阵)求解非线性方程组12345678910111213141516171819202122232425from math import sin, cosfrom scipy.optimize import fsolvedef func(x): x0, x1, x2 = x.tolist() return [ 5 * x1 + 3, 4 * x0 * x0 - 2 * sin(x1 * x2), x1 * x2 - 1.5 ]def j(x): x0, x1, x2 = x.tolist() return [ [0, 5, 0], [8 * x0, -2 * x2 * cos(x1 * x2), -2 * x1 * cos(x1 * x2)], [0, x2, x1] ]r = fsolve(func, [1, 1, 1], fprime=j)print(r) 数值积分 scipy.integrate子库中的quad函数： 一重积分：quad(函数，定积分下限，定积分上限) 双重积分：dblquad 三重积分：tplquad求解一重积分123456789from scipy.integrate import quaddef func(x): return (1 - x * x) ** 0.5p, err = quad(func, -1, 1)print(2 * p) 求解常微分方程 scipy.integrate子库中的odeint常微分方程组求解方法123456789101112131415161718from scipy.integrate import odeintimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dimport matplotlib.pyplot as pltdef lorenz(w, t, p, r, b): x, y, z = w return np.array([p * (y - x), x * (r - z), x * y - b * z])t = np.arange(0, 30, 0.01)track = odeint(lorenz, (0.0, 1.00, 0.0), t, args=(10.0, 28.0, 3.0))fig = plt.figure()ax = Axes3D(fig)ax.plot(track[:, 0], track[:,1], track[:,2])plt.show() 数值微分 scipu.misc子库中的derivative求解数值微分123456789import numpy as npimport matplotlib.pyplot as pltfrom scipy.misc import derivativeEx = lambda q: q ** 2x0 = np.linspace(-10, 10, 1000)dEx = derivative(Ex, x0, dx=1e-6)plt.plot(x0, dEx)plt.show() mpl_toolkits库3D效果图12345678910111213from mpl_toolkits.mplot3d import Axes3Dimport numpy as npimport matplotlib.pyplot as pltfig = plt.figure()ax = Axes3D(fig)th = np.linspace(-4 * np.pi, 4 * np.pi, 100)z = np.linspace(-2, 2, 100)r = z ** 2 + 1x = r * np.sin(th)y = r * np.cos(th)ax.plot() suda-morris","tags":[{"name":"Python","slug":"Python","permalink":"https://suda-morris.github.io/tags/Python/"}]},{"title":"Microsoft Office Word Skills","date":"2015-05-25T02:45:00.000Z","path":"2015/05/25/microsoft-office/","text":"从任意页开始设置页码 将鼠标光标点击到开始编页码的前一页末尾 点击菜单栏的页面布局 在页面布局栏目下，点击分隔符后面的倒三角 弹出分隔符的相关功能栏目，点击下一页 双击页眉的位置，激活页眉编辑 在需要开始编页码的那页页眉处点击链接到前一页页眉 移动光标到本页的页脚，并激活页脚编辑 在同一页（即需要开始编页码的那页）的页脚处点击链接到前一页页眉 然后在需要开始编页码的页脚处点击页码-&gt;设置页码格式，将起始页设置为1 点击进入插入菜单栏，选择页码,选择喜欢的页码格式 公式居中标号居右 在视图工具栏中打开标尺 公式先居中，在标尺上记录下此时公式的位置，根据标号长度大于预估距离页边的距离，并在标尺上做标记(此时应该有两个标记)，设置标记属性(只要在其中一个标记上双击即可)，将公式标号的位置属性设置为【右对齐】 将公式靠左对齐，紧跟其后写上标号。 光标紧跟公式前面，按下Tab键，公式即可跳到标尺上的第一个标记处。光标置于公式标号前，再按下Tab键，公式标号跳到靠近标尺末尾处，此时鼠标拖动第二个标记至标尺最右端，公式标号保证靠右对齐！ suda-morris","tags":[{"name":"Word","slug":"Word","permalink":"https://suda-morris.github.io/tags/Word/"}]},{"title":"Install Ubuntu Mate LTS","date":"2015-05-24T12:02:00.000Z","path":"2015/05/24/ubuntu-mate/","text":"Ubuntu-Mate14.04.2-LTS安装 进入Ubutnu-Mate官网下载ISO镜像后安装到虚拟机 安装结束后，打开自带的软件中心，进入-&gt;编辑-&gt;软件源，选择访问速度最快的国内镜像站(软件可以自动选取速度最快的站点) 依次安装以下软件，安装命令为:sudo apt-get install 文本编辑器:gedit vim 基本开发工具：build-essential 生成工程Makefile的工具：autoconf automake 词法扫描分析工具：flex bison texinfo git-core gnupg gperf valgrind C语言函数用户手册：manpages-dev libncurses-dev libsdl-dev libesd0-dev libwxgtk2.6-dev ncurses-dev 其他程序的用户手册：binutils-doc cpp-doc gcc-doc glib-doc stl-manual docbook-utils 其他：chrpath socat diffstat texi2html mercurial groff asciidoc 压缩工具： zip 网络工具: curl 串口工具：minicom，完了以后修改minicom的配置权限：sudo chown morris：morris /etc/minicom/minirc.dfl Ubuntu-Tweak工具安装： 添加tweak源：sudo add-apt-repository ppa:tualatrix/ppa 更新：sudo apt-get update 安装ubuntu-tweak：sudo apt-get install ubuntu-tweak 超强vim配置文件：wget -qO- https://raw.github.com/ma6174/vim/master/setup.sh | sh -x 下载工具：uget与aria2 sudo add-apt-repository ppa:plushuang-tw/uget-stable sudo ap-get update sudo apt-get install uget sudo apt-get install aria2 打开uget软件，进入插件设置，选择aria插件 修改最大连接数为16 输入法工具安装：fcitx: sudo apt-get install fcitx-table-wbpy 进入语言支持-&gt;把键盘输入方式系统改为fcitx，重启系统 用WPS替换掉Ubuntu自带的Office 去Qt官网下载QtCreator 安装Lua5.3： 下载安装源码 安装库文件：sudo apt-get install libreadline和sudo apt-get install libreadline-gplv2-dev 进入源码顶层目录，修改Makefile里面的软件安装地址 修改完成后，make linux然后make install 编译crosstool-ng需要的安装环境 sudo apt-get install bison flex texinfo automake libtool cvs patch curl gcj subversion gawk cvsd gperf libexpat1-dev VirtualBox安装增强工具 进入VirtualBox设备-&gt;安装增强工具 在Ubuntu中，进入挂在的CD(一般在media下)，运行sudo ./VBoxLinuxAdditions.run后等待完成安装 设置root密码：sudo passwd root 修改Ubuntu默认JDK配置 将要添加的JDK加入Java菜单选项 update-alternatives --install /usr/bin/java java /usr/lib/jvm/java/jdk1.6.0_12/bin/java 300 update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java/jdk1.6.0_12/bin/javac 300 修改默认JDK sudo update-alternatives --config java NFS远程文件系统 安装NFS服务器：sudo apt-get install nfs-kernel-server portmap 配置远程主机共享目录： 设置一个共享目录的方法是修改/etc/exports文件，增加一行例如:/embeded/WenRisOS/NFS_doc *(rw,sync,no_root_squash) 重启服务:sudo /etc/init.d/nfs-kernel-server restart 检测NFS服务是否设置正常：showmount -e 目标板挂载远程主机：mount -o nolock -t nfs 192.168.1.88:/embeded/WenRisOS/NFS_doc /mnt 使用uboot的nfs命令下载远程主机文件到开发板内存：nfs 0x32000000 192.168.1.11:/work/system/linux/arch/arm/boot/uImage FTP服务器软件配置： 安装FTP服务：sudo apt-get install vsftpd 修改FTP服务配置文件:sudo vim /etc/vsftpd.conf 使能listen,local_enable,write_enable 重启FTP服务 sudo /etc/init.d/vsftpd restart JLink安装 官网下载J-Link安装压缩包 注意选择Linux安装包的时候匹配操作系统的位数，这里下载了64位Linux系统的TGA压缩包，版本5.0 下载好的压缩包解压缩，打开里面的README.txt,按照其要求作相应的操作，各个本版可能要求不同，拿5.0来说，这里需要执行命令：sudo cp 99-jlink.rules /etc/udev/rules.d/ 最后接入JLink的USB接口，打开软件：./JLinkExe,如果显示usb连接不上，请检查USB是否连接可靠，虚拟机是否已经从实体机那获得了该JLink接口，多插拔几次，在该软件中使用命令usb可以尝试再次连接usb接口，如果成功，会出现类似如下的文字：123456789101112131415J-Link&gt;usbConnecting to J-Link via USB (Port: 0)DLL version V5.00, compiled Jun 8 2015 21:14:03Firmware: J-Link ARM V8 compiled Nov 28 2014 13:44:46Hardware: V8.00S/N: 158000503 Feature(s): RDI,FlashDL,FlashBP,JFlash,GDBFull VTarget = 3.319VInfo: TotalIRLen = 9, IRPrint = 0x0011Found 2 JTAG devices, Total IRLen = 5: #0 Id: 0x2B900F0F, IRLen: 04, IRPrint: 0x0, ARM ETB #1 Id: 0x07B76F0F, IRLen: 05, IRPrint: 0x1, ARM1176 CoreARM11 identified.Target interface speed: 100 kHzJ-Link&gt; 常见问题及解决方法 在Ubuntu登陆界面输入密码之后，黑屏一闪后，又跳转到登录界面。 原因：主目录下的.Xauthority文件拥有者变成了root，从而以用户登陆的时候无法都取.Xauthority文件。 方法1：将.Xauthority的拥有者改为登陆用户。开机后在登陆界面按下shift + ctrl + F1进入tty命令行终端登陆后输入: sudo chown 用户名:用户名 .Xauthority 方法2：命令行输入：dpkg-reconfigure lightdm重新配置登陆器，重启 如何在64位系统上编译32位可执行程序 确认当前架构为64位的内核 打开终端输入dpkg --print-architecture,如果看到amd64表示已经拥有了64位架构的内核 确认打开了多核架构的支持功能 打开终端输入dpkg --print-foreign-architecture,如果看到输出i386表示已经打开了多架构支持 如果没有打开，使用如下方法： 下载更新然后运行：sudo dpkg --add-architecture i386，然后sudo apt-get update 输入sudo apt-get -f dist-upgrade检查已经拥有的库文件是否有更新版本 安装兼容包 sudo apt-get install libc6:i386 sudo apt-get install gcc-multilib g++-multilib sudo apt-get install lib32z1 lib32ncurses5 lib32bz2-1.0 libgtk2.0-0:i386 libpangox-1.0-0:i386 libpangoxft-1.0-0:i386 libidn11:i386 gstreamer0.10-pulseaudio:i386 gstreamer0.10-plugins-base:i386 gstreamer0.10-plugins-good:i386 注意，在13.10后Ubuntu不提供ia32-libs的套件了，但是还是可以这样来安装： Ubuntu14.04安装ia32-libs库123456789sudo -icd /etc/apt/sources.list.decho \"deb http://archive.ubuntu.com/ubuntu/ raring main restricted universe multiverse\" &gt;ia32-libs-raring.listapt-get updateapt-get install ia32-libsrm /etc/apt/sources.list.d/ia32-libs-raring.listapt-get updateexitsudo apt-get install gcc-multilib 如何添加应用程序的快捷方式，以Eclipse软件为例 首先进入/usr/share/applications目录下，创建eclipse.desktop 编辑eclipse.desktop，内容如下：[Desktop Entry] Type=Application Name=Eclipse --应用程序名 Comment=Eclipse --程序简介 Icon=/home/lai/Software/eclipse/icon.xpm --图标地址 Exec=/home/lai/Software/eclipse/eclipse --应用程序地址 Terminal=false Categories=Development;IDE;Java; 如何通过搜索的方式安装软件 例如：sudo apt-cache search nfs- suda-morris","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://suda-morris.github.io/tags/Ubuntu/"}]}]